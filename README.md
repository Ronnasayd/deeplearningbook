# Sumário

- [Capítulo 1 – Deep Learning e a Tempestade Perfeita](#capitulo-1---deep-learning-e-a-tempestade-perfeita)

- [Capítulo 2 – Uma Breve História das Redes Neurais Artificiais](#capitulo-2---uma-breve-historia-das-redes-neurais-artificiais)

- [Capítulo 3 – O Que São Redes Neurais Artificiais Profundas ou Deep Learning?](#capitulo-3---o-que-sao-redes-neurais-artificiais-profundas-ou-deep-learning?)

- [Capítulo 4 – O Neurônio, Biológico e Matemático](#capitulo-4---o-neuronio,-biologico-e-matematico)

- [Capítulo 5 – Usando Redes Neurais Para Reconhecer Dígitos Manuscritos](#capitulo-5---usando-redes-neurais-para-reconhecer-digitos-manuscritos)

- [Capítulo 6 – O Perceptron – Parte 1](#capitulo-6---o-perceptron---parte-1)

- [Capítulo 7 – O Perceptron – Parte 2](#capitulo-7---o-perceptron---parte-2)

- [Capítulo 8 – Função de Ativação](#capitulo-8---funcao-de-ativacao)

- [Capítulo 9 – A Arquitetura das Redes Neurais](#capitulo-9---a-arquitetura-das-redes-neurais)

- [Capítulo 10 – As 10 Principais Arquiteturas de Redes Neurais](#capitulo-10---as-10-principais-arquiteturas-de-redes-neurais)

- [Capítulo 11 – Design De Uma Rede Neural Para Reconhecimento de Dígitos](#capitulo-11---design-de-uma-rede-neural-para-reconhecimento-de-digitos)

- [Capítulo 12 – Aprendizado Com a Descida do Gradiente](#capitulo-12---aprendizado-com-a-descida-do-gradiente)

- [Capítulo 13 – Construindo Uma Rede Neural Com Linguagem Python](#capitulo-13---construindo-uma-rede-neural-com-linguagem-python)

- [Capítulo 14 – Algoritmo Backpropagation Parte 1 – Grafos Computacionais e Chain Rule](#capitulo-14---algoritmo-backpropagation-parte-1---grafos-computacionais-e-chain-rule)

- [Capítulo 15 – Algoritmo Backpropagation Parte 2 – Treinamento de Redes Neurais](#capitulo-15---algoritmo-backpropagation-parte-2---treinamento-de-redes-neurais)

- [Capítulo 16 – Algoritmo Backpropagation em Python](#capitulo-16---algoritmo-backpropagation-em-python)

- [Capítulo 17 – Cross-Entropy Cost Function](#capitulo-17---cross-entropy-cost-function)

- [Capítulo 18 – Entropia Cruzada Para Quantificar a Diferença Entre Duas Distribuições de Probabilidade](#capitulo-18---entropia-cruzada-para-quantificar-a-diferenca-entre-duas-distribuicoes-de-probabilidade)

- [Capítulo 19 – Overfitting e Regularização – Parte 1](#capitulo-19---overfitting-e-regularizacao---parte-1)

- [Capítulo 20 – Overfitting e Regularização – Parte 2](#capitulo-20---overfitting-e-regularizacao---parte-2)

- [Capítulo 21 – Afinal, Por Que a Regularização Ajuda a Reduzir o Overfitting?](#capitulo-21---afinal,-por-que-a-regularizacao-ajuda-a-reduzir-o-overfitting?)

- [Capítulo 22 – Regularização L1](#capitulo-22---regularizacao-l1)

- [Capítulo 23 – Como Funciona o Dropout?](#capitulo-23---como-funciona-o-dropout?)

- [Capítulo 24 – Expandir Artificialmente os Dados de Treinamento](#capitulo-24---expandir-artificialmente-os-dados-de-treinamento)

- [Capítulo 25 – Inicialização de Pesos em Redes Neurais Artificiais](#capitulo-25---inicializacao-de-pesos-em-redes-neurais-artificiais)

- [Capítulo 26 – Como Escolher os Hiperparâmetros de Uma Rede Neural](#capitulo-26---como-escolher-os-hiperparametros-de-uma-rede-neural)

- [Capítulo 27 – A Taxa de Aprendizado de Uma Rede Neural](#capitulo-27---a-taxa-de-aprendizado-de-uma-rede-neural)

- [Capítulo 28 – Usando Early Stopping Para Definir o Número de Épocas de Treinamento](#capitulo-28---usando-early-stopping-para-definir-o-numero-de-epocas-de-treinamento)

- [Capítulo 29 – Definindo o Tamanho do Mini-Batch](#capitulo-29---definindo-o-tamanho-do-mini-batch)

- [Capítulo 30 – Variações do Stochastic Gradient Descent – Hessian Optimization e Momentum](#capitulo-30---variacoes-do-stochastic-gradient-descent---hessian-optimization-e-momentum)

- [Capítulo 31 – As Redes Neurais Artificiais Podem Computar Qualquer Função?](#capitulo-31---as-redes-neurais-artificiais-podem-computar-qualquer-funcao?)

- [Capítulo 32 – Como Uma Rede Neural Artificial Encontra a Aproximação de Uma Função](#capitulo-32---como-uma-rede-neural-artificial-encontra-a-aproximacao-de-uma-funcao)

- [Capítulo 33 – Por que as Redes Neurais Profundas São Difíceis de Treinar?](#capitulo-33---por-que-as-redes-neurais-profundas-sao-dificeis-de-treinar?)

- [Capítulo 34 – O Problema da Dissipação do Gradiente](#capitulo-34---o-problema-da-dissipacao-do-gradiente)

- [Capítulo 35 – A Matemática do Problema de Dissipação do Gradiente em Deep Learning](#capitulo-35---a-matematica-do-problema-de-dissipacao-do-gradiente-em-deep-learning)

- [Capítulo 36 – Outros Problemas com o Gradiente em Redes Neurais Artificiais](#capitulo-36---outros-problemas-com-o-gradiente-em-redes-neurais-artificiais)

- [Capítulo 37 – O Efeito do Batch Size no Treinamento de Redes Neurais Artificiais](#capitulo-37---o-efeito-do-batch-size-no-treinamento-de-redes-neurais-artificiais)

- [Capítulo 38 – O Efeito da Taxa de Aprendizagem no Treinamento de Redes Neurais Artificiais](#capitulo-38---o-efeito-da-taxa-de-aprendizagem-no-treinamento-de-redes-neurais-artificiais)

- [Capítulo 39 – Relação Entre o Tamanho do Lote e o Cálculo do Gradiente](#capitulo-39---relacao-entre-o-tamanho-do-lote-e-o-calculo-do-gradiente)

- [Capítulo 40 – Introdução às Redes Neurais Convolucionais](#capitulo-40---introducao-as-redes-neurais-convolucionais)

- [Capítulo 41 – Campos Receptivos Locais em Redes Neurais Convolucionais](#capitulo-41---campos-receptivos-locais-em-redes-neurais-convolucionais)

- [Capítulo 42 – Compartilhamento de Pesos em Redes Neurais Convolucionais](#capitulo-42---compartilhamento-de-pesos-em-redes-neurais-convolucionais)

- [Capítulo 43 – Camadas de Pooling em Redes Neurais Convolucionais](#capitulo-43---camadas-de-pooling-em-redes-neurais-convolucionais)

- [Capítulo 44 – Reconhecimento de Imagens com Redes Neurais Convolucionais em Python – Parte 1](#capitulo-44---reconhecimento-de-imagens-com-redes-neurais-convolucionais-em-python---parte-1)

- [Capítulo 45 – Reconhecimento de Imagens com Redes Neurais Convolucionais em Python – Parte 2](#capitulo-45---reconhecimento-de-imagens-com-redes-neurais-convolucionais-em-python---parte-2)

- [Capítulo 46 – Reconhecimento de Imagens com Redes Neurais Convolucionais em Python – Parte 3](#capitulo-46---reconhecimento-de-imagens-com-redes-neurais-convolucionais-em-python---parte-3)

- [Capítulo 47 – Reconhecimento de Imagens com Redes Neurais Convolucionais em Python – Parte 4](#capitulo-47---reconhecimento-de-imagens-com-redes-neurais-convolucionais-em-python---parte-4)

- [Capítulo 48 – Redes Neurais Recorrentes](#capitulo-48---redes-neurais-recorrentes)

- [Capítulo 49 – A Matemática do Backpropagation Through Time (BPTT)](#capitulo-49---a-matematica-do-backpropagation-through-time-(bptt))

- [Capítulo 50 – A Matemática da Dissipação do Gradiente e Aplicações das RNNs](#capitulo-50---a-matematica-da-dissipacao-do-gradiente-e-aplicacoes-das-rnns)

- [Capítulo 51 – Arquitetura de Redes Neurais Long Short Term Memory (LSTM)](#capitulo-51---arquitetura-de-redes-neurais-long-short-term-memory-(lstm))

- [Capítulo 52 – Arquitetura de Redes Neurais Gated Recurrent Unit (GRU)](#capitulo-52---arquitetura-de-redes-neurais-gated-recurrent-unit-(gru))

- [Capítulo 53 – Matemática na GRU, Dissipação e Clipping do Gradiente](#capitulo-53---matematica-na-gru,-dissipacao-e-clipping-do-gradiente)

- [Capítulo 54 – Introdução às Redes Adversárias Generativas (GANs – Generative Adversarial Networks)](#capitulo-54---introducao-as-redes-adversarias-generativas-(gans---generative-adversarial-networks))

- [Capítulo 55 – Geração de Variáveis Aleatórias – Uma das Bases dos Modelos Generativos em GANs (Generative Adversarial Networks)](#capitulo-55---geracao-de-variaveis-aleatorias---uma-das-bases-dos-modelos-generativos-em-gans-(generative-adversarial-networks))

- [Capítulo 56 – Modelos Generativos – O Diferencial das GANs (Generative Adversarial Networks)](#capitulo-56---modelos-generativos---o-diferencial-das-gans-(generative-adversarial-networks))

- [Capítulo 57 – Os Detalhes Matemáticos das GANs (Generative Adversarial Networks)](#capitulo-57---os-detalhes-matematicos-das-gans-(generative-adversarial-networks))

- [Capítulo 58 – Introdução aos Autoencoders](#capitulo-58---introducao-aos-autoencoders)

- [Capítulo 59 – Principais Tipos de Redes Neurais Artificiais Autoencoders](#capitulo-59---principais-tipos-de-redes-neurais-artificiais-autoencoders)

- [Capítulo 60 – Variational Autoencoders (VAEs) – Definição, Redução de Dimensionalidade, Espaço Latente e Regularização](#capitulo-60---variational-autoencoders-(vaes)---definicao,-reducao-de-dimensionalidade,-espaco-latente-e-regularizacao)

- [Capítulo 61 – A Matemática dos Variational Autoencoders (VAEs)](#capitulo-61---a-matematica-dos-variational-autoencoders-(vaes))

- [Capítulo 62 – O Que é Aprendizagem Por Reforço?](#capitulo-62---o-que-e-aprendizagem-por-reforco?)

- [Capítulo 63 – Aplicações da Aprendizagem Por Reforço no Mundo Real](#capitulo-63---aplicacoes-da-aprendizagem-por-reforco-no-mundo-real)

- [Capítulo 64 – Componentes do Aprendizado Por Reforço (Reinforcement Learning)](#capitulo-64---componentes-do-aprendizado-por-reforco-(reinforcement-learning))

- [Capítulo 65 – Distribuições de Probabilidade, Redes Neurais e Reinforcement Learning](#capitulo-65---distribuicoes-de-probabilidade,-redes-neurais-e-reinforcement-learning)

- [Capítulo 66 – Algoritmo de Agente Baseado em IA com Reinforcement Learning – Parte 1](#capitulo-66---algoritmo-de-agente-baseado-em-ia-com-reinforcement-learning---parte-1)

- [Capítulo 67 – Algoritmo de Agente Baseado em IA com Reinforcement Learning – Parte 2](#capitulo-67---algoritmo-de-agente-baseado-em-ia-com-reinforcement-learning---parte-2)

- [Capítulo 68 – Algoritmo de Agente Baseado em IA com Reinforcement Learning – Q-Learning](#capitulo-68---algoritmo-de-agente-baseado-em-ia-com-reinforcement-learning---q-learning)

- [Capítulo 69 – Treinando Um Agente Baseado em IA Para Jogar Box no Atari Usando Linguagem Python](#capitulo-69---treinando-um-agente-baseado-em-ia-para-jogar-box-no-atari-usando-linguagem-python)

- [Capítulo 70 – Deep Q-Network e Processos de Decisão de Markov](#capitulo-70---deep-q-network-e-processos-de-decisao-de-markov)

- [Capítulo 71 – Inteligência Artificial Para Jogar Blackjack – Parte 1](#capitulo-71---inteligencia-artificial-para-jogar-blackjack---parte-1)

- [Capítulo 72 – Inteligência Artificial Para Jogar Blackjack – Parte 2](#capitulo-72---inteligencia-artificial-para-jogar-blackjack---parte-2)

- [Capítulo 73 – Inteligência Artificial Para Jogar Blackjack – Parte 3](#capitulo-73---inteligencia-artificial-para-jogar-blackjack---parte-3)

- [Capítulo 74 – Inteligência Artificial Para Jogar Blackjack – Parte 4](#capitulo-74---inteligencia-artificial-para-jogar-blackjack---parte-4)

- [Capítulo 75 – Inteligência Artificial Para Jogar Blackjack – Parte 5](#capitulo-75---inteligencia-artificial-para-jogar-blackjack---parte-5)

- [Capítulo 76 – O Que é BERT (Bidirectional Encoder Representations from Transformers)?](#capitulo-76---o-que-e-bert-(bidirectional-encoder-representations-from-transformers)?)

- [Capítulo 77 – Modelo BERT Para Processamento de Linguagem Natural](#capitulo-77---modelo-bert-para-processamento-de-linguagem-natural)

- [Capítulo 78 – Modelo BERT – Previsão da Próxima Frase](#capitulo-78---modelo-bert---previsao-da-proxima-frase)

- [Capítulo 79 – Conhecendo o Modelo GPT-3 (Generative Pre-trained Transformer)](#capitulo-79---conhecendo-o-modelo-gpt-3-(generative-pre-trained-transformer))

- [Capítulo 80 – Melhorando a Compreensão da Linguagem Por Meio do Pré-treinamento Generativo (GPT-1)](#capitulo-80---melhorando-a-compreensao-da-linguagem-por-meio-do-pre-treinamento-generativo-(gpt-1))

- [Capítulo 81 – Modelos de Linguagem Como Tarefas Não Supervisionadas (GPT-2)](#capitulo-81---modelos-de-linguagem-como-tarefas-nao-supervisionadas-(gpt-2))

- [Capítulo 82 – GPT-3 – Características e Limitações](#capitulo-82---gpt-3---caracteristicas-e-limitacoes)

- [Capítulo 83 – Liquid Neural Network – Rede Neural Líquida](#capitulo-83---liquid-neural-network---rede-neural-liquida)

- [Capítulo 84 – CLIP (Contrastive Language Image Pre-training): Conectando Texto e Imagens](#capitulo-84---clip-(contrastive-language-image-pre-training):-conectando-texto-e-imagens)

- [Capítulo 85 – Transformadores – O Estado da Arte em Processamento de Linguagem Natural](#capitulo-85---transformadores---o-estado-da-arte-em-processamento-de-linguagem-natural)

- [Capítulo 86 – Como Funcionam os Transformadores em Processamento de Linguagem Natural – Parte 1](#capitulo-86---como-funcionam-os-transformadores-em-processamento-de-linguagem-natural---parte-1)

- [Capítulo 87 – Como Funcionam os Transformadores em Processamento de Linguagem Natural – Parte 2](#capitulo-87---como-funcionam-os-transformadores-em-processamento-de-linguagem-natural---parte-2)

- [Capítulo 88 – Como Funcionam os Transformadores em Processamento de Linguagem Natural – Parte 3](#capitulo-88---como-funcionam-os-transformadores-em-processamento-de-linguagem-natural---parte-3)

- [Capítulo 89 – Como Funcionam os Transformadores em Processamento de Linguagem Natural – Parte 4](#capitulo-89---como-funcionam-os-transformadores-em-processamento-de-linguagem-natural---parte-4)

- [Capítulo 90 – Como Funcionam os Transformadores em Processamento de Linguagem Natural – Parte 5](#capitulo-90---como-funcionam-os-transformadores-em-processamento-de-linguagem-natural---parte-5)

- [Capítulo 91 – Machine Learning – Guia Definitivo – Parte 1](#capitulo-91---machine-learning---guia-definitivo---parte-1)

- [Capítulo 92 – Machine Learning – Guia Definitivo – Parte 2](#capitulo-92---machine-learning---guia-definitivo---parte-2)

- [Capítulo 93 – Machine Learning – Guia Definitivo – Parte 3](#capitulo-93---machine-learning---guia-definitivo---parte-3)

- [Capítulo 94 – Machine Learning – Guia Definitivo – Parte 4](#capitulo-94---machine-learning---guia-definitivo---parte-4)

- [Capítulo 95 – Machine Learning – Guia Definitivo – Parte 5](#capitulo-95---machine-learning---guia-definitivo---parte-5)

- [Capítulo 96 – Machine Learning – Guia Definitivo – Parte 6](#capitulo-96---machine-learning---guia-definitivo---parte-6)

- [Capítulo 97 – Machine Learning – Guia Definitivo – Parte 7](#capitulo-97---machine-learning---guia-definitivo---parte-7)

- [Capítulo 98 – Machine Learning – Guia Definitivo – Parte 8](#capitulo-98---machine-learning---guia-definitivo---parte-8)

- [Capítulo 99 – Machine Learning – Guia Definitivo – Parte 9](#capitulo-99---machine-learning---guia-definitivo---parte-9)

- [Capítulo 100 – Machine Learning – Guia Definitivo – Parte 10](#capitulo-100---machine-learning---guia-definitivo---parte-10)



<div id="capitulo-1---deep-learning-e-a-tempestade-perfeita"></div>

# Capítulo 1 – Deep Learning e a Tempestade Perfeita


O interesse pela Aprendizagem de Máquina (Machine Learning) explodiu na última década. O mundo a nossa volta está passando por uma transformação e vemos uma interação cada vez maior das aplicações de computador com os seres humanos. Softwares de detecção de spam, sistemas de recomendação, marcação em fotos de redes sociais, assistentes pessoais ativados por voz, carros autônomos, smartphones com reconhecimento facial e muito mais.


E o interesse por Machine Learning se mostra ainda mais evidente pelo número cada vez maior de conferências, meetups, artigos, livros, cursos, buscas no Google e profissionais e empresas procurando compreender o que é e como usar aprendizagem de máquina, embora muitos ainda confundem o que podem fazer com o que desejam fazer. Não há como ficar indiferente a esta revolução trazida pela aprendizagem de máquina e, segundo o Gartner, até 2020 todos os softwares corporativos terão alguma funcionalidade ligada a Machine Learning.


Fundamentalmente, Machine Learning é a utilização de algoritmos para extrair informações de dados brutos e representá-los através de algum tipo de modelo matemático. Usamos então este modelo para fazer inferências a partir de outros conjuntos de dados. Existem muitos algoritmos que permitem fazer isso, mas um tipo em especial vem se destacando, as redes neurais artificiais.


As redes neurais artificiais não são necessariamente novas, existem pelo menos desde a década de 1950. Mas durante várias décadas, embora a arquitetura desses modelos tivesse evoluído, ainda faltavam ingredientes que fizessem os modelos realmente funcionar. E esses ingredientes surgiram quase ao mesmo tempo. Um deles você já deve ter ouvido: Big Data. O volume de dados, gerado em variedade e velocidade cada vez maiores, permite criar modelos e atingir altos níveis de precisão. Mas ainda falta um ingrediente. Faltava! Como processar grandes modelos de Machine Learning com grandes quantidades de dados? As CPUs não conseguiam dar conta do recado.


Foi quando os gamers e sua avidez por poder computacional e gráficos perfeitos, nos ajudaram a encontrar o segundo ingrediente: Programação Paralela em GPUs. As unidades de processamento gráfico, que permitem realizar operações matemáticas de forma paralela, principalmente operações com matrizes e vetores, elementos presentes em modelos de redes neurais artificias, formaram a tempestade perfeita, que permitiu a evolução na qual nos encontramos hoje: Big Data + Processamento Paralelo + Modelos de Aprendizagem de Máquina = Inteligência Artificial.


A unidade fundamental de uma rede neural artificial é um nó (ou neurônio matemático), que por sua vez é baseado no neurônio biológico. As conexões entre esses neurônios matemáticos também foram inspiradas em cérebros biológicos, especialmente na forma como essas conexões se desenvolvem ao longo do tempo com “treinamento”. Em meados da década de 1980 e início da década de 1990, muitos avanços importantes na arquitetura das redes neurais artificias ocorreram. No entanto, a quantidade de tempo e dados necessários para obter bons resultados retardou a adoção e, portanto, o interesse foi arrefecido, com o que ficou conhecimento como AI Winter (Inverno da IA).


No início dos anos 2000, o poder computacional expandiu exponencialmente e o mercado viu uma “explosão” de técnicas computacionais que não eram possíveis antes disso. Foi quando o aprendizado profundo (Deep Learning) emergiu do crescimento computacional explosivo dessa década como o principal mecanismo de construção de sistemas de Inteligência Artificial, ganhando muitas competições importantes de aprendizagem de máquina. O interesse por Deep Learning não para de crescer e hoje vemos o termo aprendizado profundo sendo mencionado com frequência cada vez maior e soluções comerciais surgindo a todo momento.


Este livro online, gratuito e em português, é uma iniciativa da [Data Science Academy](https://www.datascienceacademy.com.br) para ajudar aqueles que buscam conhecimento avançado e de qualidade em nosso idioma. Serão mais de 50 capítulos, publicados no formato de posts e lançados semanalmente. Desta forma, esperamos contribuir para o crescimento do Deep Learning e Inteligência Artificial no Brasil.


Nos acompanhe nesta incrível jornada!


Equipe DSA


[www.datascienceacademy.com.br](https://www.datascienceacademy.com.br)


 


<div id="capitulo-2---uma-breve-historia-das-redes-neurais-artificiais"></div>

# Capítulo 2 – Uma Breve História das Redes Neurais Artificiais


Para compreender onde estamos hoje, precisamos olhar para o passado e analisar como chegamos até aqui. Vejamos então Uma Breve História das Redes Neurais Artificiais.


O cérebro humano é uma máquina altamente poderosa e complexa capaz de processar uma grande quantidade de informações em tempo mínimo. As unidades principais do cérebro são os neurônios e é por meio deles que as informações são transmitidas e processadas. As tarefas realizadas pelo cérebro intrigam os pesquisadores, como por exemplo, a capacidade do cérebro de reconhecer um rosto familiar dentre uma multidão em apenas milésimos de segundo. As respostas sobre alguns enigmas do funcionamento do cérebro ainda não foram respondidas e se perpetuam ate os dias de hoje. O que é conhecido sobre o funcionamento do cérebro é que o mesmo desenvolve suas regras através da experiência adquirida em situações vividas anteriormente.


![Cérebro Humano](https://www.deeplearningbook.com.br/wp-content/uploads/2017/12/ce%CC%81rebro-humano-300x240.jpg)


Fig1 – Cérebro humano, a máquina mais fantástica que existe no Planeta Terra.


 


O desenvolvimento do cérebro humano ocorre principalmente nos dois primeiros anos de vida, mas se arrasta por toda a vida. Inspirando-se neste modelo, diversos pesquisadores tentaram simular o funcionamento do cérebro, principalmente o processo de aprendizagem por experiência, a fim de criar sistemas inteligentes capazes de realizar tarefas como classificação, reconhecimento de padrões, processamento de imagens, entre outras atividades. Como resultado destas pesquisas surgiu o modelo do neurônio artificial e posteriormente um sistema com vários neurônios interconectados, a chamada Rede Neural.


Em 1943, o neurofisiologista Warren McCulloch e o matemático Walter Pitts escreveram um artigo sobre como os neurônios poderiam funcionar e para isso, eles modelaram uma rede neural simples usando circuitos elétricos.


Warren McCulloch e Walter Pitts criaram um modelo computacional para redes neurais baseadas em matemática e algoritmos denominados lógica de limiar (threshold logic). Este modelo abriu o caminho para a pesquisa da rede neural dividida em duas abordagens: uma abordagem focada em processos biológicos no cérebro, enquanto a outra focada na aplicação de redes neurais à inteligência artificial.


Em 1949, Donald Hebb escreveu *The Organization of Behavior*, uma obra que apontou o fato de que os caminhos neurais são fortalecidos cada vez que são usados, um conceito fundamentalmente essencial para a maneira como os humanos aprendem. Se dois nervos dispararem ao mesmo tempo, argumentou, a conexão entre eles é melhorada.


À medida que os computadores se tornaram mais avançados na década de 1950, finalmente foi possível simular uma hipotética rede neural. O primeiro passo para isso foi feito por Nathanial Rochester dos laboratórios de pesquisa da IBM. Infelizmente para ele, a primeira tentativa de fazê-lo falhou.


No entanto, ao longo deste tempo, os defensores das “máquinas pensantes” continuaram a argumentar suas pesquisas. Em 1956, o Projeto de Pesquisa de Verão de Dartmouth sobre Inteligência Artificial proporcionou um impulso tanto à Inteligência Artificial como às Redes Neurais. Um dos resultados deste processo foi estimular a pesquisa em IA na parte de processamento neural.


Nos anos seguintes ao Projeto Dartmouth, John von Neumann sugeriu imitar funções simples de neurônios usando relés telegráficos ou tubos de vácuo. Além disso, Frank Rosenblatt, um neurobiologista, começou a trabalhar no Perceptron. Ele estava intrigado com o funcionamento do olho de uma mosca. Grande parte do processamento feito por uma mosca ao decidir fugir, é feito em seus olhos. O Perceptron, que resultou dessa pesquisa, foi construído em hardware e é a mais antiga rede neural ainda em uso hoje. Um Percetron de camada única foi útil para classificar um conjunto de entradas de valor contínuo em uma de duas classes. O Perceptron calcula uma soma ponderada das entradas, subtrai um limite e passa um dos dois valores possíveis como resultado. Infelizmente, o Perceptron é limitado e foi comprovado como tal durante os “anos desiludidos” por Marvin Minsky e o livro de Seymour Papert de 1969, Perceptrons.


 


![Deep Learning Zoo](https://www.deeplearningbook.com.br/wp-content/uploads/2018/01/zoo-602x1024.png)


Fig2 – Algumas Arquiteturas de Redes Neurais. Fonte: [Deep Learning Zoo](https://www.asimovinstitute.org/neural-network-zoo/)


 


Em 1959, Bernard Widrow e Marcian Hoff, de Stanford, desenvolveram modelos denominados “ADALINE” e “MADALINE”. Em uma exibição típica do amor de Stanford por siglas, os nomes provêm do uso de múltiplos elementos ADAptive LINear. ADALINE foi desenvolvido para reconhecer padrões binários de modo que, se ele estivesse lendo bits de transmissão de uma linha telefônica, poderia prever o próximo bit. MADALINE foi a primeira rede neural aplicada a um problema do mundo real, usando um filtro adaptativo que elimina ecos nas linhas telefônicas. Embora o sistema seja tão antigo como os sistemas de controle de tráfego aéreo, ele ainda está em uso comercial.


Infelizmente, esses sucessos anteriores levaram as pessoas a exagerar o potencial das redes neurais, particularmente à luz da limitação na eletrônica, então disponível na época. Este exagero excessivo, que decorreu do mundo acadêmico e técnico, infectou a literatura geral da época. Muitas promessas foram feitas, mas o resultado foi o desapontamento. Além disso, muitos escritores começaram a refletir sobre o efeito que teria “máquinas pensantes” no homem. A série de Asimov em robôs revelou os efeitos sobre a moral e os valores do homem quando máquinas fossem capazes de fazer todo o trabalho da humanidade. Outros escritores criaram computadores mais sinistros, como HAL do filme 2001.


Toda essa discussão sobre o efeito da Inteligência Artificial sobre a vida humana, aliada aos poucos progressos, fizeram vozes respeitadas criticar a pesquisa em redes neurais. O resultado foi a redução drástica de grande parte do financiamento em pesquisas. Esse período de crescimento atrofiado durou até 1981, sendo conhecido como o Inverno da IA (AI Winter).


Em 1982, vários eventos provocaram um renovado interesse. John Hopfield da Caltech apresentou um documento à Academia Nacional de Ciências. A abordagem de Hopfield não era simplesmente modelar cérebros, mas criar dispositivos úteis. Com clareza e análise matemática, ele mostrou como essas redes poderiam funcionar e o que poderiam fazer. No entanto, o maior recurso de Hopfield foi seu carisma. Ele era articulado e simpático e isso colaborou bastante para que ele fosse ouvido.


Em 1985, o Instituto Americano de Física começou o que se tornou uma reunião anual – Redes Neurais para Computação. Em 1987, a primeira Conferência Internacional sobre Redes Neurais do Institute of Electrical and Electronic Engineer’s (IEEE) atraiu mais de 1.800 participantes.


Em 1986, com redes neurais de várias camadas nas notícias, o problema era como estender a regra Widrow-Hoff para várias camadas. Três grupos independentes de pesquisadores, dentre os quais David Rumelhart, ex-membro do departamento de psicologia de Stanford, apresentaram ideias semelhantes que agora são chamadas de redes Backpropagation porque distribuem erros de reconhecimento de padrões em toda a rede. As redes híbridas utilizavam apenas duas camadas, essas redes de Backpropagation utilizam muitas. O resultado é que as redes de Backpropagation “aprendem” de forma mais lenta, pois necessitam, possivelmente, de milhares de iterações para aprender, mas geram um resultado muito preciso.


Agora, as redes neurais são usadas em várias aplicações. A ideia fundamental por trás da natureza das redes neurais é que, se ela funcionar na natureza, deve ser capaz de funcionar em computadores. O futuro das redes neurais, no entanto, reside no desenvolvimento de hardware. As redes neurais rápidas e eficientes dependem do hardware especificado para seu eventual uso.


O diagrama abaixo mostra alguns marcos importantes na evolução e pesquisa das redes neurais artificiais. O fato, é que ainda estamos escrevendo esta história e muita evolução está ocorrendo neste momento, através do trabalho de milhares de pesquisadores e profissionais de Inteligência Artificial em todo mundo. E você, não quer ajudar a escrever esta história?


![Timeline das Redes Neurais](https://www.deeplearningbook.com.br/wp-content/uploads/2017/12/nn_timeline.jpg)


Fig3 – Marcos no desenvolvimento das redes neurais.


 


Podemos resumir assim os principais marcos na pesquisa e evolução das redes neurais artificiais até chegarmos ao Deep Learning:


**1943**: Warren McCulloch e Walter Pitts criam um modelo computacional para redes neurais baseadas em matemática e algoritmos denominados lógica de limiar.


**1958**: Frank Rosenblatt cria o Perceptron, um algoritmo para o reconhecimento de padrões baseado em uma rede neural computacional de duas camadas usando simples adição e subtração. Ele também propôs camadas adicionais com notações matemáticas, mas isso não seria realizado até 1975.


**1980**: Kunihiko Fukushima propõe a Neoconitron, uma rede neural de hierarquia, multicamada, que foi utilizada para o reconhecimento de caligrafia e outros problemas de reconhecimento de padrões.


**1989**: os cientistas conseguiram criar algoritmos que usavam redes neurais profundas, mas os tempos de treinamento para os sistemas foram medidos em dias, tornando-os impraticáveis ​​para o uso no mundo real.


**1992**: Juyang Weng publica o Cresceptron, um método para realizar o reconhecimento de objetos 3-D automaticamente a partir de cenas desordenadas.


**Meados dos anos 2000**: o termo “aprendizagem profunda” começa a ganhar popularidade após um artigo de Geoffrey Hinton e Ruslan Salakhutdinov mostrar como uma rede neural de várias camadas poderia ser pré-treinada uma camada por vez.


**2009**: acontece o NIPS Workshop sobre Aprendizagem Profunda para Reconhecimento de Voz e descobre-se que com um conjunto de dados suficientemente grande, as redes neurais não precisam de pré-treinamento e as taxas de erro caem significativamente.


**2012**: algoritmos de reconhecimento de padrões artificiais alcançam desempenho em nível humano em determinadas tarefas. E o algoritmo de aprendizagem profunda do Google é capaz de identificar gatos.


**2014**: o Google compra a Startup de Inteligência Artificial chamada DeepMind, do Reino Unido, por £ 400m


**2015**: Facebook coloca a tecnologia de aprendizado profundo – chamada DeepFace – em operação para marcar e identificar automaticamente usuários do Facebook em fotografias. Algoritmos executam tarefas superiores de reconhecimento facial usando redes profundas que levam em conta 120 milhões de parâmetros.


**2016**: o algoritmo do Google DeepMind, AlphaGo, mapeia a arte do complexo jogo de tabuleiro Go e vence o campeão mundial de Go, Lee Sedol, em um torneio altamente divulgado em Seul.


**2017**: adoção em massa do Deep Learning em diversas aplicações corporativas e mobile, além do avanço em pesquisas. Todos os eventos de tecnologia ligados a Data Science, IA e Big Data, apontam Deep Learning como a principal tecnologia para criação de sistemas inteligentes.


 


A promessa do aprendizado profundo não é que os computadores comecem a pensar como seres humanos. Isso é como pedir uma maçã para se tornar uma laranja. Em vez disso, demonstra que, dado um conjunto de dados suficientemente grande, processadores rápidos e um algoritmo suficientemente sofisticado, os computadores podem começar a realizar tarefas que até então só podiam ser realizadas apenas por seres humanos, como reconhecer imagens e voz, criar obras de arte ou tomar decisões por si mesmo.


Os estudos sobre as redes neurais sofreram uma grande revolução a partir dos anos 80 e esta área de estudos tem se destacado, seja pelas promissoras características apresentadas pelos modelos de redes neurais propostos, seja pelas condições tecnológicas atuais de implementação que permitem desenvolver arrojadas implementações de arquiteturas neurais paralelas em hardwares dedicado, obtendo assim ótimas performances destes sistemas (bastante superiores aos sistemas convencionais). A evolução natural das redes neurais, são as redes neurais profundas (ou Deep Learning). Mas isso é o que vamos discutir no próximo capítulo! Até lá.


Referências:


Christopher D. Manning. (2015). Computational Linguistics and Deep Learning Computational Linguistics, 41(4), 701–707.


F. Rosenblatt. The perceptron, a perceiving and recognizing automaton Project Para. Cornell Aeronautical Laboratory, 1957.


W. S. McCulloch and W. Pitts. A logical calculus of the ideas immanent in nervous activity. The bulletin of mathematical biophysics, 5(4):115–133, 1943.


The organization of behavior: A neuropsychological theory. D. O. Hebb. John Wiley And Sons, Inc., New York, 1949


B. Widrow et al. Adaptive ”Adaline” neuron using chemical ”memistors”. Number Technical Report 1553-2. Stanford Electron. Labs., Stanford, CA, October 1960.


“New Navy Device Learns By Doing”, New York Times, July 8, 1958.


Perceptrons. An Introduction to Computational Geometry. MARVIN MINSKY and SEYMOUR PAPERT. M.I.T. Press, Cambridge, Mass., 1969.


Minsky, M. (1952). A neural-analogue calculator based upon a probability model of reinforcement. Harvard University Pychological Laboratories internal report.


 


<div id="capitulo-3---o-que-sao-redes-neurais-artificiais-profundas-ou-deep-learning?"></div>

# Capítulo 3 – O Que São Redes Neurais Artificiais Profundas ou Deep Learning?


Aprendizagem Profunda ou Deep Learning, é uma sub-área da Aprendizagem de Máquina, que emprega algoritmos para processar dados e imitar o processamento feito pelo cérebro humano. Mas O Que São Redes Neurais Artificiais Profundas ou Deep Learning? É o que veremos neste capítulo. Não se preocupe se alguns termos mais técnicos não fizerem sentido agora. Todos eles serão estudados ao longo deste livro online.


Deep Learning  usa camadas de neurônios matemáticos para processar dados, compreender a fala humana e reconhecer objetos visualmente. A informação é passada através de cada camada, com a saída da camada anterior fornecendo entrada para a próxima camada. A primeira camada em uma rede é chamada de camada de entrada, enquanto a última é chamada de camada de saída. Todas as camadas entre as duas são referidas como camadas ocultas. Cada camada é tipicamente um algoritmo simples e uniforme contendo um tipo de função de ativação.


 


![Neural Network](https://www.deeplearningbook.com.br/wp-content/uploads/2017/12/neural.png)


Fig4 – Rede Neural Simples e Rede Neural Profunda (Deep Learning)


 


A aprendizagem profunda é responsável por avanços recentes em visão computacional, reconhecimento de fala, processamento de linguagem natural e reconhecimento de áudio. O aprendizado profundo é baseado no conceito de redes neurais artificiais, ou sistemas computacionais que imitam a maneira como o cérebro humano funciona.


A extração de recursos é outro aspecto da Aprendizagem Profunda. A extração de recursos usa um algoritmo para construir automaticamente “recursos” significativos dos dados para fins de treinamento, aprendizado e compreensão. Normalmente, o Cientista de Dados, ou Engenheiro de IA, é responsável pela extração de recursos.


O aumento rápido e o aparente domínio do aprendizado profundo sobre os métodos tradicionais de aprendizagem de máquina em uma variedade de tarefas tem sido surpreendente de testemunhar e, às vezes, difícil de explicar. Deep Learning é uma evolução das Redes Neurais, que por sua vez possuem uma história fascinante que remonta à década de 1940, cheia de altos e baixos, voltas e reviravoltas, amigos e rivais, sucessos e fracassos. Em uma história digna de um filme dos anos 90, uma ideia que já foi uma espécie de patinho feio floresceu para se tornar a bola da vez.


Consequentemente, o interesse em aprendizagem profunda tem disparado, com cobertura constante na mídia popular. A pesquisa de aprendizagem profunda agora aparece rotineiramente em revistas como Science, Nature, Nature Methods e Forbes apenas para citar alguns. O aprendizado profundo conquistou Go, aprendeu a dirigir um carro, diagnosticou câncer de pele e autismo, tornou-se um falsificador de arte mestre e pode até alucinar imagens fotorrealistas.


Os primeiros algoritmos de aprendizagem profunda que possuíam múltiplas camadas de características não-lineares podem ser rastreados até Alexey Grigoryevich Ivakhnenko (desenvolveu o Método do Grupo de Manipulação de Dados) e Valentin Grigor’evich Lapa (autor de Cybernetics and Forecasting Techniques) em 1965 (Figura 5), que usaram modelos finos mas profundos com funções de ativação polinomial os quais eles analisaram com métodos estatísticos. Em cada camada, eles selecionavam os melhores recursos através de métodos estatísticos e encaminhavam para a próxima camada. Eles não usaram Backpropagation para treinar a rede de ponta a ponta, mas utilizaram mínimos quadrados camada-por-camada, onde as camadas anteriores foram independentemente instaladas em camadas posteriores (um processo lento e manual).


![GMDH-network](https://www.deeplearningbook.com.br/wp-content/uploads/2017/12/GMDH-network.png)


Fig5 – Arquitetura da primeira rede profunda conhecida treinada por Alexey Grigorevich Ivakhnenko em 1965.


 


No final da década de 1970, o primeiro inverno de AI começou, resultado de promessas que não poderiam ser mantidas. O impacto desta falta de financiamento limitou a pesquisa em Redes Neurais Profundas e Inteligência Artificial. Felizmente, houve indivíduos que realizaram a pesquisa sem financiamento.


As primeiras “redes neurais convolutivas” foram usadas por Kunihiko Fukushima. Fukushima concebeu redes neurais com múltiplas camadas de agrupamento e convoluções. Em 1979, ele desenvolveu uma rede neural artificial, chamada Neocognitron, que usava um design hierárquico e multicamadas. Este design permitiu ao computador “aprender” a reconhecer padrões visuais. As redes se assemelhavam a versões modernas, mas foram treinadas com uma estratégia de reforço de ativação recorrente em múltiplas camadas, que ganhou força ao longo do tempo. Além disso, o design de Fukushima permitiu que os recursos importantes fossem ajustados manualmente aumentando o “peso” de certas conexões.


Muitos dos conceitos de Neocognitron continuam a ser utilizados. O uso de conexões de cima para baixo e novos métodos de aprendizagem permitiram a realização de uma variedade de redes neurais. Quando mais de um padrão é apresentado ao mesmo tempo, o Modelo de Atenção Seletiva pode separar e reconhecer padrões individuais deslocando sua atenção de um para o outro (o mesmo processo que usamos em multitarefa). Um Neocognitron moderno não só pode identificar padrões com informações faltantes (por exemplo, um número 5 desenhado de maneira incompleta), mas também pode completar a imagem adicionando as informações que faltam. Isso pode ser descrito como “inferência”.


O Backpropagation, o uso de erros no treinamento de modelos de Deep Learning, evoluiu significativamente em 1970. Foi quando Seppo Linnainmaa escreveu sua tese de mestrado, incluindo um código FORTRAN para Backpropagation. Infelizmente, o conceito não foi aplicado às redes neurais até 1985. Foi quando Rumelhart, Williams e Hinton demonstraram o Backpropagation em uma rede neural que poderia fornecer representações de distribuição “interessantes”. Filosoficamente, essa descoberta trouxe à luz a questão dentro da psicologia cognitiva de saber se a compreensão humana depende da lógica simbólica (computacionalismo) ou de representações distribuídas (conexão). Em 1989, Yann LeCun forneceu a primeira demonstração prática de Backpropagation no Bell Labs. Ele combinou redes neurais convolutivas com Backpropagation para ler os dígitos “manuscritos” (assunto do próximo capítulo). Este sistema foi usado para ler o número de cheques manuscritos.


![Deep Learning](https://www.deeplearningbook.com.br/wp-content/uploads/2018/01/deeplearningpioneersatnipsconference2014inmontreal.jpg)


Fig6 – Os pioneiros da Inteligência Artificial. Da esquerda para a direita: Yann LeCun, Geoffrey Hinton, Yoshua Bengio e Andrew Ng


Porém, tivemos neste período o que ficou conhecido como segundo Inverno da IA, que ocorreu entre 1985-1990, que também afetou pesquisas em Redes Neurais e Aprendizagem Profunda. Vários indivíduos excessivamente otimistas haviam exagerado o potencial “imediato” da Inteligência Artificial, quebrando as expectativas e irritando os investidores. A raiva era tão intensa, que a frase Inteligência Artificial atingiu o status de pseudociência. Felizmente, algumas pessoas continuaram trabalhando em IA e Deep Learning, e alguns avanços significativos foram feitos. Em 1995, Dana Cortes e Vladimir Vapnik desenvolveram a máquina de vetor de suporte ou Support Vector Machine (um sistema para mapear e reconhecer dados semelhantes). O LSTM (Long-Short Term Memory) para redes neurais recorrentes foi desenvolvido em 1997, por Sepp Hochreiter e Juergen Schmidhuber.


O próximo passo evolutivo significativo para Deep Learning ocorreu em 1999, quando os computadores começaram a se tornar mais rápidos no processamento de dados e GPUs (unidades de processamento de gráfico) foram desenvolvidas. O uso de GPUs significou um salto no tempo de processamento, resultando em um aumento das velocidades computacionais em 1000 vezes ao longo de um período de 10 anos. Durante esse período, as redes neurais começaram a competir com máquinas de vetor de suporte. Enquanto uma rede neural poderia ser lenta em comparação com uma máquina de vetor de suporte, as redes neurais ofereciam melhores resultados usando os mesmos dados. As redes neurais também têm a vantagem de continuar a melhorar à medida que mais dados de treinamento são adicionados.


Em torno do ano 2000, apareceu o problema conhecido como Vanishing Gradient. Foi descoberto que as “características” aprendidas em camadas mais baixas não eram aprendidas pelas camadas superiores, pois nenhum sinal de aprendizado alcançou essas camadas. Este não era um problema fundamental para todas as redes neurais, apenas aquelas com métodos de aprendizagem baseados em gradientes. A origem do problema acabou por ser certas funções de ativação. Uma série de funções de ativação condensavam sua entrada, reduzindo, por sua vez, a faixa de saída de forma um tanto caótica. Isso produziu grandes áreas de entrada mapeadas em uma faixa extremamente pequena. Nessas áreas de entrada, uma grande mudança será reduzida a uma pequena mudança na saída, resultando em um gradiente em queda. Duas soluções utilizadas para resolver este problema foram o pré-treino camada-a-camada e o desenvolvimento de uma memória longa e de curto prazo.


Em 2001, um relatório de pesquisa do Grupo META (agora chamado Gartner) descreveu os desafios e oportunidades no crescimento do volume de dados. O relatório descreveu o aumento do volume de dados e a crescente velocidade de dados como o aumento da gama de fontes e tipos de dados. Este foi um apelo para se preparar para a investida do Big Data, que estava apenas começando.


Em 2009, Fei-Fei Li, professora de IA em Stanford na Califórnia, lançou o ImageNet e montou uma base de dados gratuita de mais de 14 milhões de imagens etiquetadas. Eram necessárias imagens marcadas para “treinar” as redes neurais. A professora Li disse: “Nossa visão é que o Big Data mudará a maneira como a aprendizagem de máquina funciona. Data drives learning.”. Ela acertou em cheio!


Até 2011, a velocidade das GPUs aumentou significativamente, possibilitando a formação de redes neurais convolutivas “sem” o pré-treino camada por camada. Com o aumento da velocidade de computação, tornou-se óbvio que Deep Learning tinha vantagens significativas em termos de eficiência e velocidade. Um exemplo é a AlexNet, uma rede neural convolutiva, cuja arquitetura ganhou várias competições internacionais durante 2011 e 2012. As unidades lineares retificadas foram usadas para melhorar a velocidade.


Também em 2012, o Google Brain lançou os resultados de um projeto incomum conhecido como The Cat Experiment. O projeto de espírito livre explorou as dificuldades de “aprendizagem sem supervisão”. A Aprendizagem profunda usa “aprendizagem supervisionada”, o que significa que a rede neural convolutiva é treinada usando dados rotulados. Usando a aprendizagem sem supervisão, uma rede neural convolucional é alimentada com dados não marcados, e é então solicitada a busca de padrões recorrentes.


O Cat Experiment usou uma rede neural distribuída por mais de 1.000 computadores. Dez milhões de imagens “sem etiqueta” foram tiradas aleatoriamente do YouTube, mostradas ao sistema e, em seguida, o software de treinamento foi autorizado a ser executado. No final do treinamento, um neurônio na camada mais alta foi encontrado para responder fortemente às imagens de gatos. Andrew Ng, o fundador do projeto, disse: “Nós também encontramos um neurônio que respondeu fortemente aos rostos humanos”. A aprendizagem não supervisionada continua a ser um um campo ativo de pesquisa em Aprendizagem Profunda.


Atualmente, o processamento de Big Data e a evolução da Inteligência Artificial são ambos dependentes da Aprendizagem Profunda. Com Deep Learning podemos construir sistemas inteligentes e estamos nos aproximando da criação de uma IA totalmente autônoma. Isso vai gerar impacto em todas os segmentos da sociedade e aqueles que souberem trabalhar com a tecnologia, serão os líderes desse novo mundo que se apresenta diante de nós.


No próximo capítulo você vai começar a compreender tecnicamente como funciona a Aprendizagem Profunda. Até o capítulo 4.


Referências:


Deep Learning in a Nutshell: History and Training from NVIDIA


Linnainmaa, S. (1970). The representation of the cumulative rounding error of an algorithm as a Taylor expansion of the local rounding errors. Master’s thesis, Univ. Helsinki.


P. Werbos. Beyond Regression: New Tools for Prediction and Analysis in the Behavioral Sciences. PhD thesis, Harvard University, Cambridge, MA, 1974.


Werbos, P.J. (2006). Backwards differentiation in AD and neural nets: Past links and new opportunities. In Automatic Differentiation: Applications, Theory, and Implementations, pages 15-34. Springer.


Rumelhart, D. E., Hinton, G. E., and Williams, R. J. (1986). Learning representations by back-propagating errors. Nature, 323, 533–536.


Widrow, B., & Lehr, M. (1990). 30 years of adaptive neural networks: perceptron, madaline, and backpropagation. Proceedings of the IEEE, 78(9), 1415-1442.


D. E. Rumelhart, G. E. Hinton, and R. J. Williams. 1986. Learning internal representations by error propagation. In Parallel distributed processing: explorations in the microstructure of cognition, vol. 1, David E. Rumelhart, James L. McClelland, and CORPORATE PDP Research Group (Eds.). MIT Press, Cambridge, MA, USA 318-362


<div id="capitulo-4---o-neuronio,-biologico-e-matematico"></div>

# Capítulo 4 – O Neurônio, Biológico e Matemático


Para compreender a lógica de funcionamento das redes neurais, alguns conceitos básicos referentes ao funcionamento do cérebro humano e seus componentes, os neurônios, são de fundamental importância. A formação das conexões entre as células e algumas considerações sobre como se concebe teoricamente o funcionamento matemático, ajudam a entender as bases da aprendizagem de máquina e das redes neurais. Vejamos como funciona o neurônio biológico deixando Machine Learning de lado por um instante!


### O Neurônio Biológico


O neurônio é a unidade básica do cérebro humano, sendo uma célula especializada na transmissão de informações, pois nelas estão introduzidas propriedades de excitabilidade e condução de mensagens nervosas. O neurônio é constituído por 3 partes principais: a soma ou corpo celular, do qual emanam algumas ramificações denominadas de dendritos, e por uma outra ramificação descendente da soma, porém mais extensa, chamada de axônio. Nas extremidades dos axônios estão os nervos terminais, pelos quais é realizada a transmissão das informações para outros neurônios. Esta transmissão é conhecida como sinapse.


 


![Neurônio Biológico](https://www.deeplearningbook.com.br/wp-content/uploads/2018/01/neuronio.jpg)


Fig7 – Representação Simplificada do Neurônio Biológico


Nosso cérebro é formado por bilhões de neurônios. Mas eles não estão isolados. Pelo contrário, existem centenas de bilhões de conexões entre eles, formando uma enorme rede de comunicação, a rede neural. Cada neurônio possui um corpo central, diversos dendritos e um axônio. Os dendritos recebem sinais elétricos de outros neurônios através das sinapses, que constitui o processo de comunicação entre neurônios. O corpo celular processa a informação e envia para outro neurônio.


Observe que a soma e os dendritos formam a superfície de entrada do neurônio e o axônio a superfície de saída do fluxo de informação (esse fluxo de informação é importante para compreender o neurônio matemático daqui a pouco). A informação transmitida pelos neurônios na realidade são impulsos elétricos. O impulso elétrico é a mensagem que os neurônios transmitem uns aos outros, ou seja, é a propagação de um estímulo ao longo dos neurônios que pode ser qualquer sinal captado pelos receptores nervosos.


Os dendritos têm como função, receber informações, ou impulsos nervosos, oriundos de outros neurônios e conduzi-los até o corpo celular. Ali, a informação é processada e novos impulsos são gerados. Estes impulsos são transmitidos a outros neurônios, passando pelo axônio e atingindo os dendritos dos neurônios seguintes. O corpo do neurônio é responsável por coletar e combinar informações vindas de outros neurônios.


O ponto de contato entre a terminação axônica de um neurônio e o dendrito de outro é chamado sinapse. É pelas sinapses que os neurônios se unem funcionalmente, formando as redes neurais. As sinapses funcionam como válvulas, sendo capazes de controlar a transmissão de impulsos, isto é, o fluxo da informação entre os neurônios na rede neural. O efeito das sinapses é variável e é esta variação que dá ao neurônio capacidade de adaptação.


Sinais elétricos gerados nos sensores (retina ocular, papilas gustativas, etc…) caminham pelos axônios. Se esses sinais forem superiores a um limiar de disparo (threshold), seguem pelo axônio. Caso contrário, são bloqueados e não prosseguem (são considerados irrelevantes). A passagem desses sinais não é elétrica, mas química (através da substância serotonina). Se o sinal for superior a certo limite (threshold), vai em frente; caso contrário é bloqueado e não segue. Estamos falando aqui do neurônio biológico e preste bastante atenção a palavra threshold, pois ela é a essência do neurônio matemático.


Um neurônio recebe sinais através de inúmeros dendritos, os quais são ponderados e enviados para o axônio, podendo ou não seguir adiante (threshold). Na passagem por um neurônio, um sinal pode ser amplificado ou atenuado, dependendo do dendrito de origem, pois a cada condutor, está associado um peso pelo qual o sinal é multiplicado. Os pesos são o que chamamos de memória.


Cada região do cérebro é especializada em uma dada função, como processamento de sinais auditivos, sonoros, elaboração de pensamentos, desejos, etc… Esse processamento se dá através de redes particulares interligadas entre si, realizando processamento paralelo. Cada região do cérebro possui uma arquitetura de rede diferente: varia o número de neurônios, de sinapses por neurônio, valor dos thresholds e dos pesos, etc…Os valores dos pesos são estabelecidos por meio de treinamento recebido pelo cérebro durante a vida útil. É a memorização.


Inspirados no neurônio biológico, os pesquisadores desenvolveram um modelo de neurônio matemático que se tornou a base da Inteligência Artificial. A ideia era simples: “Se redes neurais formam a inteligência humana, vamos reproduzir isso e criar Inteligência Artificial”. E assim nasceu o neurônio matemático, o qual descrevemos abaixo.


### O Neurônio Matemático


A partir da estrutura e funcionamento do neurônio biológico, pesquisadores tentaram simular este sistema em computador. O modelo mais bem aceito foi proposto por Warren McCulloch e Walter Pitts em 1943, o qual implementa de maneira simplificada os componentes e o funcionamento de um neurônio biológico. Em termos simples, um neurônio matemático de uma rede neural artificial é um componente que calcula a soma ponderada de vários inputs, aplica uma função e passa o resultado adiante.


Neste modelo de neurônio matemático, os impulsos elétricos provenientes de outros neurônios são representados pelos chamados sinais de entrada (a letra x nesse diagrama abaixo, que nada mais são do que os dados que alimentam seu modelo de rede neural artificial). Dentre os vários estímulos recebidos, alguns excitarão mais e outros menos o neurônio receptor e essa medida de quão excitatório é o estímulo é representada no modelo de Warren McCulloch e Walter Pitts através dos pesos sinápticos. Quanto maior o valor do peso, mais excitatório é o estímulo. Os pesos sinápticos são representados por wkn neste diagrama abaixo, onde k representa o índice do neurônio em questão e n se refere ao terminal de entrada da sinapse a qual o peso sináptico se refere.


A soma ou corpo da célula é representada por uma composição de dois módulos, o primeiro é uma junção aditiva, somatório dos estímulos (sinais de entrada) multiplicado pelo seu fator excitatório (pesos sinápticos), e posteriormente uma função de ativação, que definirá com base nas entradas e pesos sinápticos, qual será a saída do neurônio. O axônio é aqui representado pela saída (yk) obtida pela aplicação da função de ativação. Assim como no modelo biológico, o estímulo pode ser excitatório ou inibitório, representado pelo peso sináptico positivo ou negativo respectivamente.


![Neurônio Matemático](https://www.deeplearningbook.com.br/wp-content/uploads/2018/01/neuronio-matematico.png)


Fig8 – Representação Simplificada do Neurônio Matemático


O modelo proposto possui uma natureza binária. Tanto os sinais de entrada quanto a saída, são valores binários. McCulloch acreditava que o funcionamento do sistema nervoso central possuía um carater binário, ou seja, um neurônio infuencia ou não outro neurônio, mas posteriormente mostrou-se que não era dessa forma.


O neurônio matemático é um modelo simplificado do neurônio biológico. Tais modelos inspirados a partir da análise da geração e propagação de impulsos elétricos pela membrana celular dos neurônios. O neurônio matemático recebe um ou mais sinais de entrada e devolve um único sinal de saída, que pode ser distribuído como sinal de saída da rede, ou como sinal de entrada para um ou vários outros neurônios da camada posterior (que formam a rede neural artificial). Os dendritos e axônios são representados matematicamente apenas pelas sinapses, e a intensidade da ligação é representada por uma grandeza denominada peso sináptico, simbolizada pela letra w. Quando as entradas, x são apresentadas ao neurônio, elas são multiplicadas pelos pesos sinápticos correspondentes, gerando as entradas ponderadas, ou seja, x1 que multiplica w1, etc… Isso descreve uma das bases matemáticas do funcionamento de uma rede neural artificial, a multiplicação de matrizes:


![Matriz](https://www.deeplearningbook.com.br/wp-content/uploads/2018/01/matriz-300x147.png)


Fig9 – Multiplicação de Matrizes Entre Sinais de Entrada x e Pesos Sinápticos w (versão simplificada)


O neurônio então totaliza todos os produtos gerando um único resultado. A esta função se denomina função de combinação. Este valor é então apresentado a uma função de ativação ou função de transferência, que tem, dentre outras, a finalidade de evitar o acréscimo progressivo dos valores de saída ao longo das camadas da rede, visto que tais funções possuem valores máximos e mínimos contidos em intervalos determinados. O uso de funções de transferência não-lineares torna a rede neural uma ferramenta poderosa. Sabe-se que uma rede perceptron de duas camadas com função de transferência não-linear como a função sigmóide (que veremos mais adiante), é denominada de aproximador universal.


Um neurônio dispara quando a soma dos impulsos que ele recebe ultrapassa o seu limiar de excitação chamado de threshold. O corpo do neurônio, por sua vez, é emulado por um mecanismo simples que faz a soma dos valores xi e wi recebidos pelo neurônio (soma ponderada) e decide se o neurônio deve ou não disparar (saída igual a 1 ou a 0) comparando a soma obtida ao limiar ou threshold do neurônio. A ativação do neurônio é obtida através da aplicação de uma “função de ativação”, que ativa a saída ou não, dependendo do valor da soma ponderada das suas entradas.


Note que este modelo matemático simplificado de um neurônio é estático, ou seja, não considera a dinâmica do neurônio natural. No neurônio biológico, os sinais são enviados em pulsos e alguns componentes dos neurônios biológicos, a exemplo do axônio, funcionam como filtros de frequência.


O modelo do neurônio matemático também pode incluir uma polarização ou bias de entrada. Esta variável é incluída ao somatório da função de ativação, com o intuito de aumentar o grau de liberdade desta função e, consequentemente, a capacidade de aproximação da rede. O valor do bias é ajustado da mesma forma que os pesos sinápticos. O bias possibilita que um neurônio apresente saída não nula ainda que todas as suas entradas sejam nulas. Por exemplo, caso não houvesse o bias e todas as entradas de um neurônio fossem nulas, então o valor da função de ativação seria nulo. Desta forma não poderíamos, por exemplo, fazer com o que o neurônio aprendesse a relação pertinente ao ”ou exclusivo” da lógica. Em resumo, temos esses componentes em um neurônio matemático:


![Resumo do Neurônio](https://www.deeplearningbook.com.br/wp-content/uploads/2018/01/neuronio-300x137.jpeg)


Fig10 – Representação do Neurônio Matemático


* Sinais de entrada { X1, X2, …, Xn }: São os sinais externos normalmente normalizados para incrementar a eficiência computacional dos algoritmos de aprendizagem. São os dados que alimentam seu modelo preditivo.
* Pesos sinápticos { W1, W2, …, Wn }: São valores para ponderar os sinais de cada entrada da rede. Esses valores são aprendidos durante o treinamento.
* Combinador linear { Σ }: Agregar todos sinais de entrada que foram ponderados pelos respectivos pesos sinápticos a fim de produzir um potencial de ativação.
* Limiar de ativação { Θ }: Especifica qual será o patamar apropriado para que o resultado produzido pelo combinador linear possa gerar um valor de disparo de ativação.
* Potencial de ativação { u }: É o resultado obtido pela diferença do valor produzido entre o combinador linear e o limiar de ativação. Se o valor for positivo, ou seja, se u ≥ 0 então o neurônio produz um potencial excitatório; caso contrário, o potencial será inibitório.
* Função de ativação { g }: Seu objetivo é limitar a saída de um neurônio em um intervalo valores.
* Sinal de saída { y}: É o valor final de saída podendo ser usado como entrada de outros neurônios que estão sequencialmente interligados.


Os modelos baseados em redes neurais artificiais são os que mais ganharam atenção nos últimos anos por conseguirem resolver problemas de IA nos quais se conseguia pouco avanço com outras técnicas. A partir da concepção do neurônio matemático, várias arquiteturas e modelos com diferentes combinações entre esses neurônios, e aplicando diferentes técnicas matemáticas e estatísticas, surgiram e propiciaram a criação de arquiteturas avançadas de Deep Learning como Redes Neurais Convolucionais, Redes Neurais Recorrentes, Auto Encoders, Generative Adversarial Networks, Memory Networks, entre outras, que estudaremos ao longo deste livro online.


Referências:


[Anatomia de um Neurônio](https://pt.khanacademy.org/science/biology/human-biology/neuron-nervous-system/v/anatomy-of-a-neuron)


[Bibliografia Machine Learning e IA](https://blog.dsacademy.com.br/categoria/bibliografia/)


[Deep Learning in Neural Networks: An Overview](https://arxiv.org/abs/1404.7828)


[Grokking Deep Learning](https://www.manning.com/books/grokking-deep-learning)


HAYKIN, S. Redes Neurais, princípios e práticas. Porto Alegre: Bookman, 2001.


JAIN, A. K, MAO, J., MOHIUDDIN, K.M. Artificial neural networks: a tutorial. IEEE Computer, v. 29, n. 3, p. 56-63, 1996.


 


<div id="capitulo-5---usando-redes-neurais-para-reconhecer-digitos-manuscritos"></div>

# Capítulo 5 – Usando Redes Neurais Para Reconhecer Dígitos Manuscritos


O sistema visual humano é uma das maravilhas do mundo. Considere a seguinte sequência de dígitos manuscritos:


 


![Dígitos](https://www.deeplearningbook.com.br/wp-content/uploads/2017/12/digits-300x62.png)


 


A maioria das pessoas reconhece sem esforço esses dígitos como 504192. Essa facilidade é enganosa. Em cada hemisfério do nosso cérebro, os seres humanos têm um córtex visual primário, também conhecido como V1, contendo 140 milhões de neurônios, com dezenas de bilhões de conexões entre eles. E, no entanto, a visão humana envolve não apenas V1, mas uma série inteira de cortices visuais – V2, V3, V4 e V5 – fazendo processamento de imagem progressivamente mais complexo. Nós carregamos em nossas cabeças um supercomputador, sintonizado pela evolução ao longo de centenas de milhões de anos, e soberbamente adaptado para entender o mundo visual. Reconhecer os dígitos manuscritos não é fácil. Em vez disso, nós humanos somos estupendos, surpreendentemente bons, em entender o que nossos olhos nos mostram. Mas quase todo esse trabalho é feito inconscientemente. E, portanto, geralmente não apreciamos o quão difícil é o problema dos nossos sistemas visuais.


A dificuldade de reconhecimento do padrão visual torna-se evidente se você tentar escrever um programa de computador para reconhecer dígitos como os acima. O que parece fácil quando nós seres humanos fazemos, de repente, se torna extremamente difícil. Intuições simples sobre como reconhecemos formas – “um 9 tem um loop no topo e um curso vertical no canto inferior direito” – não é tão simples de se expressar algoritmicamente. Quando você tenta construir essas regras de forma precisa, você se perde rapidamente em diversas exceções, ressalvas e casos especiais. É meio desesperador.


As redes neurais abordam o problema de uma maneira diferente. A ideia é tomar uma grande quantidade de dígitos manuscritos, conhecidos como exemplos de treinamento, e em seguida, desenvolver um sistema que possa aprender com esses exemplos de treinamento. Em outras palavras, a rede neural usa os exemplos para inferir automaticamente regras para o reconhecimento de dígitos manuscritos. Além disso, ao aumentar o número de exemplos de treinamento, a rede pode aprender mais sobre a caligrafia, e assim melhorar sua precisão. Podemos construir um reconhecedor de dígitos manuscritos melhor usando milhares, milhões ou bilhões de exemplos de treinamento.


 


![MNIST](https://www.deeplearningbook.com.br/wp-content/uploads/2017/12/mnist_100_digits.png)


 


Ao longo dos próximos capítulos começaremos nossa jornada rumo às arquiteturas mais avançadas de Deep Learning, desenvolvendo um programa de computador implementando uma rede neural que aprende a reconhecer os dígitos manuscritos. O programa não usará bibliotecas de redes neurais especiais (usaremos apenas linguagem Python). Mas este programa pode reconhecer dígitos com uma precisão de mais de 96%, sem intervenção humana. Além disso, em capítulos posteriores, desenvolveremos ideias que podem melhorar a precisão para mais de 99%. Na verdade, as melhores redes neurais comerciais são agora tão boas que são usadas pelos bancos para processar cheques e por agências de correio para reconhecer endereços.


Estamos nos concentrando no reconhecimento de manuscrito porque é um excelente problema protótipo para aprender sobre redes neurais em geral. Como um protótipo, ele atinge um ponto interessante: é desafiador – não é tão simples reconhecer os dígitos manuscritos – mas também não é tão difícil e nem requer uma solução extremamente complicada, ou um tremendo poder computacional. Além disso, é uma ótima maneira de desenvolver técnicas mais avançadas, como a aprendizagem profunda. E assim, ao longo do livro, retornaremos repetidamente ao problema do reconhecimento de dígitos manuscritos. Mais tarde, no livro, vamos discutir como essas ideias podem ser aplicadas a outros problemas em visão computacional, e também em reconhecimento da fala, processamento de linguagem natural e outras áreas.


Ao longo do caminho, desenvolveremos muitas ideias-chave sobre as redes neurais, incluindo dois tipos importantes de neurônios artificiais (o perceptron e o neurônio sigmóide) e o algoritmo de aprendizagem padrão para redes neurais, conhecido como descida estocástica do gradiente. Explicaremos porque as coisas são feitas da maneira que elas são e na construção de sua intuição de redes neurais. Isso requer uma discussão mais longa do que apenas apresentar a mecânica básica do que está acontecendo, mas vale a pena para o entendimento mais profundo que você alcançará. E ao final deste livro, você terá uma boa compreensão do que é aprendizado profundo e como isso está transformando o mundo!


Caso você não tenha conhecimento em linguagem Python, recomendamos o curso gratuito [Python Fundamentos Para Análise de Dados](https://www.datascienceacademy.com.br/cursosgratuitos). Ele vai fornecer uma ótima base de tudo que você precisa para começar a desenvolver suas redes neurais.


Referências:


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/) (alguns trechos extraídos e traduzidos com autorização do autor [Michael Nielsen](http://michaelnielsen.org/))


 


<div id="capitulo-6---o-perceptron---parte-1"></div>

# Capítulo 6 – O Perceptron – Parte 1


Você sabe quais são as principais arquiteturas de redes neurais artificias? Não. Então analise cuidadosamente a imagem abaixo (excelente trabalho criado pela equipe do Asimov Institute, cujo link você encontra na seção de referências ao final deste capítulo):


 


![Deep Learning Zoo](https://www.deeplearningbook.com.br/wp-content/uploads/2018/01/zoo-602x1024.png)


Incrível, não? São diversas arquiteturas, usadas para resolver diferentes tipos de problemas, como por exemplo as arquiteturas de redes neurais convolucionais usadas em problemas de Visão Computacional e as redes neurais recorrentes usadas em problemas de Processamento de Linguagem Natural. Estudaremos quase todas essas arquiteturas aqui neste livro. Sim, isso mesmo que você leu. Estamos apenas começando!! Caso queira aprender a construir modelos e projetos usando essas arquiteturas e trabalhando com linguagem Python e Google TensorFlow, clique [aqui](https://www.deeplearningbook.com.br/cursos-online/).


Embora todas essas arquiteturas sejam de redes neurais artificias, nem todas são de Deep Learning. O que caracteriza modelos de aprendizagem profunda, como o nome sugere, são redes neurais artificias com muitas camadas ocultas (ou intermediárias). Mas antes de chegarmos lá, precisamos passar pela arquitetura mais simples de uma rede neural artificial, o Perceptron. Como diz o ditado: “Toda grande caminhada começa pelo primeiro passo”.


O Modelo Perceptron foi desenvolvido nas décadas de 1950 e 1960 pelo cientista Frank Rosenblatt, inspirado em trabalhos anteriores de Warren McCulloch e Walter Pitts. Hoje, é mais comum usar outros modelos de neurônios artificiais, mas o Perceptron permite uma compreensão clara de como funciona uma rede neural em termos matemáticos, sendo uma excelente introdução.


Então, como funcionam os Perceptrons? Um Perceptron é um modelo matemático que recebe várias entradas, x1, x2, … e produz uma única saída binária:


 


![Perceptron](https://www.deeplearningbook.com.br/wp-content/uploads/2017/12/perceptron.png)


 


No exemplo mostrado, o Perceptron possui três entradas: x1, x2, x3. Rosenblatt propôs uma regra simples para calcular a saída. Ele introduziu pesos, w1, w2, …, números reais expressando a importância das respectivas entradas para a saída. A saída do neurônio, 0 ou 1, é determinada pela soma ponderada, **Σjwjxj**, menor ou maior do que algum valor limiar (threshold). Assim como os pesos, o threshold é um número real que é um parâmetro do neurônio. Para colocá-lo em termos algébricos mais precisos:


 


![Output](https://www.deeplearningbook.com.br/wp-content/uploads/2017/12/output.png)


 


Esse é o modelo matemático básico. Uma maneira de pensar sobre o Perceptron é que é um dispositivo que toma decisões ao comprovar evidências. Deixe-me dar um exemplo. Não é um exemplo muito realista, mas é fácil de entender, e logo chegaremos a exemplos mais realistas. Suponha que o fim de semana esteja chegando e você ouviu falar que haverá um festival de queijo em sua cidade. Você gosta de queijo e está tentando decidir se deve ou não ir ao festival. Você pode tomar sua decisão pesando três fatores:


* O tempo está bom?
* Seu namorado ou namorada quer acompanhá-lo(a)?
* O festival está perto de transporte público? (Você não possui um carro)


Podemos representar estes três fatores pelas variáveis binárias correspondentes x1, x2 e x3. Por exemplo, teríamos x1 = 1 se o tempo estiver bom e x1 = 0 se o tempo estiver ruim. Da mesma forma, x2 = 1 se seu namorado ou namorada quiser ir ao festival com você, e x2 = 0, se não. E similarmente para x3 e transporte público.


Agora, suponha que você adore queijo e está disposto a ir ao festival, mesmo que seu namorado ou namorada não esteja interessado e o festival fica em um lugar de difícil acesso e sem transporte público amplamente disponível. Além disso, você realmente detesta mau tempo, e não há como ir ao festival se o tempo estiver ruim. Você pode usar Perceptrons para modelar esse tipo de tomada de decisão.


Uma maneira de fazer isso é escolher um peso w1 = 6 para o tempo e w2 = 2 e w3 = 2 para as outras condições. O valor maior de w1 indica que o tempo é muito importante para você, muito mais do que se seu namorado ou namorada vai acompanhá-lo(a) ou se o festival é próximo do transporte público. Finalmente, suponha que você escolha um threshold de 5 para o Perceptron. Com essas escolhas, o Perceptron implementa o modelo de tomada de decisão desejado, produzindo 1 sempre que o tempo estiver bom e 0 sempre que o tempo estiver ruim. Não faz diferença para o resultado se seu namorado ou namorada quer ir, ou se o transporte público está acessível.


Variando os pesos e o limiar, podemos obter diferentes modelos de tomada de decisão. Por exemplo, suponha que escolhemos um threshold de 3. Então, o Perceptron decidirá que você deveria ir ao festival sempre que o tempo estiver bom ou quando o festival estiver perto do transporte público e seu namorado ou namorada estiver disposto a se juntar a você. Em outras palavras, seria um modelo diferente de tomada de decisão. Reduzir o threshold significa que você está mais propenso a ir ao festival.


Obviamente, o Perceptron não é um modelo completo de tomada de decisão humana! Mas o que o exemplo ilustra é como um Perceptron pode pesar diferentes tipos de evidências para tomar decisões. E deve parecer plausível que uma rede complexa de Perceptrons possa tomar decisões bastante sutis.


 


![Rede](https://www.deeplearningbook.com.br/wp-content/uploads/2017/12/rede.png)


 


Nesta rede, a primeira coluna de Perceptrons – o que chamaremos de primeira camada de Perceptrons – está tomando três decisões muito simples, pesando a evidência de entrada. E quanto aos Perceptrons na segunda camada? Cada um desses Perceptrons está tomando uma decisão ponderando os resultados da primeira camada de tomada de decisão. Desta forma, um Perceptron na segunda camada pode tomar uma decisão em um nível mais complexo e mais abstrato do que os Perceptrons na primeira camada. E as decisões ainda mais complexas podem ser feitas pelos Perceptrons na terceira camada. Desta forma, uma rede de Perceptrons de várias camadas pode envolver-se em uma tomada de decisão sofisticada.


Aliás, quando definimos os Perceptrons, dissemos que um Perceptron possui apenas uma saída. Na rede acima, os Perceptrons parecem ter múltiplos resultados. Na verdade, eles ainda são de saída única. As setas de saída múltiplas são meramente uma maneira útil de indicar que a saída de um Perceptron está sendo usada como entrada para vários outros Perceptrons.


Vamos simplificar a maneira como descrevemos os Perceptrons. No limite de condição **Σjwjxj > threshold** podemos fazer duas mudanças de notação para simplificá-lo. A primeira mudança é escrever Σjwjxj como um produto (dot product), w⋅x≡Σjwjxj, onde w e x são vetores cujos componentes são os pesos e entradas, respectivamente. A segunda mudança é mover o threshold para o outro lado da equação e substituí-lo pelo que é conhecido como o viés (bias) do Perceptron, ou b ≡ -threshold. Usando o viés em vez do threshold, a regra Perceptron pode ser reescrita:


 


![Fórmula Perceptron](https://www.deeplearningbook.com.br/wp-content/uploads/2017/12/formula.png)


 


Você pode pensar no viés como uma medida de quão fácil é obter o Perceptron para produzir um 1. Ou para colocá-lo em termos mais biológicos, o viés é uma medida de quão fácil é fazer com que o Perceptron dispare. Para um Perceptron com um viés realmente grande, é extremamente fácil para o Perceptron emitir um 1. Mas se o viés é muito negativo, então é difícil para o Perceptron emitir um 1. Obviamente, a introdução do viés é apenas uma pequena mudança em como descrevemos Perceptrons, mas veremos mais adiante que isso leva a outras simplificações de notação. Por isso, no restante do livro, não usaremos o threshold, usaremos sempre o viés.


Agora começa a ficar mais fácil compreender o conceito por trás das redes neurais artificiais e isso será muito útil quando estudarmos arquiteturas mais avançadas! Um Perceptron segue o modelo “feed-forward”, o que significa que as entradas são enviadas para o neurônio, processadas e resultam em uma saída. No diagrama abaixo, isso significa que a rede (um neurônio) lê da esquerda para a direita.


 


![Neurônio](https://www.deeplearningbook.com.br/wp-content/uploads/2017/12/neuronio-1.png)


 


O processo de treinamento de um modelo Perceptron consiste em fazer com que o modelo aprenda os valores ideais de pesos e bias. Apresentamos ao modelo os dados de entrada e as possíveis saídas, treinamos o modelo e pesos e bias são aprendidos. Com o modelo treinado, podemos apresentar novos dados de entrada e o modelo será capaz de prever a saída. Veremos isso em breve quando criarmos nosso primeiro modelo usando linguagem Python.


Perceptron é uma rede neural de camada única e um Perceptron de várias camadas é chamado de Rede Neural Artificial. O Perceptron é um classificador linear (binário). Além disso, é usado na aprendizagem supervisionada e pode ser usado para classificar os dados de entrada fornecidos.


Mas o Perceptron tem ainda outras características importantes, como a representação de condicionais lógicos (and, or, xor), problemas com dados não linearmente separáveis e as funções de ativação. Mas esses são temas para o próximo capítulo. Até lá!


Referências:


[Formação Engenheiro de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[The Neural Network Zoo](http://www.asimovinstitute.org/neural-network-zoo/)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/) (alguns trechos extraídos e traduzidos com autorização do autor [Michael Nielsen](http://michaelnielsen.org/))


 


<div id="capitulo-7---o-perceptron---parte-2"></div>

# Capítulo 7 – O Perceptron – Parte 2


O Perceptron é um modelo matemático de um neurônio biológico. Enquanto nos neurônios reais o dendrito recebe sinais elétricos dos axônios de outros neurônios, no Perceptron estes sinais elétricos são representados como valores numéricos. Nas sinapses entre dendritos e axônio, os sinais elétricos são modulados em várias quantidades. Isso também é modelado no Perceptron multiplicando cada valor de entrada por um valor chamado peso. Um neurônio real dispara um sinal de saída somente quando a força total dos sinais de entrada excede um certo limiar. Nós modelamos esse fenômeno em um Perceptron calculando a soma ponderada das entradas para representar a força total dos sinais de entrada e aplicando uma função de ativação na soma para determinar sua saída. Tal como nas redes neurais biológicas, esta saída é alimentada em outros Perceptrons. Estudamos tudo isso no capítulo anterior. Agora vamos continuar nossa discussão sobre o Perceptron compreendendo mais alguns conceitos, que serão fundamentais mais a frente quando estudarmos as arquiteturas avançadas de Deep Learning.


Antes de iniciar, vamos definir dois conceitos que você vai ver com frequência daqui em diante, vetor de entrada e vetor de pesos:


**Vetor de entrada** –  todos os valores de entrada de cada Perceptron são coletivamente chamados de vetor de entrada desse Perceptron. Esses são seus dados de entrada.


**Vetor de pesos** – de forma semelhante, todos os valores de peso de cada Perceptron são coletivamente chamados de vetor de peso desse Perceptron. Iniciamos nossa rede neural artificial com valores aleatórios de pesos e durante o treinamento a rede neural aprende os valores de peso ideais. Como veremos, existem muitas formas de realizar esse processo.


Boa parte do trabalho de uma rede neural vai girar em torno das operações algébricas entre o vetor de entrada e o vetor de pesos. Em seguida, vamos adicionando outras camadas matemáticas ou estatísticas para realizar diferentes operações, de acordo com o problema que estamos tentando resolver com o modelo de rede neural. Você vai perceber que tudo não passa de Matemática, que pode ser implementada com linguagens de programação, grandes conjuntos de dados e processamento paralelo, para formar sistemas de Inteligência Artificial.


### Mas o que um Perceptron pode fazer afinal?


[No capítulo anterior](https://www.deeplearningbook.com.br/capitulo-6-o-perceptron-parte-1/) descrevemos os Perceptrons como um método para pesar evidências a fim de tomar decisões. Outra forma em que os Perceptrons podem ser usados é para calcular as funções lógicas elementares tais como AND, OR e NAND (caso tenha dúvidas sobre as operações lógicas, consulte as referências ao final deste capítulo). Por exemplo, suponha que tenhamos um Perceptron com duas entradas, cada uma com peso -2 e um viés de 3. Aqui está o nosso Perceptron:


 


![Perceptron](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/perceptron.png)


 


Então vemos que a entrada 00 produziria a saída 1, uma vez que (-2) \* 0 + (- 2) \* 0 + 3 = 3, é positivo (resultado positivo, gera saída 1 do Perceptron, lembra do capítulo anterior?). Aqui, incluímos o símbolo \* para tornar as multiplicações explícitas. Cálculos similares mostram que as entradas 01 e 10 produzem a saída 1. Mas a entrada 11 produz a saída 0, uma vez que (-2) \* 1 + (- 2) \* 1 + 3 = -1, é negativo. E assim nosso Perceptron implementa um “portão” NAND, ou uma operação lógica binária NAND.


O exemplo NAND mostra que podemos usar Perceptrons para calcular funções lógicas simples. Na verdade, podemos usar redes de Perceptrons para calcular qualquer função lógica. A razão é que o portão NAND é universal para computação, ou seja, podemos construir qualquer computação com portões NAND.


Uma rede de Perceptrons pode ser usada para simular um circuito contendo muitos portões NAND. E como os portões NAND são universais para a computação, segue-se que os Perceptrons também são universais para a computação. Considerando que o Perceptron é o modelo mais simples de rede neural, imagine o que pode ser feito com modelos bem mais avançados! Acertou se você pensou em Inteligência Artificial.


A universalidade computacional dos Perceptrons é simultaneamente reconfortante e decepcionante. É reconfortante porque nos diz que redes de Perceptrons podem ser tão poderosas como qualquer outro dispositivo de computação. Mas também é decepcionante, porque parece que os Perceptrons são meramente um novo tipo de portão NAND. Isso não é uma grande noticia!


No entanto, a situação é melhor do que esta visão sugere. Acontece que podemos conceber algoritmos de aprendizado que podem ajustar automaticamente os pesos e os vieses de uma rede de neurônios artificiais. Este ajuste ocorre em resposta a estímulos externos, sem intervenção direta de um programador. Esses algoritmos de aprendizagem nos permitem usar neurônios artificiais de uma maneira que é radicalmente diferente dos portões lógicos convencionais. Em vez de colocar explicitamente um circuito de NAND e outros portões, nossas redes neurais podem simplesmente aprender a resolver problemas, às vezes problemas em que seriam extremamente difíceis de projetar diretamente usando um circuito convencional de lógica.


### Operações Lógicas e Regiões Linearmente Separáveis


Conforme mencionado acima, um Perceptron calcula a soma ponderada dos valores de entrada. Por simplicidade, suponhamos que existem dois valores de entrada, x e y para um certo Perceptron P. Vamos definir os pesos de x e y, como sendo A e B, respectivamente. A soma ponderada pode ser representada como: A x + B y.


Uma vez que o Perceptron produz um valor não-zero somente quando a soma ponderada excede um certo limite C, pode-se escrever a saída deste Perceptron da seguinte maneira:


![Regra Perceptron](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/regra.png)


Considerando que A x + B y > C e A x + B y < C são as duas regiões no plano xy separadas pela linha A x + B y + C = 0, e se considerarmos ainda a entrada (x, y) como um ponto em um plano, então o Perceptron realmente nos diz qual região no plano a que esse ponto pertence. Tais regiões, uma vez que são separadas por uma única linha, são chamadas de regiões linearmente separáveis.


Um único Perceptron consegue resolver somente funções linearmente separáveis. Em funções não linearmente separáveis, o Perceptron não consegue gerar um hiperplano, esta linha nos gráficos abaixo, para separar os dados. A questão é que no mundo real raramente os dados são linearmente separáveis, fazendo com o que o Perceptron não seja muito útil para atividades práticas (mas sendo ideal para iniciar o estudo em redes neurais artificiais). E como separamos os dados não linearmente separáveis? Continue acompanhando este livro e você irá descobrir.


![Linear e Não-Linear](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/linsep_new.png)


Mas ainda assim o Perceptron tem sua utilidade, porque resulta em algumas funções lógicas, como os operadores booleanos AND, OR e NOT, que são linearmente separáveis, isto é, eles podem ser realizadas usando um único Perceptron. Podemos ilustrar porque eles são linearmente separáveis ao traçar cada um deles em um gráfico:


 


![Funções Lógicas](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/functions-300x63.png)


 


Nos gráficos acima, os dois eixos são as entradas que podem levar o valor de 0 ou 1 e os números no gráfico são a saída esperada para uma entrada específica. Usando um vetor de peso apropriado para cada caso, um único Perceptron pode executar todas essas funções.


No entanto, nem todos os operadores de lógica são linearmente separáveis. Por exemplo, o operador XOR não é linearmente separável e não pode ser alcançado por um único Perceptron. No entanto, esse problema poderia ser superado usando mais de um Perceptron organizado em redes neurais feed-forward, que veremos mais a frente nos próximos capítulos.


 


![xor](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/xor.jpg)


 


Uma vez que é impossível desenhar uma linha para dividir as regiões contendo 1 ou 0, a função XOR não é linearmente separável, conforme pode ser visto no gráfico acima.


Agora fica mais fácil compreender porque precisamos de arquiteturas mais avançadas de redes neurais artificiais, uma vez que temos problemas complexos no mundo real, como Visão Computacional, Processamento de Linguagem Natural, Tradução, Detecção de Fraudes, Classificação e muitos outros. E veremos essas arquiteturas em detalhes. Mas antes, precisamos falar sobre um componente fundamental das redes neurais, a Função de Ativação. Não perca o próximo capítulo. Até lá.


Referências:


[Operação Lógica AND](https://pt.wikipedia.org/wiki/Porta_AND)


[Operação Lógica OR](https://pt.wikipedia.org/wiki/Porta_OR)


[Operação Lógica NAND](https://pt.wikipedia.org/wiki/Porta_NAND)


[Operação Lógica XOR](https://pt.wikipedia.org/wiki/Porta_XOR)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/) (alguns trechos extraídos e traduzidos com autorização do autor [Michael Nielsen](http://michaelnielsen.org/))


<div id="capitulo-8---funcao-de-ativacao"></div>

# Capítulo 8 – Função de Ativação


Neste capítulo estudaremos um importante componente de uma rede neural artificial, a Função de Ativação. Este capítulo é uma introdução ao tema e voltaremos a ele mais adiante quando estudarmos as arquiteturas avançadas de [Deep Learning](https://www.deeplearningbook.com.br/capitulo-1-deep-learning-a-tempestade-perfeita/). Este capítulo pode ser um pouco desafiador, pois começaremos a introduzir conceitos mais avançados, que serão muito úteis na sequência dos capítulos. Relaxe, faça a leitura e aprenda um pouco mais sobre redes neurais artificiais.


Antes de mergulhar nos detalhes das funções de ativação, vamos fazer uma pequena revisão do que são [redes neurais artificiais](https://www.deeplearningbook.com.br/capitulo-3-o-que-sao-redes-neurais-artificiais-profundas/) e como funcionam. Uma rede neural é um mecanismo de aprendizado de máquina (Machine Learning) muito poderoso que imita basicamente como um cérebro humano aprende. O cérebro recebe o estímulo do mundo exterior, faz o processamento e gera o resultado. À medida que a tarefa se torna complicada, vários neurônios formam uma rede complexa, transmitindo informações entre si. Usando uma rede neural artificial, tentamos imitar um comportamento semelhante. A rede que você vê abaixo é uma rede neural artificial composta de neurônios interligados.


 


![Neural Network](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/nn.png)


 


Os círculos negros na imagem acima são neurônios. Cada neurônio é caracterizado pelo peso, bias e a função de ativação. Os dados de entrada são alimentados na camada de entrada. Os neurônios fazem uma transformação linear na entrada pelos pesos e bias. A transformação não linear é feita pela função de ativação. A informação se move da camada de entrada para as camadas ocultas. As camadas ocultas fazem o processamento e enviam a saída final para a camada de saída. Este é o movimento direto da informação conhecido como propagação direta. Mas e se o resultado gerado estiver longe do valor esperado? Em uma rede neural, atualizaríamos os pesos e bias dos neurônios com base no erro. Este processo é conhecido como backpropagation. Uma vez que todos os dados passaram por este processo, os pesos e bias finais são usados para previsões.


Calma, calma, calma. Muita informação em um único parágrafo, eu sei! Vamos por partes. As entradas, os pesos e bias nós já discutimos nos capítulos anteriores. A função de ativação vamos discutir agora e a propagação direta e o backpropagation discutimos nos próximos capítulos!


### Função de Ativação


Os algoritmos de aprendizagem são fantásticos. Mas como podemos elaborar esses algoritmos para uma rede neural artificial? Suponhamos que tenhamos uma rede de Perceptrons que gostaríamos de usar para aprender a resolver algum problema. Por exemplo, as entradas para a rede poderiam ser os dados de pixel de uma imagem digitalizada, escrita à mão, de um dígito. Gostaríamos que a rede aprendesse pesos e bias para que a saída da rede classifique corretamente o dígito. Para ver como a aprendizagem pode funcionar, suponha que façamos uma pequena alteração em algum peso (ou bias) na rede. O que queremos é que esta pequena mudança de peso cause apenas uma pequena alteração correspondente na saída da rede. Como veremos em um momento, esta propriedade tornará possível a aprendizagem. Esquematicamente, aqui está o que queremos (obviamente, esta rede é muito simples para fazer reconhecimento de escrita, mas fique tranquilo que veremos redes bem mais complexas).


 


![Esquema](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/tikz8.png)


 


Se fosse verdade que uma pequena alteração em um peso (ou bias) fizesse com que tivéssemos apenas uma pequena alteração no resultado, então poderíamos usar esse fato para modificar os pesos e os valores de bias para que a nossa rede se comporte mais da maneira que queremos. Por exemplo, suponha que a rede classificasse equivocadamente uma imagem como “8” quando deveria ser um “9”. Podemos descobrir como fazer uma pequena mudança nos pesos e bias para que a rede fique um pouco mais próxima da classificação da imagem como “9”. E então, repetiríamos isso, mudando os pesos e os valores de bias repetidamente para produzir melhor e melhor resultado. A rede estaria aprendendo.


O problema é que isso não é o que acontece quando nossa rede contém apenas Perceptrons, conforme estudamos nos capítulos anteriores. De fato, uma pequena alteração nos pesos de um único Perceptron na rede pode, por vezes, fazer com que a saída desse Perceptron mude completamente, digamos de 0 a 1. Essa mudança pode então causar o comportamento do resto da rede mudar completamente de uma maneira muito complicada. Então, enquanto o seu “9” pode agora ser classificado corretamente, o comportamento da rede em todas as outras imagens provavelmente mudará completamente de maneira difícil de controlar. Talvez haja uma maneira inteligente de resolver esse problema. Sim, há. E é conhecida como função de ativação.


Podemos superar esse problema através da introdução de um componente matemático em nosso neurônio artificial, chamado função de ativação. As funções de ativação permitem que pequenas mudanças nos pesos e bias causem apenas uma pequena alteração no output. Esse é o fato crucial que permitirá que uma rede de neurônios artificiais aprenda.


Vejamos como isso funciona:


 


![Função de Ativação](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/activation-function-1-1024x426.png)


 


As funções de ativação são um elemento extremamente importante das redes neurais artificiais. Elas basicamente decidem se um neurônio deve ser ativado ou não. Ou seja, se a informação que o neurônio está recebendo é relevante para a informação fornecida ou deve ser ignorada. Veja na fórmula abaixo como a função de ativação é mais uma camada matemática no processamento.


 


![Função de Ativação](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/act.png)


 


A função de ativação é a transformação não linear que fazemos ao longo do sinal de entrada. Esta saída transformada é então enviada para a próxima camada de neurônios como entrada. Quando não temos a função de ativação, os pesos e bias simplesmente fazem uma transformação linear. Uma equação linear é simples de resolver, mas é limitada na sua capacidade de resolver problemas complexos. Uma rede neural sem função de ativação é essencialmente apenas um modelo de regressão linear. A função de ativação faz a transformação não-linear nos dados de entrada, tornando-o capaz de aprender e executar tarefas mais complexas. Queremos que nossas redes neurais funcionem em tarefas complicadas, como traduções de idiomas (Processamento de Linguagem Natural) e classificações de imagens (Visão Computacional). As transformações lineares nunca seriam capazes de executar tais tarefas.


As funções de ativação tornam possível a propagação posterior desde que os gradientes sejam fornecidos juntamente com o erro para atualizar os pesos e bias. Sem a função não linear diferenciável, isso não seria possível. Caso o termo gradiente não seja familiar, aguarde os próximos capítulos, quando vamos explicar este conceito em detalhes, visto que ele é a essência do processo de aprendizagem em redes neurais artificiais.


Mas não existe apenas um tipo de função de ativação. Na verdade existem vários, cada qual a ser usado em diferentes situações. Vamos a uma breve descrição dos tipos mais populares.


### Tipos Populares de Funções de Ativação


A função de ativação é um componente matemático incluído na estrutura de redes neurais artificiais a fim de permitir a solução de problemas complexos. Existem diversos tipos de funções de ativação e esta é uma área de pesquisa ativa, à medida que a Inteligência Artificial evolui (não é maravilhoso estar participando desta evolução, que vai transformar completamente o mundo?). Vejamos quais são os tipos mais populares.


### Função de Etapa Binária (Binary Step Function)


A primeira coisa que vem à nossa mente quando temos uma função de ativação seria um classificador baseado em limiar (threshold), ou seja, se o neurônio deve ou não ser ativado. Se o valor Y estiver acima de um valor de limite determinado, ative o neurônio senão deixa desativado. Simples! Essa seria a regra:


**f(x) = 1, x>=0**


**f(x) = 0, x<0**


A função de etapa binária é isso mesmo, extremamente simples. Ela pode ser usada ao criar um classificador binário. Quando simplesmente precisamos dizer sim ou não para uma única classe, a função de etapa seria a melhor escolha, pois ativaria o neurônio ou deixaria zero.


A função é mais teórica do que prática, pois, na maioria dos casos, classificamos os dados em várias classes do que apenas uma única classe. A função de etapa não seria capaz de fazer isso.


Além disso, o gradiente da função de etapa é zero. Isso faz com que a função de etapa não seja tão útil durante o backpropagation quando os gradientes das funções de ativação são enviados para cálculos de erro para melhorar e otimizar os resultados. O gradiente da função de etapa reduz tudo para zero e a melhoria dos modelos realmente não acontece. Lembrando, mais uma vez, que veremos em detalhes os conceitos de gradiente e backpropagation mais adiante, nos próximos capítulos!


### Função Linear


Nós vimos o problema com a função step, o gradiente sendo zero, é impossível atualizar o gradiente durante a backpropagation. Em vez de uma função de passo simples, podemos tentar usar uma função linear. Podemos definir a função como:


 **f(x) = ax**


A derivada de uma função linear é constante, isto é, não depende do valor de entrada x. Isso significa que toda vez que fazemos backpropagation, o gradiente seria o mesmo. E este é um grande problema, não estamos realmente melhorando o erro, já que o gradiente é praticamente o mesmo. E não apenas suponha que estamos tentando realizar uma tarefa complicada para a qual precisamos de múltiplas camadas em nossa rede. Agora, se cada camada tiver uma transformação linear, não importa quantas camadas nós tenhamos, a saída final não é senão uma transformação linear da entrada. Portanto, a função linear pode ser ideal para tarefas simples, onde a interpretabilidade é altamente desejada.


### Sigmóide


Sigmóide é uma função de ativação amplamente utilizada. É da forma:


 **f (x) = 1 / (1 + e ^ -x)**


Esta é uma função suave e é continuamente diferenciável. A maior vantagem sobre a função de etapa e a função linear é que não é linear. Esta é uma característica incrivelmente interessante da função sigmóide. Isto significa essencialmente que quando eu tenho vários neurônios com função sigmóide como função de ativação – a saída também não é linear. A função varia de 0 a 1 tendo um formato S.


A função essencialmente tenta empurrar os valores de Y para os extremos. Esta é uma qualidade muito desejável quando tentamos classificar os valores para uma classe específica.


A função sigmóide ainda é amplamente utilizada até hoje, mas ainda temos problemas que precisamos abordar. Com a sigmóide temos problemas quando os gradientes se tornam muito pequenos. Isso significa que o gradiente está se aproximando de zero e a rede não está realmente aprendendo.


Outro problema que a função sigmóide sofre é que os valores variam apenas de 0 a 1. Esta medida que a função sigmóide não é simétrica em torno da origem e os valores recebidos são todos positivos. Nem sempre desejamos que os valores enviados ao próximo neurônio sejam todos do mesmo sinal. Isso pode ser abordado pela ampliação da função sigmóide. Isso é exatamente o que acontece na função tanh.


### Tanh


A função tanh é muito semelhante à função sigmóide. Na verdade, é apenas uma versão escalonada da função sigmóide.


**Tanh (x) = 2sigmoides (2x) -1**


Pode ser escrito diretamente como:


**tanh (x) = 2 / (1 + e ^ (- 2x)) -1**


Tanh funciona de forma semelhante à função sigmóide, mas sim simétrico em relação à origem. varia de -1 a 1.


Basicamente, soluciona o nosso problema dos valores, sendo todos do mesmo sinal. Todas as outras propriedades são as mesmas da função sigmoide. É contínuo e diferenciável em todos os pontos. A função não é linear, então podemos fazer o backpropagation facilmente nos erros.


### ReLU


A função ReLU é a unidade linear rectificada. É definida como:


**f(x) = max (0, x)**


ReLU é a função de ativação mais amplamente utilizada ao projetar redes neurais atualmente. Primeiramente, a função ReLU é não linear, o que significa que podemos facilmente copiar os erros para trás e ter várias camadas de neurônios ativados pela função ReLU.


A principal vantagem de usar a função ReLU sobre outras funções de ativação é que ela não ativa todos os neurônios ao mesmo tempo. O que isto significa ? Se você olhar para a função ReLU e a entrada for negativa, ela será convertida em zero e o neurônio não será ativado. Isso significa que, ao mesmo tempo, apenas alguns neurônios são ativados, tornando a rede esparsa e eficiente e fácil para a computação.


Mas ReLU também pode ter problemas com os gradientes que se deslocam em direção a zero. Mas quando temos um problema, sempre podemos pensar em uma solução. Aliás, isso é o que as empresas mais procuram nos dias de hoje: “resolvedores de problemas”. Seja um e sua empregabilidade estará garantida!


### Leaky ReLU


A função Leaky ReLU não passa de uma versão melhorada da função ReLU. Na função ReLU, o gradiente é 0 para x < 0, o que fez os neurônios morrerem por ativações nessa região. Leaky ReLU ajuda a resolver este problema. Em vez de definir a função Relu como 0 para x inferior a 0, definimos como um pequeno componente linear de x. Pode ser definido como:


**f(x) = ax, x < 0**  

 **f(x) = x, x > = 0**


O que fizemos aqui é que simplesmente substituímos a linha horizontal por uma linha não-zero, não horizontal. Aqui um é um valor pequeno como 0,01 ou algo parecido. A principal vantagem de substituir a linha horizontal é remover o gradiente zero.


### Softmax


A função softmax também é um tipo de função sigmóide, mas é útil quando tentamos lidar com problemas de classificação. A função sigmóide como vimos anteriormente é capaz de lidar com apenas duas classes. O que devemos fazer quando estamos tentando lidar com várias classes? Apenas classificar sim ou não para uma única classe não ajudaria. A função softmax transforma as saídas para cada classe para valores entre 0 e 1 e também divide pela soma das saídas. Isso essencialmente dá a probabilidade de a entrada estar em uma determinada classe. Pode ser definido como:


 


![Softmax](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/softmax.png)


 


Digamos, por exemplo, que temos as saídas como [1.2, 0.9, 0.75], quando aplicamos a função softmax, obteríamos [0.42, 0.31, 0.27]. Então, agora podemos usá-los como probabilidades de que o valor seja de cada classe.


A função softmax é idealmente usada na camada de saída do classificador, onde realmente estamos tentando gerar as probabilidades para definir a classe de cada entrada.


### Escolhendo a Função de Ativação Correta


Ufa! Muita coisa, não? E ainda não vimos as questões matemáticas envolvidas nessas funções. Mas não tenhamos pressa, não existe atalho para o aprendizado e estudaremos tudo passo a passo, item a item, no padrão dos cursos na [Data Science Academy](https://www.datascienceacademy.com.br).


Agora que já vimos tantas funções de ativação, precisamos de alguma lógica/heurística para saber qual função de ativação deve ser usada em qual situação. Não há uma regra de ouro e a escolha depende do problema no qual você estiver trabalhando.


No entanto, dependendo das propriedades do problema, poderemos fazer uma melhor escolha para uma convergência fácil e rápida da rede neural.


* Funções Sigmóide e suas combinações geralmente funcionam melhor no caso de classificadores.
* Funções Sigmóide e Tanh às vezes são evitadas devido ao problema de Vanishing Gradient (que estudaremos no capítulo sobre redes neurais recorrentes).
* A função ReLU é uma função de ativação geral e é usada na maioria dos casos atualmente.
* Se encontrarmos um caso de neurônios deficientes em nossas redes, a função Leaky ReLU é a melhor escolha.
* Tenha sempre em mente que a função ReLU deve ser usada apenas nas camadas ocultas.
* Como regra geral, você pode começar usando a função ReLU e depois passar para outras funções de ativação no caso da ReLU não fornecer resultados ótimos.


Está começando a sentir a vibração em trabalhar com Inteligência Artificial? Então continue acompanhando, pois estamos apenas no começo! Até o próximo capítulo!


Referências:


[Função Sigmóide](https://pt.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_sigm%C3%B3ide)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Vanishing Gradient Problem](https://en.wikipedia.org/wiki/Vanishing_gradient_problem)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/) (alguns trechos extraídos e traduzidos com autorização do autor [Michael Nielsen](http://michaelnielsen.org/))


<div id="capitulo-9---a-arquitetura-das-redes-neurais"></div>

# Capítulo 9 – A Arquitetura das Redes Neurais


No capítulo 11 vamos desenvolver uma rede neural para classificação de dígitos manuscritos, usando linguagem Python (caso ainda não saiba trabalhar com a linguagem, comece agora mesmo com nosso curso online totalmente gratuito [Python Fundamentos Para Análise de Dados](https://www.datascienceacademy.com.br/cursosgratuitos)). Mas antes, vamos compreender a terminologia que será muito útil quando estivermos desenvolvendo nosso modelo, estudando a Arquitetura das Redes Neurais. Suponha que tenhamos a rede abaixo:


 


![Rede](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/rede.png)


 


A camada mais à esquerda nesta rede é chamada de camada de entrada e os neurônios dentro da camada são chamados de neurônios de entrada. A camada mais à direita ou a saída contém os neurônios de saída ou, como neste caso, um único neurônio de saída. A camada do meio é chamada de camada oculta, já que os neurônios nessa camada não são entradas ou saídas. O termo “oculto” talvez soe um pouco misterioso – a primeira vez que ouvi o termo, pensei que devesse ter algum significado filosófico ou matemático profundo – mas isso realmente não significa nada mais do que “uma camada que não é entrada ou saída”. A rede acima tem apenas uma única camada oculta, mas algumas redes possuem múltiplas camadas ocultas. Por exemplo, a seguinte rede de quatro camadas tem duas camadas ocultas:


 


![Rede](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/rede2.png)


 


Tais redes de camadas múltiplas são chamados de Perceptrons Multicamadas ou MLPs (Multilayer Perceptrons), ou seja, uma rede neural formada por Perceptrons (embora na verdade seja uma rede de neurônios sigmóides, como veremos mais adiante).


O design das camadas de entrada e saída em uma rede geralmente é direto. Por exemplo, suponha que estamos tentando determinar se uma imagem manuscrita representa um “9” ou não. Uma maneira natural de projetar a rede é codificar as intensidades dos pixels da imagem nos neurônios de entrada. Se a imagem for uma imagem em escala de cinza 64 x 64, teríamos 64 × 64 = 4.096  neurônios de entrada, com as intensidades dimensionadas adequadamente entre 0 e 1. A camada de saída conterá apenas um único neurônio com valores inferiores a 0,5 indicando que “a imagem de entrada não é um 9” e valores maiores que 0,5 indicando que “a imagem de entrada é um 9”.


Embora o design das camadas de entrada e saída de uma rede neural seja frequentemente direto, pode haver bastante variação para o design das camadas ocultas. Em particular, não é possível resumir o processo de design das camadas ocultas com poucas regras simples. Em vez disso, pesquisadores de redes neurais desenvolveram muitas heurísticas de design para as camadas ocultas, que ajudam as pessoas a obter o comportamento que querem de suas redes. Conheceremos várias heurísticas de design desse tipo mais adiante ao longo dos próximos capítulos. O design das camadas ocultas é um dos pontos cruciais em modelos de Deep Learning.


Até agora, estamos discutindo redes neurais onde a saída de uma camada é usada como entrada para a próxima camada. Essas redes são chamadas de redes neurais feedforward. Isso significa que não há loops na rede – as informações sempre são alimentadas para a frente, nunca são enviadas de volta. Se tivéssemos loops, acabaríamos com situações em que a entrada para a função σ dependeria da saída. Isso seria difícil de entender e, portanto, não permitimos tais loops.


No entanto, existem outros modelos de redes neurais artificiais em que os circuitos de feedback são possíveis. Esses modelos são chamados de redes neurais recorrentes. A ideia nestes modelos é ter neurônios que disparem por algum período de tempo limitado. Disparar pode estimular outros neurônios, que podem disparar um pouco mais tarde, também por uma duração limitada. Isso faz com que ainda mais neurônios disparem e, ao longo do tempo, conseguimos uma cascata de disparos de neurônios. Loops não causam problemas em tal modelo, uma vez que a saída de um neurônio afeta apenas sua entrada em algum momento posterior, não instantaneamente.


Geralmente, as arquiteturas de redes neurais podem ser colocadas em 3 categorias específicas:


### 1- Redes Neurais Feed-Forward


Estes são o tipo mais comum de rede neural em aplicações práticas. A primeira camada é a entrada e a última camada é a saída. Se houver mais de uma camada oculta, nós as chamamos de redes neurais “profundas” (ou Deep Learning). Esses tipos de redes neurais calculam uma série de transformações que alteram as semelhanças entre os casos. As atividades dos neurônios em cada camada são uma função não-linear das atividades na camada anterior.


### 2- Redes Recorrentes


Estes tipos de redes neurais têm ciclos direcionados em seu grafo de conexão. Isso significa que às vezes você pode voltar para onde você começou seguindo as setas. Eles podem ter uma dinâmica complicada e isso pode torná-los muito difíceis de treinar. Entretanto, estes tipos são mais biologicamente realistas.


Atualmente, há muito interesse em encontrar formas eficientes de treinamento de redes recorrentes. As redes neurais recorrentes são uma maneira muito natural de modelar dados sequenciais. Eles são equivalentes a redes muito profundas com uma camada oculta por fatia de tempo; exceto que eles usam os mesmos pesos em cada fatia de tempo e recebem entrada em cada fatia. Eles têm a capacidade de lembrar informações em seu estado oculto por um longo período de tempo, mas é muito difícil treiná-las para usar esse potencial.


### 3- Redes Conectadas Simetricamente


Estas são como redes recorrentes, mas as conexões entre as unidades são simétricas (elas têm o mesmo peso em ambas as direções). As redes simétricas são muito mais fáceis de analisar do que as redes recorrentes. Elas também são mais restritas no que podem fazer porque obedecem a uma função de energia. As redes conectadas simetricamente sem unidades ocultas são chamadas de “Redes Hopfield”. As redes conectadas simetricamente com unidades ocultas são chamadas de “Máquinas de Boltzmann”.




---


Dentre estas 3 categorias, podemos listar 10 arquiteturas principais de redes neurais:


* Redes Multilayer Perceptron
* Redes Neurais Convolucionais
* Redes Neurais Recorrentes
* Long Short-Term Memory (LSTM)
* Redes de Hopfield
* Máquinas de Boltzmann
* Deep Belief Network
* Deep Auto-Encoders
* Generative Adversarial Network
* Deep Neural Network Capsules (este é um tipo completamente novo de rede neural, lançado no final de 2017)


Quer aprender a construir essas arquiteturas de redes neurais de forma eficiente, profissional e totalmente prática, com mini-projetos para solução de problemas do mundo real, em visão computacional, processamento de linguagem natural, detecção de fraudes, previsão de séries temporais e muito mais? Então confira os únicos cursos online do Brasil, 100% em português, onde você aprende tudo sobre essas arquiteturas. Clique no link abaixo e comece agora mesmo:


 


[Formação Engenheiro de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)
===================================================================================================


 


No próximo capítulo, daremos a você uma visão geral sobre cada uma dessas 10 arquiteturas e ao longo dos capítulos seguintes, estudaremos todas elas. Cada umas dessas arquiteturas tem sido usada para resolver diferentes problemas e criar sistemas de Inteligência Artificial. Saber trabalhar com IA de forma eficiente, será determinante para seu futuro profissional.


Referências:


[Função Sigmóide](https://pt.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_sigm%C3%B3ide)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Vanishing Gradient Problem](https://en.wikipedia.org/wiki/Vanishing_gradient_problem)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/) (alguns trechos extraídos e traduzidos com autorização do autor [Michael Nielsen](http://michaelnielsen.org/))


<div id="capitulo-10---as-10-principais-arquiteturas-de-redes-neurais"></div>

# Capítulo 10 – As 10 Principais Arquiteturas de Redes Neurais


O Aprendizado de Máquina ([Machine Learning](https://www.datascienceacademy.com.br/course/machine-learning-engineer)) é necessário para resolver tarefas que são muito complexas para os humanos. Algumas tarefas são tão complexas que é impraticável, senão impossível, que os seres humanos consigam explicar todas as nuances envolvidas. Então, em vez disso, fornecemos uma grande quantidade de dados para um algoritmo de aprendizado de máquina e deixamos que o algoritmo funcione, explorando esses dados e buscando um modelo que alcance o que os [Cientistas de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) e [Engenheiros de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia) determinaram como objetivo. Vejamos estes dois exemplos:


– É muito difícil escrever programas que solucionem problemas como reconhecer um objeto tridimensional a partir de um novo ponto de vista em novas condições de iluminação em uma cena desordenada. Nós não sabemos qual programa de computador escrever porque não sabemos como ocorre o processo em nosso cérebro. Mesmo se tivéssemos uma boa ideia sobre como fazê-lo, o programa poderia ser incrivelmente complicado.


– É difícil escrever um programa para calcular a probabilidade de uma transação de cartão de crédito ser fraudulenta. Pode não haver regras que sejam simples e confiáveis. Precisamos combinar um número muito grande de regras fracas. A fraude é um alvo em movimento, mas o programa precisa continuar mudando.


É onde Machine Learning pode ser aplicado com sucesso. Em vez de escrever um programa à mão para cada tarefa específica, nós coletamos muitos exemplos que especificam a saída correta para uma determinada entrada. Um algoritmo de aprendizagem de máquina recebe esses exemplos e produz um programa que faz o trabalho. O programa produzido pelo algoritmo de aprendizagem pode parecer muito diferente de um programa típico escrito à mão. Pode conter milhões de números. Se o fizermos corretamente, o programa funciona para novos casos (novos dados). Se os dados mudarem, o programa também pode mudar ao treinar em novos dados. E com a redução de custos de computação (principalmente usando processamento em nuvem), grande quantidade de dados (Big Data) e processamento paralelo em GPU, temos as condições perfeitas para a evolução de Machine Learning. O maior problema, por incrível que pareça, será a falta de profissionais qualificados em número suficiente para atender as demandas do mercado.


Alguns exemplos de tarefas melhor resolvidas pela aprendizagem de máquina incluem:


* Reconhecimento de padrões: objetos em cenas reais, identidades faciais ou expressões faciais, palavras escritas ou faladas.
* Detecção de anomalias: sequências incomuns de transações de cartão de crédito, padrões incomuns de leituras de sensores em máquinas de uma indústria têxtil.
* Previsão: preços de ações futuros ou taxas de câmbio, quais filmes uma pessoa gostaria de assistir, previsão de vendas.


Machine Learning é um campo abrangente dentro da Inteligência Artificial. Mas uma sub-área de Machine Learning, o [Deep Learning](https://www.deeplearningbook.com.br/capitulo-3-o-que-sao-redes-neurais-artificiais-profundas/) (ou Redes Neurais Profundas), vem conseguindo resultados no estado da arte para as tarefas acima mencionadas. Neste capítulo você encontra As 10 Principais Arquiteturas de Redes Neurais, dentre elas as principais arquiteturas de Deep Learning.


### 1- Redes Multilayer Perceptrons


O Perceptron, conforme estudamos nos capítulos anteriores, é um algoritmo simples destinado a realizar a classificação binária; isto é, prevê se a entrada pertence a uma determinada categoria de interesse ou não: fraude ou não\_fraude, gato ou não\_gato.


![Multilayer Perceptrons (MLP)](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/mlp-1024x583.jpg)


Um Perceptron é um classificador linear; ou seja, é um algoritmo que classifica a entrada separando duas categorias com uma linha reta. A entrada geralmente é um vetor de recursos **x** multiplicado por pesos **w** e adicionado a um viés (ou bias) **b**. Aqui um exemplo do Perceptron: y = w \* x + b. Um Perceptron produz uma única saída com base em várias entradas de valor real, formando uma combinação linear usando os pesos (e às vezes passando a saída através de uma função de ativação não linear).


[Rosenblatt](https://en.wikipedia.org/wiki/Frank_Rosenblatt) construiu um Perceptron de uma camada. Ou seja, seu algoritmo não inclui múltiplas camadas, o que permite que as redes neurais modelem uma hierarquia de recursos. Isso impede que o Perceptron consiga realizar classificação não linear, como a função XOR (um disparador do operador XOR quando a entrada exibe uma característica ou outra, mas não ambas, significa “OR exclusivo” “), como [Minsky e Papert](https://mitpress.mit.edu/books/perceptrons) mostraram em seu livro.


Um Multilayer Perceptron (MLP) é uma rede neural artificial composta por mais de um Perceptron. Eles são compostos por uma camada de entrada para receber o sinal, uma camada de saída que toma uma decisão ou previsão sobre a entrada, e entre esses dois, um número arbitrário de camadas ocultas que são o verdadeiro mecanismo computacional do MLP. MLPs com uma camada oculta são capazes de aproximar qualquer função contínua.


O Multilayer Perceptron é uma espécie de “Hello World” da aprendizagem profunda: uma boa forma de começar quando você está aprendendo sobre Deep Learning.


Os MLPs são frequentemente aplicados a problemas de aprendizagem supervisionados: treinam em um conjunto de pares entrada-saída e aprendem a modelar a correlação (ou dependências) entre essas entradas e saídas. O treinamento envolve o ajuste dos parâmetros, ou os pesos e bias, do modelo para minimizar o erro. O backpropagation é usado para fazer os ajustes dos pesos e de bias em relação ao erro, e o próprio erro pode ser medido de várias maneiras, inclusive pelo erro quadrático médio (MSE – Mean Squared Error).


As redes feed forward, como MLPs, são como ping-pong. Elas são principalmente envolvidas em dois movimentos, uma constante de ida e volta.  Na passagem para a frente, o fluxo de sinal se move da camada de entrada através das camadas ocultas para a camada de saída e a decisão da camada de saída é medida em relação às saídas esperadas.


Na passagem para trás, usando o backpropagation e a regra da cadeia (Chain Rule), derivadas parciais da função de erro dos vários pesos e bias são reproduzidos através do MLP. Esse ato de diferenciação nos dá um gradiente, ao longo do qual os parâmetros podem ser ajustados à medida que movem o MLP um passo mais perto do erro mínimo. Isso pode ser feito com qualquer algoritmo de otimização baseado em gradiente, como descida estocástica do gradiente. A rede continua jogando aquele jogo de ping-pong até que o erro não possa mais ser reduzido (chegou ao mínimo possível). Este estado é conhecido como convergência.


Parece muita coisa? Sim, é. Veremos esse processo em mais detalhes aqui mesmo neste livro e caso queira aprender a construir modelos MLP para aplicações práticas, através de vídeos em português, clique [aqui](https://www.datascienceacademy.com.br/pages/curso-deep-learning-i).


### 2- Redes Neurais Convolucionais


Em 1998, [Yann LeCun](http://yann.lecun.com/) e seus colaboradores desenvolveram um reconhecedor, realmente bom, para dígitos manuscritos chamado [LeNet](http://yann.lecun.com/exdb/lenet/). Ele usou o backpropagation em uma rede feed forward com muitas camadas ocultas, muitos mapas de unidades replicadas em cada camada, agrupando as saídas de unidades próximas, formando uma rede ampla que pode lidar com vários caracteres ao mesmo tempo, mesmo se eles se sobrepõem e uma inteligente maneira de treinar um sistema completo, não apenas um reconhecedor. Mais tarde, esta arquitetura foi formalizada sob o nome de redes neurais convolucionais.


As Redes Neurais Convolucionais (ConvNets ou CNNs) são redes neurais artificiais profundas que podem ser usadas para classificar imagens, agrupá-las por similaridade (busca de fotos) e realizar reconhecimento de objetos dentro de cenas. São algoritmos que podem identificar rostos, indivíduos, sinais de rua, cenouras, ornitorrincos e muitos outros aspectos dos dados visuais.


As redes convolucionais realizam o reconhecimento óptico de caracteres (OCR) para digitalizar texto e tornar possível o processamento de linguagem natural em documentos analógicos e manuscritos, onde as imagens são símbolos a serem transcritos. CNNs também podem ser aplicadas a arquivos de áudio quando estes são representados visualmente como um espectrograma. Mais recentemente, as redes convolucionais foram aplicadas diretamente à análise de texto, bem como dados gráficos.


A eficácia das redes convolucionais no reconhecimento de imagem é uma das principais razões pelas quais o mundo testemunhou a eficácia do aprendizado profundo. Este tipo de rede está impulsionando grandes avanços em [Visão Computacional](https://www.datascienceacademy.com.br/pages/curso-visao-computacional-e-reconhecimento-de-imagens), que tem aplicações óbvias em carros autônomos, robótica, drones, segurança, diagnósticos médicos e tratamentos para deficientes visuais.


As redes convolucionais ingerem e processam imagens como tensores e tensores são matrizes de números com várias dimensões. Eles podem ser difíceis de visualizar, então vamos abordá-los por analogia. Um escalar é apenas um número, como 7; um vetor é uma lista de números (por exemplo, [7,8,9]); e uma matriz é uma grade retangular de números que ocupam várias linhas e colunas como uma planilha. Geometricamente, se um escalar é um ponto de dimensão zero, então um vetor é uma linha unidimensional, uma matriz é um plano bidimensional, uma pilha de matrizes é um cubo tridimensional e quando cada elemento dessas matrizes tem uma pilha de mapas de recursos ligados a ele, você entra na quarta dimensão. Calma, não se desespere (ainda). Veremos isso mais a frente com calma, quando estudarmos exclusivamente esta arquitetura. Em nossos cursos na Data Science Academy incluímos aulas completas sobre Álgebra Linear, onde escalares, vetores, matrizes e tensores são estudados na teoria e prática, pois este conhecimento é fundamental na construção de redes neurais profundas.


A primeira coisa a saber sobre redes convolucionais é que elas não percebem imagens como os humanos. Portanto, você terá que pensar de uma maneira diferente sobre o que uma imagem significa quando é alimentada e processada por uma rede convolucional.


![CNN](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/cnn.png)


As redes convolucionais percebem imagens como volumes; isto é, objetos tridimensionais, em vez de estruturas planas a serem medidas apenas por largura e altura. Isso porque as imagens de cores digitais têm uma codificação vermelho-verde-azul (RGB – Red-Green-Blue), misturando essas três cores para produzir o espectro de cores que os seres humanos percebem. Uma rede convolucional recebe imagens como três estratos separados de cores empilhados um em cima do outro.


Assim, uma rede convolucional recebe uma imagem como uma caixa retangular cuja largura e altura são medidas pelo número de pixels ao longo dessas dimensões e cuja profundidade é de três camadas profundas, uma para cada letra em RGB. Essas camadas de profundidade são referidas como canais.


À medida que as imagens se movem através de uma rede convolucional, descrevemos em termos de volumes de entrada e saída, expressando-as matematicamente como matrizes de múltiplas dimensões dessa forma: 30x30x3. De camada em camada, suas dimensões mudam à medida que atravessam a rede neural convolucional até gerar uma série de probabilidades na camada de saída, sendo uma probabilidade para cada possível classe de saída. Aquela com maior probabilidade, será a classe definida para a imagem de entrada, um pássaro por exemplo.


Você precisará prestar muita atenção às medidas de cada dimensão do volume da imagem, porque elas são a base das operações de álgebra linear usadas para processar imagens. Poderíamos dedicar dois capítulos inteiros somente a esta arquitetura. Aliás, é o que faremos mais à frente aqui no livro e o que já fazemos na prática [aqui](https://www.datascienceacademy.com.br/course/deep-learning-para-aplicacoes-de-ia-com-pytorch-e-lightning).


### 3- Redes Neurais Recorrentes


As redes recorrentes são um poderoso conjunto de algoritmos de redes neurais artificiais especialmente úteis para o processamento de dados sequenciais, como som, dados de séries temporais ou linguagem natural. Uma versão de redes recorrentes foi usada pelo [DeepMind](https://deepmind.com/) no projeto de videogames com agentes autônomos.


As redes recorrentes diferem das redes feed forward porque incluem um loop de feedback, pelo qual a saída do passo n-1 é alimentada de volta à rede para afetar o resultado do passo n, e assim por diante para cada etapa subsequente. Por exemplo, se uma rede é exposta a uma palavra letra por letra, e é solicitado a adivinhar cada letra a seguir, a primeira letra de uma palavra ajudará a determinar o que uma rede recorrente pensa que a segunda letra pode ser.


Isso difere de uma rede feed forward, que aprende a classificar cada número manuscrito por exemplo, independentemente, e de acordo com os pixels de que é exposto a partir de um único exemplo, sem se referir ao exemplo anterior para ajustar suas previsões. As redes feed forward aceitam uma entrada por vez e produzem uma saída. As redes recorrentes não enfrentam a mesma restrição um-para-um.


Embora algumas formas de dados, como imagens, não pareçam ser sequenciais, elas podem ser entendidas como sequências quando alimentadas em uma rede recorrente. Considere uma imagem de uma palavra manuscrita. Assim como as redes recorrentes processam a escrita manual, convertendo cada imagem em uma letra e usando o início de uma palavra para adivinhar como essa palavra terminará, então as redes podem tratar parte de qualquer imagem como letras em uma sequência. Uma rede neural que percorre uma imagem grande pode aprender a partir de cada região, o que as regiões vizinhas, são mais prováveis ​​de ser.


 


![Redes Neurais Recorrentes](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/rnn.gif)


 


As redes recorrentes e as redes feed forward “lembram” algo sobre o mundo, modelando os dados que estão expostos. Mas elas se lembram de maneiras muito diferentes. Após o treinamento, a rede feed forward produz um modelo estático dos dados e esse modelo pode então aceitar novos exemplos e classificá-los ou agrupá-los com precisão.


Em contraste, as redes recorrentes produzem modelos dinâmicos – ou seja, modelos que mudam ao longo do tempo – de formas que produzem classificações precisas dependentes do contexto dos exemplos que estão expostos.


Para ser preciso, um modelo recorrente inclui o estado oculto que determinou a classificação anterior em uma série. Em cada etapa subsequente, esse estado oculto é combinado com os dados de entrada do novo passo para produzir a) um novo estado oculto e, em seguida, b) uma nova classificação. Cada estado oculto é reciclado para produzir seu sucessor modificado.


As memórias humanas também são conscientes do contexto, reciclando a consciência de estados anteriores para interpretar corretamente novos dados. Por exemplo, vamos considerar dois indivíduos. Um está ciente de que ele está perto da casa de Bob. O outro está ciente de que entrou em um avião. Eles interpretarão os sons “Oi Bob!” de duas formas muito diferentes, precisamente porque retém um estado oculto afetado por suas memórias de curto prazo e sensações precedentes.


Diferentes lembranças de curto prazo devem ser recontadas em momentos diferentes, a fim de atribuir o significado certo à entrada atual. Algumas dessas memórias terão sido forjadas recentemente e outras memórias terão forjado muitos passos antes de serem necessários. A rede recorrente que efetivamente associa memórias e entrada remota no tempo é chamada de Memória de Longo Prazo (LSTM), a qual veremos em seguida.


### 4- Long Short-Term Memory (LSTM)


Em meados dos anos 90, a proposta dos pesquisadores alemães [Sepp Hochreiter e Juergen Schmidhuber](http://www.bioinf.jku.at/publications/older/2604.pdf) apresentou uma variação da rede recorrente com as chamadas unidades de Long Short-Term Memory, como uma solução para o problema do vanishing gradient, problema comum em redes neurais recorrentes.


Os LSTMs ajudam a preservar o erro que pode ser copiado por tempo e camadas. Ao manter um erro mais constante, eles permitem que as redes recorrentes continuem aprendendo durante vários passos de tempo (mais de 1000), abrindo assim um canal para vincular causas e efeitos remotamente. Este é um dos desafios centrais para a aprendizagem de máquina e a IA, uma vez que os algoritmos são frequentemente confrontados por ambientes onde os sinais de recompensa são escassos e atrasados, como a própria vida. (Os pensadores religiosos abordaram este mesmo problema com ideias de karma ou recompensas divinas, teorizando consequências invisíveis e distantes para nossas ações).


Os LSTMs contêm informações fora do fluxo normal da rede recorrente em uma célula fechada. As informações podem ser armazenadas, escritas ou lidas a partir de uma célula, como dados na memória de um computador. A célula toma decisões sobre o que armazenar, e quando permitir leituras, gravações e exclusões, através de portões abertos e fechados. Ao contrário do armazenamento digital em computadores, no entanto, esses portões são analógicos, implementados com a multiplicação de elementos por sigmóides, que estão todos na faixa de 0-1. Analógico tem a vantagem sobre o digital de ser diferenciável e, portanto, adequado para backpropagation.


Esses portões atuam sobre os sinais que recebem e, de forma semelhante aos nós da rede neural, eles bloqueiam ou transmitem informações com base em sua força e importação, que eles filtram com seus próprios conjuntos de pesos. Esses pesos, como os pesos que modulam a entrada e estados ocultos, são ajustados através do processo de aprendizagem das redes recorrentes. Ou seja, as células aprendem quando permitir que os dados entrem, saiam ou sejam excluídos através do processo iterativo de fazer suposições, calculando o erro durante o backpropagation e ajustando pesos através da descida do gradiente.


O diagrama abaixo ilustra como os dados fluem através de uma célula de memória e são controlados por seus portões.


![Long Short-Term Memory](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/lstm.png)


 


Os LSTM’s possuem muitas aplicações práticas, incluindo processamento de linguagem natural, geração automática de texto e análise de séries temporais. Caso queira ver esses exemplos na prática, clique [aqui](https://www.datascienceacademy.com.br/pages/curso-deep-learning-ii). Teremos um capítulo inteiro dedicado aos LSTM’s aqui no livro.


### 5- Redes de Hopfield


Redes recorrentes de unidades não lineares geralmente são muito difíceis de analisar. Elas podem se comportar de muitas maneiras diferentes: se estabelecer em um estado estável, oscilar ou seguir trajetórias caóticas que não podem ser preditas no futuro. Uma Rede Hopfield é composta por unidades de limite binário com conexões recorrentes entre elas. Em 1982, John Hopfield percebeu que, se as conexões são simétricas, existe uma função de energia global. Cada “configuração” binária de toda a rede possui energia, enquanto a regra de decisão do limite binário faz com que a rede se conforme com um mínimo desta função de energia. Uma excelente maneira de usar esse tipo de computação é usar memórias como energia mínima para a rede neural. Usar mínimos de energia para representar memórias resulta em uma memória endereçável ao conteúdo. Um item pode ser acessado por apenas conhecer parte do seu conteúdo. É robusto contra danos no hardware.


 


![Hopfield](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/hopfield.png)


 


Cada vez que memorizamos uma configuração, esperamos criar um novo mínimo de energia. Mas e se dois mínimos próximos estão em um local intermediário? Isso limita a capacidade de uma Rede Hopfield. Então, como aumentamos a capacidade de uma Rede Hopfield? Os físicos adoram a ideia de que a matemática que eles já conhecem pode explicar como o cérebro funciona. Muitos artigos foram publicados em revistas de física sobre Redes Hopfield e sua capacidade de armazenamento. Eventualmente, [Elizabeth Gardner](http://www.baginsky.de/eli/eg_portr.html) descobriu que havia uma regra de armazenamento muito melhor que usa a capacidade total dos pesos. Em vez de tentar armazenar vetores de uma só vez, ela percorreu o conjunto de treinamento muitas vezes e usou o procedimento de convergência Perceptron para treinar cada unidade para ter o estado correto, dado os estados de todas as outras unidades nesse vetor. **Os estatísticos chamam essa técnica de “pseudo-probabilidade”**.


Existe outro papel computacional para as Redes Hopfield. Em vez de usar a rede para armazenar memórias, usamos para construir interpretações de entrada sensorial. A entrada é representada pelas unidades visíveis, a interpretação é representada pelos estados das unidades ocultas e o erro da interpretação é representado pela energia.


### 6- Máquinas de Boltzmann


Uma Máquina de Boltzmann é um tipo de rede neural recorrente estocástica. Pode ser visto como a contrapartida estocástica e generativa das Redes Hopfield. Foi uma das primeiras redes neurais capazes de aprender representações internas e é capaz de representar e resolver problemas combinatórios difíceis.


O objetivo do aprendizado do algoritmo da Máquina de Boltzmann é maximizar o produto das probabilidades que a Máquina de Boltzmann atribui aos vetores binários no conjunto de treinamento. Isso equivale a maximizar a soma das probabilidades de log que a Máquina de Boltzmann atribui aos vetores de treinamento. Também é equivalente a maximizar a probabilidade de obtermos exatamente os N casos de treinamento se fizéssemos o seguinte: 1) Deixar a rede se estabelecer em sua distribuição estacionária no tempo N diferente, sem entrada externa e 2) Mudar o vetor visível uma vez em cada passada.


Um procedimento eficiente de aprendizado de mini-lote foi proposto para as Máquinas de Boltzmann por [Salakhutdinov e Hinton em 2012](http://proceedings.mlr.press/v5/salakhutdinov09a/salakhutdinov09a.pdf).


![Boltzmann Machine Network](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/maquinas-1024x576.jpeg)


Em uma Máquina de Boltzmann geral, as atualizações estocásticas de unidades precisam ser sequenciais. Existe uma arquitetura especial que permite alternar atualizações paralelas que são muito mais eficientes (sem conexões dentro de uma camada, sem conexões de camada ignorada). Este procedimento de mini-lote torna as atualizações da Máquina de Boltzmann mais paralelas. Isso é chamado de Deep Boltzmann Machines (DBM), uma Máquina de Boltzmann geral, mas com muitas conexões ausentes.


Em 2014, Salakhutdinov e Hinton apresentaram outra atualização para seu modelo, chamando-o de Máquinas Boltzmann Restritas. Elas restringem a conectividade para facilitar a inferência e a aprendizagem (apenas uma camada de unidades escondidas e sem conexões entre unidades ocultas). Em um RBM, é preciso apenas um passo para alcançar o equilíbrio.


### 7- Deep Belief Network


O backpropagation é considerado o método padrão em redes neurais artificiais para calcular a contribuição de erro de cada neurônio após processar um lote de dados (teremos um capítulo inteiro sobre isso). No entanto, existem alguns problemas importantes no backpropagation. Em primeiro lugar, requer dados de treinamento rotulados; enquanto quase todos os dados estão sem rótulos. Em segundo lugar, o tempo de aprendizagem não escala bem, o que significa que é muito lento em redes com múltiplas camadas ocultas. Em terceiro lugar, pode ficar preso em um “local optima”. Portanto, para redes profundas, o backpropagation está longe de ser ótimo.


Para superar as limitações do backpropagation, os pesquisadores consideraram o uso de abordagens de aprendizado sem supervisão. Isso ajuda a manter a eficiência e a simplicidade de usar um método de gradiente para ajustar os pesos, mas também usá-lo para modelar a estrutura da entrada sensorial. Em particular, eles ajustam os pesos para maximizar a probabilidade de um modelo gerador ter gerado a entrada sensorial. A questão é que tipo de modelo generativo devemos aprender? Pode ser um modelo baseado em energia como uma Máquina de Boltzmann? Ou um modelo causal feito de neurônios? Ou um híbrido dos dois?


 


![Deep Belief Network](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/dbn-1024x528.png)


 


Uma Deep Belief Network pode ser definida como uma pilha de Máquinas de Boltzmann Restritas (RBM – Restricted Boltzmann Machines), em que cada camada RBM se comunica com as camadas anterior e posterior. Os nós de qualquer camada única não se comunicam lateralmente.


Esta pilha de RBMs pode terminar com uma camada Softmax para criar um classificador, ou simplesmente pode ajudar a agrupar dados não gravados em um cenário de aprendizado sem supervisão.


Com a exceção das camadas inicial e final, cada camada em uma Deep Belief Network tem uma função dupla: ela serve como a camada oculta para os nós que vem antes, e como a camada de entrada (ou “visível”) para a nós que vem depois. É uma rede construída de redes de camada única.


As Deep Belief Networks são usadas para reconhecer, agrupar e gerar imagens, sequências de vídeos e dados de captura de movimento. Outra aplicação das Deep Belief Networks é no [Processamento de Linguagem Natural](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers). Esse tipo de rede foi apresentado por Geoff Hinton e seus alunos em 2006.


### 8- Deep Auto-Encoders


Um Deep Auto-Encoder é composto por duas redes simétricas Deep Belief que tipicamente têm quatro ou cinco camadas rasas que representam a metade da codificação (encoder) da rede e o segundo conjunto de quatro ou cinco camadas que compõem a metade da decodificação (decoder).


As camadas são Máquinas de Boltzmann Restritas, os blocos de construção das Deep Belief Networks, com várias peculiaridades que discutiremos abaixo. Aqui está um esquema simplificado da estrutura de um Deep Auto-Encoder:


 


![Deep Auto-Encoder](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/deep_autoencoder.png)


 


Os Deep Auto-Encoders são uma maneira muito agradável de reduzir a dimensionalidade não linear devido a alguns motivos: eles fornecem mapeamentos flexíveis em ambos os sentidos. O tempo de aprendizagem é linear (ou melhor) no número de casos de treinamento. E o modelo de codificação final é bastante compacto e rápido. No entanto, pode ser muito difícil otimizar Deep Auto-Encoders usando backpropagation. Com pequenos pesos iniciais, o gradiente do backpropagation morre. Mas temos maneiras de otimizá-las, usando o pré-treinamento camada-por-camada sem supervisão ou apenas inicializando os pesos com cuidado.


Os Deep Auto-Encoders são úteis na modelagem de tópicos ou modelagem estatística de tópicos abstratos que são distribuídos em uma coleção de documentos. Isso, por sua vez, é um passo importante em sistemas de perguntas e respostas como o IBM Watson.


Em resumo, cada documento em uma coleção é convertido em um Bag-of-Words (ou seja, um conjunto de contagens de palavras) e essas contagens de palavras são dimensionadas para decimais entre 0 e 1, o que pode ser pensado como a probabilidade de uma palavra ocorrer no documento.


As contagens de palavras em escala são então alimentadas em uma Deep Belief Network, uma pilha de Máquinas de Boltzmann Restritas, que elas mesmas são apenas um subconjunto de Autoencoders. Essas Deep Belief Networks, ou DBNs, comprimem cada documento para um conjunto de 10 números através de uma série de transformações sigmóides que o mapeiam no espaço de recursos.


O conjunto de números de cada documento, ou vetor, é então introduzido no mesmo espaço vetorial, e sua distância de qualquer outro vetor de documento medido. Em termos aproximados, os vetores de documentos próximos se enquadram no mesmo tópico. Por exemplo, um documento poderia ser a “pergunta” e outros poderiam ser as “respostas”, uma combinação que o software faria usando medidas de espaço vetorial.


Em resumo, existem agora muitas maneiras diferentes de fazer pré-treinamento camada-por-camada de recursos. Para conjuntos de dados que não possuem um grande número de casos rotulados, o pré-treinamento ajuda a aprendizagem discriminativa subsequente. Para conjuntos de dados muito grandes e rotulados, não é necessário inicializar os pesos utilizados na aprendizagem supervisionada usando pré-treinamento não supervisionado, mesmo para redes profundas. O pré-treinamento foi o primeiro bom caminho para inicializar os pesos para redes profundas, mas agora existem outras formas. Mas se construímos redes muito maiores, precisaremos de pré-treinamento novamente! Se quiser aprender a construir Deep Auto-Encoders em Python, clique [aqui](https://www.datascienceacademy.com.br/pages/curso-deep-learning-ii).


### 9- Generative Adversarial Network


As Generative Adversarial Networks (GANs) são arquiteturas de redes neurais profundas compostas por duas redes, colocando uma contra a outra (daí o nome, “adversária”).


Os GANs foram introduzidos em um artigo de Ian Goodfellow e outros pesquisadores da Universidade de Montreal no Canadá, incluindo Yoshua Bengio, em 2014. Referindo-se aos GANs, o diretor de pesquisa de IA do Facebook, Yann LeCun, chamou de treinamento adversário “a ideia mais interessante nos últimos 10 anos em Machine Learning”.


O potencial de GANs é enorme, porque eles podem aprender a imitar qualquer distribuição de dados. Ou seja, os GANs podem ser ensinados a criar mundos estranhamente semelhantes aos nossos em qualquer domínio: imagens, música, fala, prosa. Eles são artistas robôs em um sentido, e sua produção é impressionante – até mesmo pungente.


Para entender os GANs, você deve saber como os algoritmos geradores funcionam, e para isso, contrastá-los com algoritmos discriminatórios é útil. Os algoritmos discriminatórios tentam classificar dados de entrada; isto é, dados os recursos de uma instância de dados, eles predizem um rótulo ou categoria a que esses dados pertencem.


Por exemplo, tendo em conta todas as palavras em um e-mail, um algoritmo discriminatório pode prever se a mensagem é spam ou not\_spam. O spam é um dos rótulos, e o saco de palavras (Bag of Words) coletadas do e-mail são os recursos que constituem os dados de entrada. Quando este problema é expresso matematicamente, o rótulo é chamado y e os recursos são chamados de x. A formulação p (y | x) é usada para significar “a probabilidade de y dado x”, que neste caso seria traduzido para “a probabilidade de um email ser spam com as palavras que contém”.


Portanto, algoritmos discriminatórios mapeiam recursos para rótulos. Eles estão preocupados apenas com essa correlação. Uma maneira de pensar sobre algoritmos generativos é que eles fazem o contrário. Em vez de prever um rótulo com determinados recursos, eles tentam prever os recursos com um determinado rótulo.


A questão que um algoritmo gerador tenta responder é: assumir que este e-mail é spam, qual a probabilidade dos recursos? Enquanto os modelos discriminativos se preocupam com a relação entre y e x, os modelos generativos se preocupam com “como você obtém x”. Eles permitem que você capture p (x | y), a probabilidade de x dado y, ou a probabilidade de características oferecidas em uma classe . (Dito isto, os algoritmos geradores também podem ser usados ​​como classificadores, embora eles podem fazer mais do que categorizar dados de entrada.)


Outra maneira de pensar sobre isso é distinguir discriminativo de gerador assim:


* Modelos discriminativos aprendem o limite entre as classes
* Modelos generativos modelam a distribuição de classes individuais


 


![Generative Adversarial Network](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/GANs-1024x447.png)


 


Uma rede neural, chamada de gerador, gera novas instâncias de dados, enquanto a outra, o discriminador, as avalia por autenticidade; ou seja, o discriminador decide se cada instância de dados que revisa pertence ao conjunto de dados de treinamento real ou não.


Digamos que estamos tentando fazer algo mais banal do que imitar a Mona Lisa. Vamos gerar números escritos à mão como os encontrados no conjunto de dados [MNIST](http://yann.lecun.com/exdb/mnist/), que é retirado do mundo real. O objetivo do discriminador, quando mostrado uma instância do verdadeiro conjunto de dados MNIST, é reconhecê-los como autênticos.


Enquanto isso, o gerador está criando novas imagens que passa para o discriminador. Isso acontece com a esperança de que eles, também, sejam considerados autênticos, embora sejam falsos. O objetivo do gerador é gerar dígitos ​​escritos à mão por si mesmo. O objetivo do discriminador é identificar as imagens provenientes do gerador como falsas.


Aqui estão os passos que um GAN realiza:


* O gerador recebe números aleatórios e retorna uma imagem.
* Essa imagem gerada é alimentada no discriminador ao lado de um fluxo de imagens tiradas do conjunto de dados real.
* O discriminador assume imagens reais e falsas e retorna probabilidades, um número entre 0 e 1, com 1 representando uma previsão de autenticidade e 0 representando falsas.


Então você tem um loop de feedback duplo:


* O discriminador está em um loop de feedback com as imagens verdadeiras, que conhecemos.
* O gerador está em um loop de feedback com o discriminador.


Quer aprender como construir GANs, uma das arquiteturas mais incríveis de Deep Learning, 100% em português e 100% online, para gerar imagens de forma automática? Clique [aqui](https://www.datascienceacademy.com.br/course/deep-learning-para-aplicacoes-de-ia-com-pytorch-e-lightning).


### 10- Deep Neural Network Capsules


No final de 2017, Geoffrey Hinton e sua equipe publicaram dois artigos que introduziram um novo tipo de rede neural chamada ***Capsules***. Além disso, a equipe publicou um algoritmo, denominado roteamento dinâmico entre cápsulas, que permite treinar essa rede.


Para todos na comunidade de Deep Learning, esta é uma grande notícia, e por várias razões. Em primeiro lugar, Hinton é um dos fundadores do Deep Learning e um inventor de inúmeros modelos e algoritmos que hoje são amplamente utilizados. Em segundo lugar, esses artigos apresentam algo completamente novo, e isso é muito emocionante porque provavelmente estimulará a onda adicional de pesquisas e aplicativos muito inovadores.


 


![Capsule](https://www.deeplearningbook.com.br/wp-content/uploads/2018/02/capsule.png)


 


As ***Capsules*** introduzem um novo bloco de construção que pode ser usado na aprendizagem profunda para modelar melhor as relações hierárquicas dentro da representação do conhecimento interno de uma rede neural. A intuição por trás deles é muito simples e elegante.


Hinton e sua equipe propuseram uma maneira de treinar essa rede composta de cápsulas e treinou-a com êxito em um conjunto de dados simples, alcançando desempenho de ponta. Isso é muito encorajador. No entanto, há desafios. As implementações atuais são muito mais lentas do que outros modelos modernos de aprendizado profundo. O tempo mostrará se as redes ***Capsules*** podem ser treinadas de forma rápida e eficiente. Além disso, precisamos ver se elas funcionam bem em conjuntos de dados mais difíceis e em diferentes domínios.


Em qualquer caso, a rede ***Capsule*** é um modelo muito interessante e já funcionando, que definitivamente se desenvolverá ao longo do tempo e contribuirá para uma maior expansão de aplicações de aprendizagem profunda.


Incluímos as Capsules entre as 10 principais arquiteturas de redes neurais, pois elas representam a inovação e o avanço na incrível e vibrante área de Deep Learning e sistemas de Inteligência Artificial. Profissionais que realmente desejem abraçar IA como carreira, devem estar atentos aos movimentos e inovações na área.


 


Esta não é uma lista definitiva de arquiteturas e existem outras, tais como Word2Vec, Doc2vec, Neural Embeddings e variações das arquiteturas aqui apresentadas, como Denoising Autoencoders, Variational Autoencoders, além de outras categorias como Deep Reinforcement Learning. Exatamente para auxiliar aqueles que buscam conhecimento de ponta 100% em português e 100% online, que nós criamos a [Formação Engenheiro de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia), o único programa do Brasil completo, com todas as ferramentas que o aluno precisa para aprender a trabalhar com IA de forma eficiente. O aluno aprende programação paralela em GPU, Deep Learning e seus frameworks, estuda as principais arquiteturas com aplicações práticas e desenvolve aplicações de Visão Computacional e Processamento de Linguagem Natural. Clique [aqui](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia) e veja mais detalhes sobre o programa.


Isso conclui a primeira parte deste livro, com uma introdução ao universo do Deep Learning. No próximo capítulo começaremos a ver as redes neurais em ação. Até lá.


Referências:


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Multilayer Perceptrons](https://deeplearning4j.org/multilayerperceptron.html)


[Long Short-Term Memory](http://people.idsia.ch/~juergen/rnn.html)


[Long Short-Term Memory Neural Computation](http://www.bioinf.jku.at/publications/older/2604.pdf)


[The Unreasonable Effectiveness of Recurrent Neural Networks](https://karpathy.github.io/2015/05/21/rnn-effectiveness/)


[Perceptrons, Expanded Edition](https://mitpress.mit.edu/books/perceptrons)


[The 8 Neural Network Architectures Machine Learning Researchers Need to Learn](https://medium.com/@james_aka_yale/the-8-neural-network-architectures-machine-learning-researchers-need-to-learn-2f5c4e61aeeb)


[Dynamic Routing Between Capsules](https://arxiv.org/abs/1710.09829v1)


[Neural networks and physical systems with emergent collective computational abilities](http://www.pnas.org/content/pnas/79/8/2554.full.pdf)


[Deep Boltzmann Machines](http://proceedings.mlr.press/v5/salakhutdinov09a/salakhutdinov09a.pdf)


[Application of Deep Belief Networks for Natural Language Understanding](https://www.cs.toronto.edu/~hinton/absps/ruhijournal.pdf)


[A fast learning algorithm for deep belief nets](http://www.cs.toronto.edu/~hinton/absps/fastnc.pdf)


[A Beginner’s Guide to Deep Autoencoders](https://deeplearning4j.org/deepautoencoder)


[Matrix Capsules With RM Routing](https://openreview.net/pdf?id=HJWLfGWRb)


[Generative Adversarial Networks (GANs)](http://www.iangoodfellow.com/slides/2016-12-04-NIPS.pdf)


<div id="capitulo-11---design-de-uma-rede-neural-para-reconhecimento-de-digitos"></div>

# Capítulo 11 – Design De Uma Rede Neural Para Reconhecimento de Dígitos


Na primeira parte deste livro online, durante os 10 primeiros capítulos, definimos e estudamos o universo das redes neurais artificias. Neste ponto você já deve ter uma boa compreensão sobre que são estes algoritmos e como podem ser usados, além da importância das redes neurais para a construção de sistemas de Inteligência Artificial. Estamos prontos para iniciar a construção de redes neurais e na sequência estudaremos as arquiteturas mais avançadas. Vamos começar definindo o Design De Uma Rede Neural Para Reconhecimento de Dígitos.


Nossa primeira tarefa será construir uma rede neural para reconhecer caligrafia, ou seja, dígitos escritos à mão que foram digitalizados em imagens no computador. Por que vamos começar com este tipo de tarefa? Porque ela permite percorrer todas as etapas e procedimentos matemáticos de uma rede neural, sendo portanto uma excelente introdução. Vamos começar?


Se você acompanha os cursos na [Data Science Academy](https://www.datascienceacademy.com.br) já sabe que: antes de pensar em escrever sua primeira linha de código, é preciso definir claramente o problema a ser resolvido. A tecnologia existe para resolver problemas e a definição clara do objetivo é o ponto de partida de qualquer projeto de sucesso! Neste capítulo definiremos o problema a ser resolvido, nesse caso o reconhecimento de dígitos manuscritos.


Podemos dividir o problema de reconhecer os dígitos manuscritos em dois sub-problemas. Primeiro, precisamos encontrar uma maneira de quebrar uma imagem que contenha muitos dígitos em uma sequência de imagens separadas, cada uma contendo um único dígito. Por exemplo, gostaríamos de quebrar a imagem:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/digits-300x62.png)


 


em seis imagens separadas:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/digits_separate-300x47.png)


 


Nós, humanos, resolvemos esse problema de segmentação com facilidade, mas é um desafio para um programa de computador dividir corretamente a imagem. Uma vez que a imagem foi segmentada, o programa precisa classificar cada dígito individual. Então, por exemplo, gostaríamos que nosso programa reconhecesse automaticamente que o primeiro dígito acima é um 5:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/mnist_first_digit.png)


 


Vamos nos concentrar em escrever um programa para resolver o segundo problema, isto é, classificar dígitos individuais. O problema da segmentação não é tão difícil de resolver, uma vez que você tenha uma boa maneira de classificar os dígitos individuais. Existem muitas abordagens para resolver o problema de segmentação. Uma abordagem é testar muitas maneiras diferentes de segmentar a imagem, usando o classificador de dígitos individuais para marcar cada segmentação de teste. Uma segmentação de teste obtém uma pontuação alta se o classificador de dígitos individuais estiver confiante de sua classificação em todos os segmentos e uma pontuação baixa se o classificador tiver muitos problemas em um ou mais segmentos. A ideia é que, se o classificador estiver tendo problemas em algum lugar, provavelmente está tendo problemas porque a segmentação foi escolhida incorretamente. Essa ideia e outras variações podem ser usadas para resolver o problema de segmentação. Então, em vez de se preocupar com a segmentação, nos concentraremos no desenvolvimento de uma rede neural que pode resolver o problema mais interessante e difícil, ou seja, reconhecer dígitos individuais manuscritos.


Para reconhecer dígitos individuais, usaremos uma rede neural de três camadas:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/tikz12.png)


 


A camada de entrada da rede contém neurônios que codificam os valores dos pixels de entrada. Conforme iremos discutir no próximo capítulo, nossos dados de treinamento para a rede consistirão em muitas imagens de 28 por 28 pixels de dígitos manuscritos digitalizados e, portanto, a camada de entrada contém 28 × 28 = 784 neurônios (Nota: uma imagem nada mais é do que uma matriz, nesse caso de dimensões 28×28, que iremos converter em um vetor cujo tamanho será 784, onde cada item representa um pixel na imagem). Os pixels de entrada são de escala de cinza, com um valor de 0.0 representando branco e um valor de 1.0 representando preto. Valores intermediários representam tonalidades gradualmente escurecidas de cinza.


A segunda camada da rede é uma camada oculta. Representaremos o número de neurônios nesta camada oculta por n, e vamos experimentar diferentes valores para n. O exemplo mostrado acima ilustra uma pequena camada oculta, contendo apenas n = 15 neurônios.


A camada de saída da rede contém 10 neurônios. Se o primeiro neurônio “disparar” (for ativado), ou seja, tiver uma saída ≈ 1, então isso indicará que a rede acha que o dígito é 0. Se o segundo neurônio “disparar” (for ativado), isso indicará que a rede pensa que o dígito é um 1. E assim por diante. Em resumo, vamos numerar os neurônios de saída de 0 a 9 e descobrimos qual neurônio possui o maior valor de ativação. Se esse neurônio é, digamos, neurônio número 6, então nossa rede adivinhará que o dígito de entrada era um 6. E assim por diante para os outros neurônios de saída.


Você pode se perguntar por que usamos 10 neurônios de saída. Afinal, o objetivo da rede é nos dizer qual dígito (0,1,2, …, 9) corresponde à imagem de entrada. Uma maneira aparentemente natural de fazer isso é usar apenas 4 neurônios de saída, tratando cada neurônio como assumindo um valor binário, dependendo se a saída do neurônio está mais próxima de 0 ou 1. Quatro neurônios são suficientes para codificar a resposta, desde que 2ˆ4 = 16 é mais do que os 10 valores possíveis para o dígito de entrada. Por que nossa rede deve usar 10 neurônios em vez disso? Isso não é ineficiente? A justificativa final é empírica: podemos experimentar ambos os projetos de rede, e verifica-se que, para este problema específico, a rede com 10 neurônios de saída aprende a reconhecer dígitos melhor do que a rede com 4 neurônios de saída. Mas isso ainda deixa a pergunta por que o uso de 10 neurônios de saída funciona melhor. Existe alguma heurística que nos diga com antecedência que devemos usar a codificação de 10 saídas em vez da codificação de 4 saídas?


Entender porque fazemos isso, ajuda a pensar sobre o que a rede neural está realmente fazendo. Considere primeiro o caso em que usamos 10 neurônios de saída. Vamos nos concentrar no primeiro neurônio de saída, aquele que está tentando decidir se o dígito é ou não 0. Ele faz isso pesando evidências da camada oculta dos neurônios. O que esses neurônios ocultos estão fazendo? Bem, vamos supor que o primeiro neurônio na camada oculta detecta ou não uma imagem como a seguinte:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/mnist_top_left_feature-150x150.png)


 


Isso pode ser feito pesando fortemente pixels de entrada que se sobrepõem à imagem e apenas ponderam ligeiramente as outras entradas. De forma semelhante, suponhamos que o segundo, terceiro e quarto neurônios na camada oculta detectem se as seguintes imagens estão ou não presentes:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/mnist_other_features-300x96.png)


 


Como você pode ter adivinhado, essas quatro imagens juntas compõem a imagem 0 que vimos na linha de dígitos mostrada anteriormente:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/mnist_complete_zero-300x300.png)


 


Então, se todos os quatro neurônios ocultos estão disparando, podemos concluir que o dígito é um 0. Claro, esse não é o único tipo de evidência que podemos usar para concluir que a imagem era um 0 – podemos legitimamente obter um 0 em muitas outras maneiras (por exemplo, através de traduções das imagens acima, ou pequenas distorções). Mas parece seguro dizer que, pelo menos neste caso, concluiríamos que a entrada era um 0.


Supondo que a rede neural funciona assim, podemos dar uma explicação plausível sobre porque é melhor ter 10 saídas da rede, em vez de 4. Se tivéssemos 4 saídas, o primeiro neurônio de saída tentaria decidir o que mais um bit significativo do dígito representa. E não existe uma maneira fácil de relacionar esse bit mais significativo com formas simples, como as mostradas acima. As formas componentes do dígito estarão intimamente relacionadas com (digamos) o bit mais significativo na saída.


Isso tudo é apenas uma heurística. Nada diz que a rede neural de três camadas tem que operar da maneira que descrevemos, com os neurônios ocultos detectando formas de componentes simples. Talvez um algoritmo de aprendizado inteligente encontre alguma atribuição de pesos que nos permita usar apenas 4 neurônios de saída. Mas, usar uma boa heurística pode economizar muito tempo na concepção de boas arquiteturas de redes neurais.


Já temos então um design para a nossa rede neural. Agora precisamos definir como será o processo de aprendizagem do algoritmo, antes de começar a codificar nossa rede em linguagem Python. Usaremos o treinamento com Gradiente Descendente, assunto do próximo capítulo, que aliás eu não perderia por nada, se fosse você, pois aí está a “magia” por trás das redes neurais. Até lá!


Para acompanhar os próximos capítulos e reproduzir os exemplos, você deve ter o Anaconda Python instalado no seu computador. Acesse o capítulo 1 do curso gratuito [Python Fundamentos Para Análise de Dados](https://www.datascienceacademy.com.br/cursosgratuitos), para aprender como instalar o Anaconda.


Referências:


[Função Sigmóide](https://pt.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_sigm%C3%B3ide)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/) (alguns trechos extraídos e traduzidos com autorização do autor [Michael Nielsen](http://michaelnielsen.org/))


<div id="capitulo-12---aprendizado-com-a-descida-do-gradiente"></div>

# Capítulo 12 – Aprendizado Com a Descida do Gradiente


No capítulo anterior definimos o design para a nossa rede neural e agora podemos começar o processo de aprendizado de máquina. Neste capítulo você vai compreender o que é o Aprendizado Com a Descida do Gradiente.


A primeira coisa que precisamos é um conjunto de dados para o treinamento da rede. Usaremos o conjunto de dados [MNIST](http://yann.lecun.com/exdb/mnist/), que contém dezenas de milhares de imagens digitalizadas de dígitos manuscritos, juntamente com suas classificações corretas. O nome MNIST vem do fato de que é um subconjunto modificado de dois conjuntos de dados coletados pelo NIST, o Instituto Nacional de Padrões e Tecnologia dos Estados Unidos. Aqui estão algumas imagens do MNIST:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/digits_separate-1-300x47.png)


 


O MNIST tem duas partes. A primeira parte contém 60.000 imagens para serem usadas como dados de treinamento. Essas imagens são amostras de manuscritos escaneados de 250 pessoas, metade dos quais funcionários do Bureau do Censo dos EUA e metade dos estudantes do ensino médio. As imagens estão em escala de cinza e 28 por 28 pixels de tamanho. A segunda parte do conjunto de dados MNIST tem 10.000 imagens a serem usadas como dados de teste, também 28 por 28 pixels em escala de cinza. Usaremos os dados do teste para avaliar o quão bem a nossa rede neural aprendeu a reconhecer os dígitos. Para fazer deste um bom teste de desempenho, os dados de teste foram retirados de um conjunto diferente de 250 pessoas em relação aos dados de treinamento originais (embora ainda seja um grupo dividido entre funcionários do Census Bureau e alunos do ensino médio). Isso nos ajuda a confiar que nosso sistema pode reconhecer dígitos de pessoas cuja escrita não viu durante o treinamento.


Usaremos a notação x para indicar uma entrada (input) de treinamento. Será conveniente considerar cada entrada de treinamento x (cada imagem) como um vetor de 784 posições (28 x 28 pixels). A imagem abaixo representa como este vetor é construído:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/pixels-300x277.png)


 


Cada entrada no vetor representa o valor de cinza para um único pixel na imagem. Vamos indicar a saída correspondente desejada por y = y(x), onde y é um vetor com dimensão 10. Por exemplo, se uma imagem de treinamento particular, x, representa um 3, então y(x) = (0,0,0,1,0,0,0,0,0,0)T é a saída desejada da rede . Observe que T aqui é a operação de transposição, transformando um vetor de linha em um vetor comum (coluna). Vamos deixar isso mais claro. Observe a figura abaixo:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/label.png)


 


Vamos usar os pixels de imagem correspondentes ao fluxo inteiro chamado “features”. Os rótulos são One-Hot Encoded 1-hot. O rótulo que representa a classe de saída da imagem com dígito 3 torna-se “0001000000” uma vez que temos 10 classes para os 10 dígitos possíveis, onde o primeiro índice corresponde ao dígito “0” e o último corresponde ao dígito “9”.


O que queremos é um algoritmo que nos permita encontrar pesos e bias para que a saída da rede se aproxime de y(x) para todas as entradas de treinamento x. Para quantificar o quão bem estamos alcançando esse objetivo, definimos uma função de custo:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/2018-03-14_1123-300x96.png)


Função Quadrático de Custo


 


Na fórmula acima, w indica a coleta de todos os pesos na rede, b todos os bias (viés), n é o número total de entradas de treinamento, a é o vetor de saídas da rede (quando x é entrada) e a soma é sobre todas as entradas de treinamento x. Claro, a saída a depende de x, w e b, mas para manter a notação simples, eu não indiquei explicitamente essa dependência. A notação ‖v‖ apenas indica a função de comprimento usual para um vetor v. Chamaremos C a função de custo quadrático, que também é conhecido como o erro quadrático médio ou apenas o MSE (Mean Squared Error). Inspecionando a forma da função de custo quadrático, vemos que C (w, b) não é negativo, pois cada termo na soma não é negativo. Além disso, o custo C (w, b) torna-se pequeno, isto é, C (w, b) ≈ 0, precisamente quando y(x) é aproximadamente igual à saída, a, para todas as entradas de treinamento x.


Portanto, nosso algoritmo de treinamento faz um bom trabalho se ele pode encontrar pesos e bias para que C (w, b) ≈ 0. Isso significa basicamente que nosso modelo fez as previsões corretas, ou seja, cada vez que apresentamos ao modelo uma imagem com dígito 3, ele é capaz de reconhecer que se trata do número 3.


Em contraste, o algoritmo não terá boa performance, quando C (w, b) for um valor maior que 0 – isso significaria que nosso algoritmo não está conseguindo fazer as previsões, ou seja, quando apresentado a imagem com o dígito 3, ele não é capaz de prever que se trata de um número 3. Isso ocorre, porque a diferença entre o valor real da saída e o valor previsto pelo modelo, é muito alta. Assim, o objetivo do nosso algoritmo de treinamento será minimizar o custo C(w, b) em função dos pesos e dos bias. Em outras palavras, queremos encontrar um conjunto de pesos e bias que tornem o custo o menor possível. Vamos fazer isso usando um algoritmo conhecido como Descida do Gradiente (Gradient Descent).


Mas antes, uma pergunta. Por que introduzir o custo quadrático? Afinal, não nos interessamos principalmente pelo número de imagens corretamente classificadas pela rede? Por que não tentar maximizar esse número diretamente, em vez de minimizar uma medida, como o custo quadrático? O problema com isso é que o número de imagens corretamente classificadas não é uma “smooth function” dos pesos e bias na rede. Geralmente, fazer pequenas mudanças nos pesos e bias não causará nenhuma alteração no número de imagens de treinamento classificadas corretamente. Isso torna difícil descobrir como mudar os pesos e os bias para melhorar o desempenho. Se, em vez disso, usamos uma “smooth cost function”, como o custo quadrático, revela-se fácil descobrir como fazer pequenas mudanças nos pesos e nos bias para obter uma melhoria no custo. É por isso que nos concentramos primeiro na minimização do custo quadrático e somente depois examinaremos a precisão da classificação.


Mesmo considerando que queremos usar uma “smooth cost function”, você ainda pode se perguntar por que escolhemos a função quadrática. Talvez se escolhêssemos uma função de custo diferente, obteríamos um conjunto totalmente diferente de pesos e bias? Esta é uma preocupação válida e, mais tarde, revisitaremos a função de custo e faremos algumas modificações. No entanto, a função de custo quadrático mostrada anteriormente funciona perfeitamente para entender os conceitos básicos de aprendizagem em redes neurais, então ficaremos com isso por enquanto.


Recapitulando, nosso objetivo na construção de uma rede neural é encontrar pesos e bias que minimizem a função de custo quadrático C (w, b).


### Descida do Gradiente


A maioria das tarefas em Machine Learning são na verdade problemas de otimização e um dos algoritmos mais usados para isso é o Algoritmo de Descida do Gradiente. Para um iniciante, o nome Algoritmo de Descida do Gradiente pode parecer intimidante, mas espero que depois de ler o que está logo abaixo, isso deixe de ser um mistério para você.


A Descida do Gradiente é uma ferramenta padrão para otimizar funções complexas iterativamente dentro de um programa de computador. Seu objetivo é: dada alguma função arbitrária, encontrar um mínimo. Para alguns pequenos subconjuntos de funções – aqueles que são convexos – há apenas um único *minumum* que também acontece de ser global. Para as funções mais realistas, pode haver muitos mínimos, então a maioria dos mínimos são locais. Certifique-se de que a otimização encontre o “melhor” *minimum* e não fique preso em mínimos sub-otimistas (um problema comum durante o treinamento do algoritmo).


Para compreender a intuição da Descida do Gradiente, vamos simplificar um pouco as coisas. Vamos imaginar que simplesmente recebemos uma função de muitas variáveis e queremos minimizar essa função. Vamos desenvolver a técnica chamada Descida do Gradiente que pode ser usada para resolver tais problemas de minimização. Então, voltaremos para a função específica que queremos minimizar para as redes neurais.


Ok, suponhamos que estamos tentando minimizar alguma função, C(v). Esta poderia ser qualquer função de valor real de muitas variáveis, onde v = v1, v2, …. Observe que eu substitui a notação w e b por v para enfatizar que esta poderia ser qualquer função – não estamos mais pensando especificamente no contexto das redes neurais apenas. Para minimizar C (v), vamos imaginar C como uma função de apenas duas variáveis, que chamaremos v1 e v2, conforme pode ser visto na figura abaixo:


![Descida do Gradiente](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/valley.png)


O que queremos é encontrar onde C atinge seu mínimo global. Fica claro, que para a função traçada no gráfico acima, podemos observar facilmente o gráfico e encontrar o mínimo. Mas uma função geral, C, pode ser uma função complicada de muitas variáveis, e geralmente não será possível apenas observar o gráfico para encontrar o mínimo.


Uma maneira de atacar o problema é usar Cálculo (especificamente Álgebra Linear) para tentar encontrar o mínimo de forma analítica. Podemos calcular [derivadas](https://pt.wikipedia.org/wiki/Derivada) e depois tentar usá-las para encontrar lugares onde C é um *extremum*. Isso pode funcionar quando C é uma função de apenas uma ou algumas variáveis. Mas vai se transformar em um pesadelo quando tivermos muitas outras variáveis. E para as redes neurais, muitas vezes queremos muito mais variáveis – as maiores redes neurais têm funções de custo que dependem de bilhões de pesos e bias de uma maneira extremamente complicada. Usando “apenas” Cálculo para minimizar isso, não funcionará e precisamos de algo mais! Precisamos de um algoritmo de otimização capaz de minimizar C (v).


Felizmente, há uma analogia que nos ajuda a compreender como encontrar a solução. Começamos por pensar em nossa função como uma espécie de vale e imaginamos uma bola rolando pela encosta do vale, conforme pode ser visto na figura abaixo. Nossa experiência diária nos diz que a bola acabará rolando para o fundo do vale. Talvez possamos usar essa ideia como forma de encontrar um mínimo para a função? Escolheríamos aleatoriamente um ponto de partida para uma bola (imaginária), e então simularíamos o movimento da bola enquanto ela rola até o fundo do vale. Poderíamos fazer essa simulação simplesmente por derivadas de computação da função C – essas derivadas nos diriam tudo o que precisamos saber sobre a “forma” local do vale, e, portanto, como nossa bola deve rolar.


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/ball-1024x555.png)


Representação da Descida do Gradiente (com o objetivo de minimizar a função de custo)


 


Ou seja, a Descida do Gradiente é um algoritmo de otimização usado para encontrar os valores de parâmetros (coeficientes ou se preferir w e b – weight e bias) de uma função que minimizam uma função de custo. A Descida do Gradiente é melhor usada quando os parâmetros não podem ser calculados analiticamente (por exemplo, usando álgebra linear) e devem ser pesquisados por um algoritmo de otimização.


O procedimento começa com valores iniciais para o coeficiente ou coeficientes da função. Estes poderiam ser 0.0 ou um pequeno valor aleatório (a inicialização dos coeficiente é parte crítica do processo e diversas técnicas podem ser usadas, ficando a escolha a cargo do [Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) e do problema a ser resolvido com o modelo). Poderíamos iniciar assim nossos coeficientes (valores de w e b):


 


**coeficiente = 0,0**


 


O custo dos coeficientes é avaliado ligando-os à função e calculando o custo.


 


**custo = f (coeficiente)**


 


ou


 


**custo = avaliar (f (coeficiente))**


 


A derivada do custo é calculada. A derivada é um conceito de Cálculo e refere-se à inclinação da função em um determinado ponto. Precisamos conhecer a inclinação para que possamos conhecer a direção (sinal) para mover os valores dos coeficientes para obter um custo menor na próxima iteração.


 


**delta = derivado (custo)**


 


Agora que sabemos da derivada em que direção está em declive, podemos atualizar os valores dos coeficientes. Um parâmetro de taxa de aprendizagem (alfa) deve ser especificado e controla o quanto os coeficientes podem mudar em cada atualização.


 


**coeficiente = coeficiente – (alfa \* delta)**


 


Este processo é repetido até que o **custo dos coeficientes** (**função de custo**) seja 0,0 ou próximo o suficiente de zero, indicando que as saídas da rede estão cada vez mais próximas dos valores reais (saídas desejadas).


A Descida do Gradiente é simples, mas exige que seja calculado o gradiente da função de custo ou a função que você está otimizando, mas além disso, é muito direto. Em resumo:


Você divide seus dados em amostras e a cada amostra (sample), você passa as entradas pela rede, multiplica pelos pesos, soma, e no final você vai ter sua saÍda (a previsão da rede). Você então compara a saída da sua rede com o a resposta certa, calcula o erro, e então retroage esse erro (backpropagation), ajustando os pesos de cada neurônio de cada camada. Quando você acabar de fazer a atualização dos pesos, uma nova amostra é introduzida e ela será multiplicada pelos pesos já atualizados. Esse processo de atualizar os pesos é que é chamado de “aprendizado”.


Se você observar os algoritmos mais atuais, todos trabalham dentro de um conceito relativamente novo chamado de mini-lotes (mini-batches). Para otimizar a performance, o que se faz é passar pela rede múltiplas amostras (por exemplo 128 amostras), calcular o erro médio delas e então realizar o backpropagation e a atualização dos pesos. Do ponto de vista da atualização dos pesos, 1 amostra = 128 amostras. Esse é um conceito mais novo, necessário principalmente no treinamento de grandes modelos de Deep Learning.


Em seguida, veremos como podemos usar isso em algoritmos de aprendizado de máquina.


### Batch Gradient Descent em Aprendizado de Máquina


O objetivo de todos os algoritmos supervisionados de aprendizagem de máquina é estimar uma função de destino (f) que mapeia dados de entrada (X) para as variáveis ​​de saída (Y). Isso descreve todos os problemas de classificação e regressão (aprendizagem supervisionada).


Alguns algoritmos de aprendizagem de máquina têm coeficientes que caracterizam a estimativa de algoritmos para a função alvo (f). Diferentes algoritmos têm diferentes representações e diferentes coeficientes, mas muitos deles requerem um processo de otimização para encontrar o conjunto de coeficientes que resultam na melhor estimativa da função alvo. Os exemplos comuns de algoritmos com coeficientes que podem ser otimizados usando descida do gradiente são Regressão linear e Regressão logística.


A avaliação de quão próximo um modelo de aprendizagem de máquina estima a função de destino pode ser calculada de várias maneiras, muitas vezes específicas para o algoritmo de aprendizagem de máquina. A função de custo envolve a avaliação dos coeficientes no modelo de aprendizagem de máquina calculando uma previsão para o modelo para cada instância de treinamento no conjunto de dados e comparando as previsões com os valores de saída reais e calculando uma soma ou erro médio (como a Soma de Residuais Quadrados ou SSR no caso de regressão linear).


A partir da função de custo, uma derivada pode ser calculada para cada coeficiente para que ele possa ser atualizado usando exatamente a equação de atualização descrita acima.


O custo é calculado para um algoritmo de aprendizado de máquina em todo o conjunto de dados de treinamento para cada iteração do algoritmo de descida de gradiente. Uma iteração do algoritmo é chamada de um lote e esta forma de descida do gradiente é referida como descida do gradiente em lote (Batch Gradient Descent).


A descida do gradiente em lote é a forma mais comum de descida do gradiente em Machine Learning.


### Stochastic Gradient Descent em Aprendizado de Máquina


A Descida do Gradiente pode ser lenta para executar em conjuntos de dados muito grandes. Como uma iteração do algoritmo de descida do gradiente requer uma previsão para cada instância no conjunto de dados de treinamento, pode demorar muito quando você tem muitos milhões de instâncias.


Em situações em que você possui grandes quantidades de dados, você pode usar uma variação da descida do gradiente chamada Stochastic Gradient Descent.


Nesta variação, o procedimento de descida do gradiente descrito acima é executado, mas a atualização para os coeficientes é realizada para cada instância de treinamento, em vez do final do lote de instâncias.


O primeiro passo do procedimento exige que a ordem do conjunto de dados de treinamento seja randomizada. Isto é, misturar a ordem que as atualizações são feitas para os coeficientes. Como os coeficientes são atualizados após cada instância de treinamento, as atualizações serão barulhentas saltando por todo o lado, e assim o custo correspondente funcionará. Ao misturar a ordem para as atualizações dos coeficientes, ela aproveita essa caminhada aleatória e evita que ela fique “distraída” ou presa.


O procedimento de atualização para os coeficientes é o mesmo que o anterior, exceto que o custo não é somado em todos os padrões de treinamento, mas sim calculado para um padrão de treinamento.


A aprendizagem pode ser muito mais rápida com descida de gradiente estocástica para conjuntos de dados de treinamento muito grandes e muitas vezes você só precisa de um pequeno número de passagens através do conjunto de dados para alcançar um conjunto de coeficientes bom o suficiente.


Ufa, você ainda está aí? Entende agora porque [Cientistas de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) e [Engenheiros de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia) devem ser muito bem remunerados? Eles são os “magos” que estão ajudando a transformar o mundo com Machine Learning. E este capítulo foi apenas uma breve introdução! Voltaremos a este assunto mais a frente no livro, quando estudarmos outros algoritmos.


Tenho certeza que você está ansioso para criar e treinar sua primeira rede neural. Então, não perca o próximo capítulo!


Referências:


[Machine Learning com R e Python](https://www.datascienceacademy.com.br/course/machine-learning-engineer)


[MNIST](http://yann.lecun.com/exdb/mnist/)


[Derivada](https://pt.wikipedia.org/wiki/Derivada)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[An overview of gradient descent optimization algorithms](http://ruder.io/optimizing-gradient-descent/)


[Optimization: Stochastic Gradient Descent](http://ufldl.stanford.edu/tutorial/supervised/OptimizationStochasticGradientDescent/)


[Gradient Descent vs Stochastic Gradient Descent vs Mini-Batch Learning](https://sebastianraschka.com/faq/docs/closed-form-vs-gd.html)


<div id="capitulo-13---construindo-uma-rede-neural-com-linguagem-python"></div>

# Capítulo 13 – Construindo Uma Rede Neural Com Linguagem Python


Ok. Chegou a hora. Vamos escrever um programa em linguagem Python que aprenda como reconhecer dígitos manuscritos, usando Stochastic Gradient Descent e o dataset de treinamento MNIST. Se você chegou até aqui sem ler os capítulos anteriores, então pare imediatamente, leia os últimos 12 capítulos e depois volte aqui! Não tenha pressa! Não existe atalho para o aprendizado!


 


\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\* Atenção \*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*


Este capítulo considera que você já tem o interpretador Python instalado no seu computador, seja ele com sistema operacional Windows, MacOS ou Linux. Recomendamos que você instale o [Anaconda](https://www.anaconda.com/download/#macos) e que já possua conhecimentos em linguagem Python. Se esse não for seu caso, antes de ler este capítulo e executar os exemplos aqui fornecidos, acesse o curso gratuito [Python Fundamentos Para Análise de Dados](https://www.datascienceacademy.com.br/cursosgratuitos).


**Usaremos Python 3 e os scripts podem ser encontrados [aqui](https://drive.google.com/file/d/1esmcuW-aluCZTwS-Yjh1x-uijX8DHK62/view). Vamos começar!**


\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*


 


Quando descrevemos o dataset MNIST anteriormente, dissemos que ele estava dividido em 60.000 imagens de treinamento e 10.000 imagens de teste. Essa é a descrição oficial do MNIST. Mas vamos dividir os dados de forma um pouco diferente. Deixaremos as imagens de teste como está, mas dividiremos o conjunto de treinamento MNIST de 60.000 imagens em duas partes: um conjunto de 50.000 imagens, que usaremos para treinar nossa rede neural e um conjunto separado de validação de 10.000 imagens. Não utilizaremos os dados de validação neste capítulo, porém mais tarde, aqui mesmo no livro, usaremos este dataset quando estivermos configurando certos hiperparâmetros da rede neural, como a taxa de aprendizado por exemplo. Embora os dados de validação não façam parte da especificação MNIST original, muitas pessoas usam o MNIST desta forma e o uso de dados de validação é comum em redes neurais. Quando eu me referir aos “dados de treinamento MNIST” de agora em diante, vou me referir ao nosso conjunto de dados de 50.000 imagens, e não ao conjunto de dados de 60.000 imagens. Fique atento!


Além dos dados MNIST, também precisamos de uma biblioteca Python chamada Numpy, para álgebra linear. Se você instalou o Anaconda, não precisa se preocupar, pois o Numpy já está instalado. Caso contrário, será necessário fazer a instalação do pacote.


Mas antes de carregar e dividir os dados, vamos compreender os principais recursos do nosso código para construção de uma rede neural. A peça central é uma classe chamada **Network**, que usamos para representar uma rede neural. Abaixo a classe Network e seu construtor:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/classe1-1-1024x201.png)


 


Neste código, o parâmetro **sizes** contêm o número de neurônios nas respectivas camadas, sendo um objeto do tipo lista em Python. Então, por exemplo, se queremos criar um objeto da classe Network com 2 neurônios na primeira camada, 3 neurônios na segunda camada e 1 neurônio na camada final, aqui está o código que usamos para instanciar um objeto da classe Network::


 


**rede1 = Network([2, 3, 1])**


 


Os bias e pesos no objeto rede1 são todos inicializados aleatoriamente, usando a função Numpy **np.random.randn** para gerar distribuições gaussianas com 0 de média e desvio padrão 1. Esta inicialização aleatória dá ao nosso algoritmo de descida do gradiente estocástico um local para começar. Em capítulos posteriores, encontraremos melhores maneiras de inicializar os pesos e os bias. Observe que o código de inicialização de rede assume que a primeira camada de neurônios é uma camada de entrada e omite a definição de quaisquer bias para esses neurônios, uma vez que os bias são usados apenas para calcular as saídas de camadas posteriores.


Observe também que os bias e pesos são armazenados como listas de matrizes Numpy. Assim, por exemplo, rede1.weights[1] é uma matriz Numpy armazenando os pesos conectando a segunda e terceira camadas de neurônios. (Não é a primeira e segunda camadas, uma vez que a indexação da lista em Python começa em 0.) Uma vez que rede1.weights[1] é bastante detalhado, vamos apenas indicar essa matriz w. É uma matriz tal que wjk é o peso para a conexão entre o neurônio kth na segunda camada e o neurônio jth na terceira camada. Essa ordenação dos índices j e k pode parecer estranha – certamente teria mais sentido trocar os índices j e k? A grande vantagem de usar essa ordenação é que isso significa que o vetor de ativações da terceira camada de neurônios é:


 


![Form](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/form-1.png)


Equação 1


 


Onde, **a** é o vetor de ativações da segunda camada de neurônios. Para obter um **a’** multiplicamos **a** pela matriz de peso **w**, e adicionamos o vetor **b** com os bias (se você leu os capítulos anteriores, isso não deve ser novidade agora). Em seguida, aplicamos a função **σ** de forma elementar a cada entrada no vetor **wa + b**. (Isto é chamado de vetorizar a função σ.)


Com tudo isso em mente, é fácil escrever código que computa a saída de uma instância de rede. Começamos definindo a função sigmoide:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/func.png)


 


Observe que quando a entrada z é um vetor ou uma matriz Numpy, Numpy aplica automaticamente a função sigmoid elementwise, ou seja, na forma vetorizada.


Em seguida, adicionamos um método feedforward à classe Network, que, dada a entrada a para a rede, retorna a saída corresponente. Basicamente o método feedforward aplica a Equação 1 mostrada acima, para cada camada:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/func2-1024x320.png)


 


A principal atividade que queremos que nossos objetos da classe Network façam é aprender. Para esse fim, criaremos um método SGD (Stochastic Gradient Descent). Aqui está o código. É um pouco misterioso em alguns lugares, mas vamos explicar em detalhes mais abaixo:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/func2-1-1024x682.png)


 


O **training\_data** é uma lista de tuplas (x, y) que representam as entradas de treinamento e as correspondentes saídas desejadas. As variáveis **epochs** e **mini\_batch\_size** são o que você esperaria – o número de épocas para treinar e o tamanho dos mini-lotes a serem usados durante a amostragem, enquanto **eta** é a taxa de aprendizagem, η. Se o argumento opcional test\_data for fornecido, o programa avaliará a rede após cada período de treinamento e imprimirá progresso parcial. Isso é útil para rastrear o progresso, mas retarda substancialmente as coisas.


O código funciona da seguinte forma. Em cada época, ele começa arrastando aleatoriamente os dados de treinamento e, em seguida, particiona-os em mini-lotes de tamanho apropriado. Esta é uma maneira fácil de amostragem aleatória dos dados de treinamento. Então, para cada mini\_batch, aplicamos um único passo de descida do gradiente. Isso é feito pelo código self.update\_mini\_batch (mini\_batch, eta), que atualiza os pesos e os bias da rede de acordo com uma única iteração de descida de gradiente, usando apenas os dados de treinamento em mini\_batch. Aqui está o código para o método update\_mini\_batch:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/classe4-1024x976.png)


 


A maior parte do trabalho é feita pela linha delta\_nabla\_b, delta\_nabla\_w = self.backprop (x, y). Isso invoca algo chamado algoritmo de backpropagation, que é uma maneira rápida de calcular o gradiente da função de custo. Portanto, update\_mini\_batch funciona simplesmente calculando esses gradientes para cada exemplo de treinamento no mini\_batch e, em seguida, atualizando self.weights e self.biases adequadamente.


Abaixo você encontra o código para self.backprop, mas não estudaremos ele agora. Estudaremos em detalhes como funciona o backpropagation no próximo capítulo, incluindo o código para self.backprop. Por hora, basta assumir que ele se comporta conforme indicado, retornando o gradiente apropriado para o custo associado ao exemplo de treinamento x.


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/03/back-1024x852.png)


 


No programa completo disponível no [Github](https://github.com/dsacademybr/DeepLearningBook) você encontra comentários explicando como ocorre todo o processo. Além do self.backprop, o programa é auto-explicativo – todo o levantamento pesado é feito em self.SGD e self.update\_mini\_batch, que já discutimos. O método self.backprop faz uso de algumas funções extras para ajudar no cálculo do gradiente, nomeadamente sigmoid\_prime, que calcula a derivada da função σ e self.cost\_derivative.


A classe Network é em essência nosso algoritmo de rede neural. A partir dela criamos uma instância (como rede1), alimentamos com os dados de treinamento e realizamos o treinamento. Avaliamos então a performance da rede com dados de teste e repetimos todo o processo até alcançar o nível de acurácia desejado em nosso projeto. Quando o modelo final estiver pronto, usamos para realizar as previsões para as quais o modelo foi criado, apresentando a ele novos conjuntos de dados e extraindo as previsões. Perceba que este é um algoritmo de rede neural bem simples, mas que permite compreender como funcionam as redes neurais e mais tarde, aqui mesmo no livro, as redes neurais profundas ou Deep Learning.


No próximo capítulo vamos continuar trabalhando com este algoritmo e compreender como funciona o Backpropagation. Na sequência, vamos carregar os dados, treinar e testar nossa rede neural e então usá-la para reconhecer dígitos manuscritos. Até lá.


Referências:


[MNIST](http://yann.lecun.com/exdb/mnist/)


[Derivada](https://pt.wikipedia.org/wiki/Derivada)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[An overview of gradient descent optimization algorithms](http://ruder.io/optimizing-gradient-descent/)


[Optimization: Stochastic Gradient Descent](http://ufldl.stanford.edu/tutorial/supervised/OptimizationStochasticGradientDescent/)


[Gradient Descent vs Stochastic Gradient Descent vs Mini-Batch Learning](https://sebastianraschka.com/faq/docs/closed-form-vs-gd.html)


<div id="capitulo-14---algoritmo-backpropagation-parte-1---grafos-computacionais-e-chain-rule"></div>

# Capítulo 14 – Algoritmo Backpropagation Parte 1 – Grafos Computacionais e Chain Rule


No último capítulo, vimos como as redes neurais podem aprender seus pesos e bias usando o algoritmo de gradiente descendente. Houve, no entanto, uma lacuna na nossa explicação: não discutimos como calcular o gradiente da função de custo. Neste capítulo, explicaremos sobre um algoritmo usado para calcular esses gradientes, um algoritmo conhecido como backpropagation. Como esse tema é a essência do treinamento de redes neurais, vamos dividí-lo em dois capítulos. Vamos começar com Algoritmo Backpropagation Parte 1 – Grafos Computacionais e Chain Rule.


O backpropagation é indiscutivelmente o algoritmo mais importante na história das redes neurais – sem backpropagation, seria quase impossível treinar redes de aprendizagem profunda da forma que vemos hoje. O backpropagation pode ser considerado a pedra angular das redes neurais modernas e consequentemente do Deep Learning.


O algoritmo backpropagation foi originalmente introduzido na década de 1970, mas sua importância não foi totalmente apreciada até um famoso [artigo de 1986 de David Rumelhart, Geoffrey Hinton e Ronald Williams](https://www.nature.com/articles/323533a0). Esse artigo descreve várias redes neurais em que o backpropagation funciona muito mais rapidamente do que as abordagens anteriores de aprendizado, possibilitando o uso de redes neurais para resolver problemas que antes eram insolúveis.


O backpropagation é o algoritmo-chave que faz o treinamento de modelos profundos algo computacionalmente tratável. Para as redes neurais modernas, ele pode tornar o treinamento com gradiente descendente até dez milhões de vezes mais rápido, em relação a uma implementação ingênua. Essa é a diferença entre um modelo que leva algumas horas ou dias para treinar e e outro que poderia levar anos (sem exagero).


Além de seu uso em Deep Learning, o backpropagation é uma poderosa ferramenta computacional em muitas outras áreas, desde previsão do tempo até a análise da estabilidade numérica. De fato, o algoritmo foi reinventado pelo menos dezenas de vezes em diferentes campos. O nome geral, independente da aplicação, é “diferenciação no modo reverso”.


Fundamentalmente, backpropagation é uma técnica para calcular derivadas rapidamente (não sabe o que é derivada? Consulte o link para um excelente vídeo em português explicando esse conceito em detalhes nas referências ao final deste capítulo). E é um truque essencial, não apenas em Deep Learning, mas em uma ampla variedade de situações de computação numérica. E para compreender backpropagation de forma efetiva, vamos primeiro compreender o conceito de grafo computacional e chain rule.


Grafo Computacional
-------------------


Grafos computacionais são uma boa maneira de pensar em expressões matemáticas. O conceito de grafo foi introduzido por [Leonhard Euler](https://www.encyclopedia.com/science/encyclopedias-almanacs-transcripts-and-maps/birth-graph-theory-leonhard-euler-and-konigsberg-bridge-problem) em 1736 para tentar resolver o problema das [Pontes de Konigsberg](https://pt.wikipedia.org/wiki/Sete_pontes_de_K%C3%B6nigsberg). Grafos são modelos matemáticos para resolver problemas práticos do dia a dia, com várias aplicações no mundo real tais como: circuitos elétricos, redes de distribuição, relações de parentesco entre pessoas, análise de redes sociais, logística, redes de estradas, redes de computadores e muito mais. Grafos são muito usados para modelar problemas em computação.


Um Grafo é um modelo matemático que representa relações entre objetos. Um grafo G = (V, E) consiste de um conjunto de vértices **V** (também chamados de nós), ligados por um conjunto de bordas ou arestas **E**. Para aprender sobre grafos em mais detalhes, clique [aqui](https://www.datascienceacademy.com.br/pages/curso-analise-em-grafos-para-big-data).


Por exemplo, considere a expressão:


 


**e = (a + b) ∗ (b + 1)**


 


Existem três operações: duas adições e uma multiplicação. Para facilitar a compreensão sobre isso, vamos introduzir duas variáveis intermediárias c e d para que a saída de cada função tenha uma variável. Nós agora temos:


 


**c = a+b**  

 **d = b+1**  

 **e = c∗d**


 


Para criar um grafo computacional, fazemos cada uma dessas operações nos ***nós***, juntamente com as variáveis de entrada. Quando o valor de um nó é a entrada para outro nó, uma seta vai de um para outro e temos nesse caso um grafo direcionado.


 




![tree-def](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/tree-def-1024x592.png)


 


Esses tipos de grafos surgem o tempo todo em Ciência da Computação, especialmente ao falar sobre programas funcionais. Eles estão intimamente relacionados com as noções de grafos de dependência e grafos de chamadas. Eles também são a principal abstração por trás do popular framework de Deep Learning, o TensorFlow.


Podemos avaliar a expressão definindo as variáveis de entrada para determinados valores e computando os nós através do grafo. Por exemplo, vamos definir a = 2 e b = 1:


 


![tree-eval](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/tree-eval-1024x592.png)


 


A expressão, nesse exemplo, é avaliada como 6.


Derivadas em Grafos Computacionais
----------------------------------


Se alguém quiser entender derivadas em um grafo computacional, a chave é entender as derivadas nas bordas (arestas que conectam os nós no grafo). Se **a** afeta diretamente **c**, então queremos saber como isso afeta **c**. Se **a** muda um pouco, como **c** muda? Chamamos isso de derivada parcial de **c** em relação a **a**.


Para avaliar as derivadas parciais neste grafo, precisamos da regra da soma e da regra do produto:


 


![derivada](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/derivada.png)


 


Abaixo, o grafo tem a derivada em cada borda (aresta) rotulada.


 


 ![tree-eval-derivs](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/tree-eval-derivs-1024x578.png)


 


 


E se quisermos entender como os nós que não estão diretamente conectados afetam uns aos outros? Vamos considerar como **e** é afetado por **a**. Se mudarmos **a** uma velocidade de 1, **c** também muda a uma velocidade de 1. Por sua vez, **c** mudando a uma velocidade de 1 faz com que **e** mude a uma velocidade de 2. Então **e** muda a uma taxa de 1 ∗ 2 em relação a **a** (analise o diagrama acima para visualizar isso).


A regra geral é somar todos os caminhos possíveis de um nó para o outro, multiplicando as derivadas em cada aresta do caminho. Por exemplo, para obter a derivada de **e** em relação a **b**, obtemos:


![form](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/form.png)


Isso explica como **b** afeta **e** através de **c** e também como isso afeta **d**.


Essa regra geral de “soma sobre caminhos” é apenas uma maneira diferente de pensar sobre a regra da cadeia multivariada ou **chain rule**.


Fatorando os Caminhos
---------------------


O problema com apenas “somar os caminhos” é que é muito fácil obter uma explosão combinatória no número de caminhos possíveis.


 


![chain-def-greek](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/chain-def-greek-300x73.png)


 


No diagrama acima, existem três caminhos de X a Y, e mais três caminhos de Y a Z. Se quisermos obter a derivada ∂Z/∂X somando todos os caminhos, precisamos calcular 3 ∗ 3 = 9 caminhos:


 


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/form2.png)


 


O exemplo acima só tem nove caminhos, mas seria fácil o número de caminhos crescer exponencialmente à medida que o grafo se torna mais complicado. Em vez de apenas ingenuamente somar os caminhos, seria muito melhor fatorá-los:


 


![form3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/form3.png)


 


É aí que entram a “diferenciação de modo de avanço” (forward-mode differentiation ou forward pass) e a “diferenciação de modo reverso” (reverse-mode differentiation ou backpropagation). Eles são algoritmos para calcular a soma de forma eficiente fatorando os caminhos. Em vez de somar todos os caminhos explicitamente, eles calculam a mesma soma de forma mais eficiente, mesclando os caminhos juntos novamente em cada nó. De fato, os dois algoritmos tocam cada borda exatamente uma vez!


A diferenciação do modo de avanço inicia em uma entrada para o grafo e se move em direção ao final. Em cada nó, soma todos os caminhos que se alimentam. Cada um desses caminhos representa uma maneira na qual a entrada afeta esse nó. Ao adicioná-los, obtemos a maneira total em que o nó é afetado pela entrada, isso é a derivada.


 


![chain-forward-greek](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/chain-forward-greek-1024x345.png)


 


Embora você provavelmente não tenha pensado nisso em termos de grafos, a diferenciação no modo de avanço é muito parecida com o que você aprendeu implicitamente caso tenha feito alguma introdução a Cálculo.


A diferenciação no modo reverso, por outro lado, começa na saída do grafo e se move em direção ao início (ou seja, se retropropaga ou backpropagation). Em cada nó, ele mescla todos os caminhos originados nesse nó.


 


![chain-backward-greek](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/chain-backward-greek-1024x356.png)


 


A diferenciação do modo de avanço rastreia como uma entrada afeta todos os nós. A diferenciação no modo reverso rastreia como cada nó afeta uma saída. Ou seja, a diferenciação de modo de avanço aplica o operador ∂/∂X a cada nó, enquanto a diferenciação de modo reverso aplica o operador ∂Z/∂ a cada nó. Se isso parece o conceito de programação dinâmica, é porque é exatamente isso! (acesse um material sobre programação dinâmica nas referências ao final do capítulo)


Nesse ponto, você pode se perguntar porque alguém se importaria com a diferenciação no modo reverso. Parece uma maneira estranha de fazer a mesma coisa que o modo de avanço. Existe alguma vantagem? Vamos considerar nosso exemplo original novamente:


 


![tree-eval-derivs](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/tree-eval-derivs-1024x578.png)


 


Podemos usar a diferenciação de modo de avanço de **b** para cima. Isso nos dá a derivada de cada nó em relação a **b**.


 


![tree-forwradmode](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/tree-forwradmode-1024x583.png)


 


Nós calculamos ∂e/∂b, a derivada de nossa saída em relação a um de nossos inputs. E se fizermos a diferenciação de modo reverso de **e** para baixo? Isso nos dá a derivada de **e** em relação a todos os nós:


![tree-backprop](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/tree-backprop-1024x606.png)


 


Quando digo que a diferenciação no modo reverso nos dá a derivada de **e** em relação a cada nó, eu realmente quero dizer cada nó. Temos tanto ∂e/∂a quanto ∂e/∂b, as derivadas de **e** em relação a ambas as entradas. A diferenciação no modo de avanço nos deu a derivada de nossa saída em relação a uma única entrada, mas a diferenciação no modo reverso nos dá todos eles.


Para este grafo, isso é apenas um fator de duas velocidades, mas imagine uma função com um milhão de entradas e uma saída. A diferenciação no modo de avanço exigiria que passássemos pelo grafo um milhão de vezes para obter as derivadas. Diferenciação no modo reverso pode fazer isso em uma só passada! Uma aceleração de um fator de um milhão é bem legal e explica porque conseguimos treinar um modelo de rede neural profunda em tempo razoável.


Ao treinar redes neurais, pensamos no custo (um valor que descreve o quanto uma rede neural é ruim) em função dos parâmetros (números que descrevem como a rede se comporta). Queremos calcular as derivadas do custo em relação a todos os parâmetros, para uso em descida do gradiente. Entretanto, muitas vezes, há milhões ou até dezenas de milhões de parâmetros em uma rede neural. Então, a diferenciação no modo reverso, chamada de backpropagation no contexto das redes neurais, nos dá uma velocidade enorme!


Existem casos em que a diferenciação de modo de avanço faz mais sentido? Sim, existem! Onde o modo reverso fornece as derivadas de uma saída em relação a todas as entradas, o modo de avanço nos dá as derivadas de todas as saídas em relação a uma entrada. Se tiver uma função com muitas saídas, a diferenciação no modo de avanço pode ser muito, muito mais rápida.


Agora faz sentido?
------------------


Quando aprendemos pela primeira vez o que é backpropagation, a reação é: “Oh, essa é apenas a regra da cadeia (chain rule)! Como demoramos tanto tempo para descobrir?”


Na época em que o backpropagation foi inventado, as pessoas não estavam muito focadas nas redes neurais feedforward. Também não era óbvio que as derivadas eram o caminho certo para treiná-las. Esses são apenas óbvios quando você percebe que pode calcular rapidamente derivadas. Houve uma dependência circular.


Treinar redes neurais com derivadas? Certamente você ficaria preso em mínimos locais. E obviamente seria caro computar todas essas derivadas. O fato é que só porque sabemos que essa abordagem funciona é que não começamos imediatamente a listar os motivos que provavelmente não funcionaria. Já sabemos que funciona, mas novas abordagens vem sendo propostas no avanço das pesquisas em Deep Learning e Inteligência Artificial.


Conclusão da Parte 1
--------------------


O backpropagation também é útil para entender como as derivadas fluem através de um modelo. Isso pode ser extremamente útil no raciocínio sobre porque alguns modelos são difíceis de otimizar. O exemplo clássico disso é o problema do desaparecimento de gradientes em redes neurais recorrentes, que discutiremos mais diante neste livro.


Por fim, há uma lição algorítmica ampla a ser retirada dessas técnicas. Backpropagation e forward-mode differentiation usam um poderoso par de truques (linearização e programação dinâmica) para computar derivadas de forma mais eficiente do que se poderia imaginar. Se você realmente entende essas técnicas, pode usá-las para calcular com eficiência várias outras expressões interessantes envolvendo derivadas.


Mas este capítulo teve como objetivo apenas ajudá-lo a compreender o algoritmo, já que praticamente não existe documentação sobre isso em português. Falta ainda compreender como o backpropagation é aplicado no treinamento das redes neurais. Ansioso por isso? Então acompanhe o próximo capítulo!


Referências:


[Me Salva! Cálculo – O que é uma derivada?](https://www.youtube.com/watch?v=CQxb5ZXeY3E)


[The Birth Of Graph Theory: Leonhard Euler And The Königsberg Bridge Problem](https://www.encyclopedia.com/science/encyclopedias-almanacs-transcripts-and-maps/birth-graph-theory-leonhard-euler-and-konigsberg-bridge-problem)


[Learning representations by back-propagating errors](https://www.nature.com/articles/323533a0)


[Chain Rule](https://en.wikipedia.org/wiki/Chain_rule)


[Calculus on Computational Graphs: Backpropagation](http://colah.github.io/posts/2015-08-Backprop/)


[How the backpropagation algorithm works](http://neuralnetworksanddeeplearning.com/chap2.html)


[Dynamic programming](https://en.wikipedia.org/wiki/Dynamic_programming)


Nota: parte das imagens usadas neste capítulo foram extraídas no excelente post (citado nas referências acima) de [Christopher Olah](http://colah.github.io/about.html), pesquisador de Machine Learning do Google Brain, e com a devida autorização do autor.


<div id="capitulo-15---algoritmo-backpropagation-parte-2---treinamento-de-redes-neurais"></div>

# Capítulo 15 – Algoritmo Backpropagation Parte 2 – Treinamento de Redes Neurais


O backpropagation é indiscutivelmente o algoritmo mais importante na história das redes neurais – sem backpropagation (eficiente), seria impossível treinar redes de aprendizagem profunda da forma que vemos hoje. O backpropagation pode ser considerado a pedra angular das redes neurais modernas e aprendizagem profunda. Neste capítulo, vamos compreender como o backpropagation é usado no treinamento das redes neurais: Algoritmo Backpropagation Parte 2 – Treinamento de Redes Neurais.


O algoritmo de backpropagation consiste em duas fases:


1. O passo para frente (forward pass), onde nossas entradas são passadas através da rede e as previsões de saída obtidas (essa etapa também é conhecida como fase de propagação).


2. O passo para trás (backward pass), onde calculamos o gradiente da função de perda na camada final (ou seja, camada de previsão) da rede e usamos esse gradiente para aplicar recursivamente a regra da cadeia (chain rule) para atualizar os pesos em nossa rede (etapa também conhecida como fase de atualização de pesos ou retro-propagação).


Vamos analisar cada uma dessas fases e compreender como funciona o backpropagation no treinamento nas redes neurais. No próximo capítulo, voltaremos ao script em Python para compreender como é a implementação do algoritmo. Let’s begin!


Forward Pass
------------


O propósito do passo para frente é propagar nossas entradas (os dados de entrada) através da rede aplicando uma série de *dot products* (multiplicação entre os vetores) e ativações até chegarmos à camada de saída da rede (ou seja, nossas previsões). Para visualizar esse processo, vamos primeiro considerar a tabela abaixo. Podemos ver que cada entrada X na matriz é 2-dim (2 dimensões), onde cada ponto de dado é representado por dois números. Por exemplo, o primeiro ponto de dado é representado pelo vetor de recursos (0, 0), o segundo ponto de dado por (0, 1), etc. Em seguida, temos nossos valores de saída Y como a coluna da direita. Nossos valores de saída são os rótulos de classe. Dada uma entrada da matriz, nosso objetivo é prever corretamente o valor de saída desejado. Em resumo, X representa as entradas e Y a saída.


 


![table](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/table.png)


 


Para obter uma precisão de classificação perfeita nesse problema, precisamos de uma rede neural feedforward com pelo menos uma camada oculta. Podemos então começar com uma arquitetura de 2-2-1 conforme a imagem abaixo.


 


![rede1](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/rede1.png)


 


Este é um bom começo, no entanto, estamos esquecendo de incluir o bias. Existem duas maneiras de incluir o bias b em nossa rede. Nós podemos:


1. Usar uma variável separada.  

 2. Tratar o bias como um parâmetro treinável dentro da matriz, inserindo uma coluna de **1s** nos vetores de recursos.


Inserir uma coluna de 1s no nosso vetor de recursos é feito de forma programática, mas para garantir a didática, vamos atualizar nossa matriz para ver isso explicitamente, conforme tabela abaixo. Como você pode ver, uma coluna de **1s** foi adicionada aos nossos vetores de recursos. Na prática você pode inserir essa coluna em qualquer lugar que desejar, mas normalmente a colocamos como a primeira entrada no vetor de recursos ou a última entrada no vetor de recursos.


 


![table2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/table2-1.png)


 


Como nós mudamos o tamanho do nosso vetor de recursos de entrada (normalmente o que é realizado dentro da implementação da rede em si, para que não seja necessário modificar explicitamente a nossa matriz), isso muda nossa arquitetura de rede de 2-2-1 para uma arquitetura 3-3-1, conforme imagem abaixo. Ainda nos referimos a essa arquitetura de rede como 2-2-1, mas quando se trata de implementação, na verdade, é 3-3-1 devido à adição do termo de bias incorporado na matriz.


![rede2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/rede2.png)


Finalmente, lembre-se de que tanto nossa camada de entrada quanto todas as camadas ocultas exigem um termo de bias. No entanto, a camada de saída final não requer um bias. O bias agora é um parâmetro treinável dentro da matriz de peso, tornando o treinamento mais eficiente e substancialmente mais fácil de implementar. Para ver o forward pass em ação, primeiro inicializamos os pesos em nossa rede, conforme figura abaixo. Observe como cada seta na matriz de peso tem um valor associado a ela – esse é o valor de peso atual para um determinado nó e significa o valor em que uma determinada entrada é amplificada ou diminuída. Este valor de peso será então atualizado durante a fase de backpropgation (lembre-se que ainda estamos no forward pass). Existem várias formas de inicializar o vetor de pesos e isso pode influenciar diretamente no treinamento da rede, como veremos mais abaixo.


Na extrema esquerda da figura abaixo, apresentamos o vetor de recursos (0, 1, 1) e também o valor de saída 1 para a rede, pois depois precisamos calcular os erros de previsão. Aqui podemos ver que 0,1 e 1 foram atribuídos aos três nós de entrada na rede. Para propagar os valores através da rede e obter a classificação final, nós precisamos do *dot product* entre as entradas e os valores de peso, seguido pela aplicação de um função de ativação (neste caso, a função **sigmóide s**). Vamos calcular as entradas para os três nós nas camadas ocultas:


1. s ((0 x 0.351) + (1 x 1.076) + (1 x 1.116)) = 0.899


2. s ((0 x 0.097) + (1 x 0.165)+(1 x 0.542)) = 0.593


3. s ((0x 0.457) + (1 x 0.165)+(1 x 0.331)) = 0.378


 


![rede3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/rede3.png)


 


 


Observando os valores dos nós das camadas ocultas (camadas do meio), podemos ver que os nós foram atualizados para refletir nossa computação. Agora temos nossas entradas para os nós da camada oculta. Para calcular a previsão de saída, uma vez mais usamos o *dot product* seguido por uma ativação sigmóide:


s ((0.899 x 0.383) + (0.593 x – 0.327) + (0.378 x -0.329)) = 0.506


A saída da rede é, portanto, 0.506. Podemos aplicar uma função de etapa (step function) para determinar se a saída é a classificação correta ou não:


 


![saida](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/saida-1.png)


 


Aplicando a step function com saida = 0.506, vemos que nossa rede prevê 1 que é, de fato, o rótulo de classe correto. No entanto, a nossa rede não está muito confiante neste rótulo de classe. O valor previsto 0.506 está muito próximo do limite da etapa. Idealmente, esta previsão deve ser mais próxima de 0.98 ou 0.99., implicando que a nossa rede realmente aprendeu o padrão no conjunto de dados. Para que nossa rede realmente “aprenda”, precisamos aplicar o backpropagation.


Backpropagation
---------------


Para qualquer problema de aprendizagem supervisionada, nós selecionamos pesos que fornecem a estimativa ótima de uma função que modela nossos dados de treinamento. Em outras palavras, queremos encontrar um conjunto de pesos W que minimize a saída de J(W), onde J(W) é a função de perda, ou o erro da rede. Nos capítulos anteriores, discutimos o algoritmo de gradiente descendente, em que atualizamos cada peso por alguma redução escalar negativa da derivada do erro em relação a esse peso. Se optarmos por usar gradiente descendente (ou quase qualquer outro algoritmo de otimização convexo), precisamos encontrar as derivadas na forma numérica.



> 
> O objetivo do backpropagation é otimizar os pesos para que a rede neural possa aprender a mapear corretamente as entradas para as saídas.
> 
> 
> 


Para outros algoritmos de aprendizado de máquina, como regressão logística ou regressão linear, o cálculo das derivadas é uma aplicação elementar de diferenciação. Isso ocorre porque as saídas desses modelos são apenas as entradas multiplicadas por alguns pesos escolhidos e, no máximo, alimentados por uma única função de ativação (a função sigmóide na regressão logística). O mesmo, no entanto, não pode ser dito para redes neurais. Para demonstrar isso, aqui está um diagrama de uma rede neural de dupla camada:


 


![diam](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/diam.jpeg)


 


Como você pode ver, cada neurônio é uma função do anterior conectado a ele. Em outras palavras, se alguém alterasse o valor de w1, os neurônios “hidden 1” e “hidden 2” (e, finalmente, a saída) mudariam. Devido a essa noção de dependências funcionais, podemos formular matematicamente a saída como uma função composta extensiva:


 


![func](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/func.png)


 


ou simplesmente:


 


![func2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/func2.png)


 


Para aplicar o algoritmo de backpropagation, nossa função de ativação deve ser diferenciável, de modo que possamos calcular a derivada parcial do erro em relação a um dado peso wi,j, loss(E), saída de nó oj e saída de rede j.


 


![derivada](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/derivada-1.png)


 


Aqui, a saída é uma função composta dos pesos, entradas e função (ou funções) de ativação. É importante perceber que as unidades / nós ocultos são simplesmente cálculos intermediários que, na realidade, podem ser reduzidos a cálculos da camada de entrada. Se fôssemos então tirar a derivada da função com relação a algum peso arbitrário (por exemplo, w1), aplicaríamos iterativamente a regra da cadeia (da qual eu tenho certeza que você se lembra do [capítulo anterior](https://www.deeplearningbook.com.br/algoritmo-backpropagation-parte1-grafos-computacionais-e-chain-rule/)). O resultado seria semelhante ao seguinte:


 


![func3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/func3.png)


 


Agora, vamos anexar mais uma operação à cauda da nossa rede neural. Esta operação irá calcular e retornar o erro – usando a função de custo – da nossa saída:


 


![func4](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/func4.jpeg)


 


Tudo o que fizemos foi adicionar outra dependência funcional; nosso erro é agora uma função da saída e, portanto, uma função da entrada, pesos e função de ativação. Se fôssemos calcular a derivada do erro com qualquer peso arbitrário (novamente, escolheríamos w1), o resultado seria:


 


![func5](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/func5.png)


 


Cada uma dessas derivações pode ser simplificada, uma vez que escolhemos uma função de ativação e erro, de modo que todo o resultado represente um valor numérico. Nesse ponto, qualquer abstração foi removida e a derivada de erro pode ser usada na descida do gradiente (como discutido anteriormente aqui no livro) para melhorar iterativamente o peso. Calculamos as derivadas de erro w.r.t. para todos os outros pesos na rede e aplicamos gradiente descendente da mesma maneira. Isso é backpropagation – simplesmente o cálculo de derivadas que são alimentadas para um algoritmo de otimização convexa. Chamamos isso de “retropropagação” porque estamos usando o erro de saída para atualizar os pesos, tomando passos iterativos usando a regra da cadeia até que alcancemos o valor de peso ideal.


Depois de compreender o funcionamento do algoritmo backpropagation, você percebe sua simplicidade. Claro, a aritmética/cálculos reais podem ser difíceis, mas esse processo é tratado pelos nossos computadores. Na realidade, o backpropagation é apenas uma aplicação da regra da cadeia (chain rule). Como as redes neurais são estruturas de modelo de aprendizado de máquina multicamadas complicadas, cada peso “contribui” para o erro geral de uma maneira mais complexa e, portanto, as derivadas reais exigem muito esforço para serem produzidas. No entanto, uma vez que passamos pelo cálculo, o backpropagation das redes neurais é equivalente à descida de gradiente típica para regressão logística / linear.


Assim, como regra geral de atualizações de peso, podemos usar a Regra Delta (Delta Rule):


 


**Novo Peso = Peso Antigo – Derivada \* Taxa de Aprendizagem**


 


A taxa de aprendizagem (learning rate) é introduzida como uma constante (geralmente muito pequena), a fim de forçar o peso a ser atualizado de forma suave e lenta (para evitar grandes passos e comportamento caótico).


Para validar esta equação:


* Se a Derivada for positiva, isso significa que um aumento no peso aumentará o erro, portanto, o novo peso deverá ser menor.
* Se a Derivada é negativa, isso significa que um aumento no peso diminuirá o erro, portanto, precisamos aumentar os pesos.
* Se a Derivada é 0, significa que estamos em um mínimo estável. Assim, nenhuma atualização nos pesos é necessária -> chegamos a um estado estável.


Existem vários métodos de atualização de peso. Esses métodos são frequentemente chamados de *otimizadores*. A regra delta é a mais simples e intuitiva, no entanto, possui várias desvantagens. Confira nas referências ao final do capítulo, um excelente artigo sobre otimizadores.


Como atualizamos os pesos com uma pequena etapa delta de cada vez, serão necessárias várias iterações para ocorrer o aprendizado. Na rede neural, após cada iteração, a força de descida do gradiente atualiza os pesos para um valor cada vez menor da função de perda global. A atualização de peso na rede neural é guiada pela força do gradiente descendente sobre o erro.


Quantas iterações são necessárias para convergir (ou seja, alcançar uma função de perda mínima global)? Isso vai depender de diversos fatores:


* Depende de quão forte é a taxa de aprendizado que estamos aplicando. Alta taxa de aprendizado significa aprendizado mais rápido, mas com maior chance de instabilidade.
* Depende também dos hyperparâmetros da rede (quantas camadas, quão complexas são as funções não-lineares, etc..). Quanto mais variáveis, mais leva tempo para convergir, mas a precisão tende a ser maior.
* Depende do uso do método de otimização, pois algumas regras de atualização de peso são comprovadamente mais rápidas do que outras.
* Depende da inicialização aleatória da rede. Talvez com alguma sorte você inicie a rede com pesos quase ideais e esteja a apenas um passo da solução ideal. Mas o contrário também pode ocorrer.
* Depende da qualidade do conjunto de treinamento. Se a entrada e a saída não tiverem correlação entre si, a rede neural não fará mágica e não poderá aprender uma correlação aleatória.


Ou seja, treinar uma rede neural não é tarefa simples. Imagine agora treinar uma rede profunda, com várias camadas intermediárias e milhões ou mesmo bilhões de pontos de dados e você compreende o quão trabalhoso isso pode ser e quantas decisões devem ser tomadas pelo [Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) ou [Engenheiro de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia). E aprender a trabalhar de forma profissional, requer tempo, dedicação e preparo e melhor ainda se isso puder ser 100% em português para acelerar seu aprendizado. Construir aplicações de IA é uma habilidade com demanda cada vez maior no mercado.


Agora que você já compreende como funciona o backpropagation, podemos retornar ao código Python e ver tudo isso funcionando na prática. Mas isso é assunto para o próximo capítulo!


Referências:


[Formação Engenheiro de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Dot Product](https://en.wikipedia.org/wiki/Dot_product)


[How the backpropagation algorithm works](http://neuralnetworksanddeeplearning.com/chap2.html)


[Delta Rule](http://www.cs.stir.ac.uk/courses/ITNP4B/lectures/kms/3-DeltaRule.pdf)


[An overview of gradient descent optimization algorithms](http://ruder.io/optimizing-gradient-descent/)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Derivada](https://pt.wikipedia.org/wiki/Derivada)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


[An overview of gradient descent optimization algorithms](http://ruder.io/optimizing-gradient-descent/)


[Optimization: Stochastic Gradient Descent](http://ufldl.stanford.edu/tutorial/supervised/OptimizationStochasticGradientDescent/)


[Gradient Descent vs Stochastic Gradient Descent vs Mini-Batch Learning](https://sebastianraschka.com/faq/docs/closed-form-vs-gd.html)


<div id="capitulo-16---algoritmo-backpropagation-em-python"></div>

# Capítulo 16 – Algoritmo Backpropagation em Python


Depois de compreender como funciona o backpropagation, podemos agora entender o código usado em alguns capítulos anteriores para implementar o algoritmo (o qual vamos reproduzir aqui). O arquivo com o código completo pode ser encontrado [aqui](https://drive.google.com/file/d/1esmcuW-aluCZTwS-Yjh1x-uijX8DHK62/view).


Em nosso código nós temos os métodos **update\_mini\_batch** e **backprop** da classe Network. Em particular, o método **update\_mini\_batch** atualiza os pesos e bias da rede calculando o gradiente para o mini\_batch atual de exemplos (dados) de treinamento:


 


![metodo1](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/metodo1-1024x378.png)


 


A maior parte do trabalho é feita pela linha:


 **delta\_nabla\_b, delta\_nabla\_w = self.backprop (x, y)**


que usa o método backprop para descobrir as derivadas parciais ∂Cx / ∂blj e ∂Cx / ∂wljk. Isso invoca o algoritmo de backpropagation, que é uma maneira rápida de calcular o gradiente da função de custo. Portanto, update\_mini\_batch funciona simplesmente calculando esses gradientes para cada exemplo de treinamento no mini\_batch e, em seguida, atualizando self.weights e self.biases adequadamente. Há uma pequena mudança – usamos uma abordagem ligeiramente diferente para indexar as camadas. Essa alteração é feita para aproveitar um recurso do Python, ou seja, o uso de índices de lista negativa para contar para trás a partir do final de uma lista, por exemplo, lst[-3] é a terceira última entrada em uma lista chamada lst. O código para backprop está abaixo, junto com algumas funções auxiliares, que são usadas para calcular a função σ, a derivada σ′ e a derivada da função de custo. Com essas inclusões, você deve ser capaz de entender o código de maneira independente:


 


![backprop](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/backprop-1024x916.png)


 


Observe o método backprop. Começamos inicalizando as matrizes de pesos (nabla\_w) e bias (nabla\_b) com zeros. Essas  matrizes serão alimentadas com valores durante o processo de treinamento. Isso é o que a rede neural artificial efetivamente aprende. Depois de inicializar alguns objetos, temos um loop for para cada valor de b e w (que a esta altura você já sabe se trata de bias e pesos, respectivamente). Neste loop, usamos a função np.dot do Numpy para a multiplicação entre matrizes e adição do bias, colocamos o resultado na lista z e fazemos uma chamada à função de ativação Sigmóide. Ao final deste loop, teremos a lista com todas as ativações e finalizamos a passada para a frente.


Na passada para trás (Backward Pass) calculamos as derivadas e fazemos as multiplicações de matrizes mais uma vez (o funcionamento de redes neurais artificiais é baseado em um conceito elementar da Álgebra Linear, a multiplicação de matrizes). Repare que chamamos o método Transpose() para gerar a transposta da matriz e assim ajustar as dimensões antes de efetuar os cálculo. Por fim, retornamos bias e pesos.


### Em que sentido backpropagation é um algoritmo rápido?


Para responder a essa pergunta, vamos considerar outra abordagem para calcular o gradiente. Imagine que é o início da pesquisa de redes neurais. Talvez seja a década de 1950 ou 1960, e você é a primeira pessoa no mundo a pensar em usar gradiente descendente para o aprendizado! Mas, para que a ideia funcione, você precisa de uma maneira de calcular o gradiente da função de custo. Você volta ao seu conhecimento de cálculo e decide se pode usar a regra da cadeia (chain rule) para calcular o gradiente. Mas depois de brincar um pouco, a álgebra parece complicada e você fica desanimado. Então você tenta encontrar outra abordagem. Você decide considerar o custo como uma função apenas dos pesos C = C(w) (voltaremos ao bias em um momento). Você numera os pesos w1, w2,… e deseja computar ∂C / ∂wj para um peso específico wj. Uma maneira óbvia de fazer isso é usar a aproximação


![form](https://www.deeplearningbook.com.br/wp-content/uploads/2018/04/form-1.png)


onde ϵ> 0 é um pequeno número positivo e ej é o vetor unitário na direção j. Em outras palavras, podemos estimar ∂C / ∂wj calculando o custo C para dois valores ligeiramente diferentes de wj e, em seguida, aplicando a equação. A mesma ideia nos permitirá calcular as derivadas parciais ∂C / ∂b em relação aos vieses (bias).


Essa abordagem parece muito promissora. É simples conceitualmente e extremamente fácil de implementar, usando apenas algumas linhas de código. Certamente, parece muito mais promissor do que a ideia de usar a regra da cadeia para calcular o gradiente!


Infelizmente, embora essa abordagem pareça promissora, quando você implementa o código, ele fica extremamente lento. Para entender porque, imagine que temos um milhão de pesos em nossa rede. Então, para cada peso distinto wj, precisamos computar C (w + ϵej) para calcular ∂C / ∂wj. Isso significa que, para calcular o gradiente, precisamos computar a função de custo um milhão de vezes diferentes, exigindo um milhão de passos para frente pela rede (por exemplo, treinamento). Precisamos calcular C(w) também, em um total de um milhão de vezes e em uma única passada pela rede.


O que há de inteligente no backpropagation é que ele nos permite calcular simultaneamente todas as derivadas parciais ∂C / ∂wj usando apenas uma passagem direta pela rede, seguida por uma passagem para trás pela rede. Grosso modo, o custo computacional do passe para trás é quase o mesmo que o do forward. Isso deve ser plausível, mas requer algumas análises para fazer uma declaração cuidadosa. É plausível porque o custo computacional dominante no passe para frente é multiplicado pelas matrizes de peso, enquanto no passo para trás é multiplicado pelas transpostas das matrizes de peso. Obviamente, essas operações têm um custo computacional similar. E assim, o custo total da retropropagação (backpropagation) é aproximadamente o mesmo que fazer apenas duas passagens pela rede. Compare isso com o milhão e um passe para frente que precisávamos para a abordagem que descrevi anteriormente. E assim, embora a retropropagação pareça superficialmente mais complexa do que a abordagem anterior, é na verdade muito, muito mais rápida.


Essa aceleração foi amplamente apreciada em 1986 e expandiu enormemente a gama de problemas que as redes neurais poderiam resolver. Isso, por sua vez, causou uma onda de pessoas usando redes neurais. Claro, a retropropagação não é uma panacéia. Mesmo no final da década de 1980, as pessoas enfrentavam limites, especialmente quando tentavam usar a retropropagação para treinar redes neurais profundas, ou seja, redes com muitas camadas ocultas. Mais adiante, no livro, veremos como os computadores modernos e algumas novas ideias inteligentes tornam possível usar a retropropagação para treinar redes neurais bem profundas.


Seu trabalho agora é estudar e compreender cada linha de código usada em nossa rede de amostra. Esse código é bem simples e o objetivo é mostrar a você como as coisas funcionam programaticamente. Ainda vamos treinar nossa rede, avaliar seu desempenho, otimizar algumas operações e compreender outros conceitos básicos. Temos muito mais vindo por aí! Até o próximo capítulo!


Referências:


[Machine Learning](https://www.datascienceacademy.com.br/course/machine-learning-engineer)


[Dot Product](https://en.wikipedia.org/wiki/Dot_product)


[How the backpropagation algorithm works](http://neuralnetworksanddeeplearning.com/chap2.html)


[Delta Rule](http://www.cs.stir.ac.uk/courses/ITNP4B/lectures/kms/3-DeltaRule.pdf)


[An overview of gradient descent optimization algorithms](http://ruder.io/optimizing-gradient-descent/)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Derivada](https://pt.wikipedia.org/wiki/Derivada)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


[An overview of gradient descent optimization algorithms](http://ruder.io/optimizing-gradient-descent/)


[Optimization: Stochastic Gradient Descent](http://ufldl.stanford.edu/tutorial/supervised/OptimizationStochasticGradientDescent/)


[Gradient Descent vs Stochastic Gradient Descent vs Mini-Batch Learning](https://sebastianraschka.com/faq/docs/closed-form-vs-gd.html)


 


<div id="capitulo-17---cross-entropy-cost-function"></div>

# Capítulo 17 – Cross-Entropy Cost Function


Quando um jogador de tênis está aprendendo a praticar o esporte, ele geralmente passa a maior parte do tempo desenvolvendo o movimento do corpo. Apenas gradualmente ele desenvolve as tacadas, aprende a movimentar a bola com precisão para a quadra adversária e com isso vai construindo sua técnica, que se aprimora à medida que ele pratica. De maneira semelhante, até agora nos concentramos em entender o algoritmo de retropropagação (backpropagation), a base para aprender a maioria das atividades em redes neurais. A partir de agora, estudaremos um conjunto de técnicas que podem ser usadas para melhorar nossa implementação do backpropagation e, assim, melhorar a maneira como nossas redes aprendem.


As técnicas que desenvolveremos incluem: uma melhor escolha de função de custo, conhecida como função de custo de entropia cruzada (ou Cross-Entropy Cost Function); quatro métodos de “regularização” (regularização de L1 e L2, dropout e expansão artificial dos dados de treinamento), que melhoram nossas redes para generalizar além dos dados de treinamento; um método melhor para inicializar os pesos na rede; e um conjunto de heurísticas para ajudar a escolher bons hyperparâmetros para a rede. Também vamos analisar várias outras técnicas com menos profundidade. As discussões são em grande parte independentes umas das outras e, portanto, você pode avançar se quiser. Também implementaremos muitas das técnicas em nosso código e usaremos para melhorar os resultados obtidos no problema de classificação de dígitos manuscritos estudado nos [capítulos anteriores](https://www.deeplearningbook.com.br/construindo-uma-rede-neural-para-reconhecimento-de-digitos/).


Naturalmente, estamos cobrindo apenas algumas das muitas técnicas que foram desenvolvidas para uso em redes neurais. A filosofia é que o melhor acesso à multiplicidade de técnicas disponíveis é o estudo aprofundado de algumas das mais importantes. Dominar essas técnicas importantes não é apenas útil por si só, mas também irá aprofundar sua compreensão sobre quais problemas podem surgir quando você usa redes neurais. Isso deixará você bem preparado para aprender rapidamente outras técnicas, conforme necessário.


### A Função de Custo


A maioria de nós acha desagradável estar errado. Logo depois de começar a aprender piano, minha filha fez sua primeira apresentação diante de uma platéia. Ela estava nervosa e começou a tocar a peça com uma oitava muito baixa. Ela ficou confusa e não pôde continuar até que alguém apontasse o erro. Ela ficou muito envergonhada. Ainda que desagradável, também aprendemos rapidamente quando estamos decididamente errados. Você pode apostar que a próxima vez que ela se apresentou diante de uma platéia, ela começou na oitava correta! Em contraste, aprendemos mais lentamente quando nossos erros são menos bem definidos.


Idealmente, esperamos que nossas redes neurais aprendam rapidamente com seus erros. Mas é isso que acontece na prática? Para responder a essa pergunta, vamos dar uma olhada em um exemplo simples. O exemplo envolve um neurônio com apenas uma entrada:


 


![neuron](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/neuron.png)


 


Nós vamos treinar esse neurônio para fazer algo ridiculamente fácil: obter a entrada 1 e gerar a saída 0. Claro, essa é uma tarefa tão trivial que poderíamos facilmente descobrir um peso apropriado e um viés (bias) de forma manual, sem usar um algoritmo de aprendizado. No entanto, vai nos ajudar a compreender melhor o processo de usar gradiente descendente para tentar aprender um peso e viés. Então, vamos dar uma olhada em como o neurônio aprende.


Para tornar as coisas definitivas, escolhemos o peso inicial como 0.6 e o ​​viés inicial como 0.9. Estas são escolhas genéricas usadas como um lugar para começar a aprender, eu não as escolhi para serem especiais de alguma forma. A saída inicial do neurônio é 0.82, então um pouco de aprendizado será necessário antes que nosso neurônio se aproxime da saída desejada 0,0.


No gráfico abaixo, podemos ver como o neurônio aprende uma saída muito mais próxima de 0.0. Durante o treinamento, o modelo está realmente computando o gradiente, e usando o gradiente para atualizar o peso e o viés, e exibir o resultado. A taxa de aprendizado é η = 0.15, o que acaba sendo lento o suficiente para que possamos acompanhar o que está acontecendo, mas rápido o suficiente para que possamos obter um aprendizado substancial em apenas alguns segundos. O custo é a função de custo quadrático, C, apresentada nos capítulos anteriores. Vou lembrá-lo da forma exata da função de custo em breve.


 


![train](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/train.png)


 


Como você pode ver, o neurônio aprende um peso e um viés que diminui o custo e dá uma saída do neurônio de cerca de 0.09 (Epoch, ou Época em português, é o número de passadas que nosso modelo faz pelos dados. A cada passada, os pesos são atualizados, o aprendizado ocorre e o custo, ou a taxa de erros, diminui). Isso não é exatamente o resultado desejado, 0.0, mas é muito bom.


Suponha, no entanto, que, em vez disso, escolhamos o peso inicial e o viés inicial como 2.0. Nesse caso, a saída inicial é 0.98, o que é muito ruim. Vamos ver como o neurônio aprende a gerar 0 neste caso:


 


![train2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/train2.png)


 


Embora este exemplo use a mesma taxa de aprendizado (η = 0.15), podemos ver que a aprendizagem começa muito mais devagar. De fato, nas primeiras 150 épocas de aprendizado, os pesos e vieses não mudam muito. Então o aprendizado entra em ação e, como em nosso primeiro exemplo, a saída do neurônio se aproxima rapidamente de 0.0.


Esse comportamento é estranho quando comparado ao aprendizado humano. Como eu disse no começo deste capítulo, muitas vezes aprendemos mais rápido quando estamos muito errados sobre algo. Mas acabamos de ver que nosso neurônio artificial tem muita dificuldade em aprender quando está muito errado – muito mais dificuldade do que quando está apenas um pouco errado. Além do mais, verifica-se que esse comportamento ocorre não apenas neste exemplo, mas em redes mais gerais. Por que aprender tão devagar? E podemos encontrar uma maneira de evitar essa desaceleração?


Para entender a origem do problema, considere que nosso neurônio aprende mudando o peso e o viés a uma taxa determinada pelas derivadas parciais da função custo, ∂C/∂w e ∂C/∂b. Então, dizer “aprender é lento” é realmente o mesmo que dizer que essas derivadas parciais são pequenas. O desafio é entender por que eles são pequenas. Para entender isso, vamos calcular as derivadas parciais. Lembre-se de que estamos usando a função de custo quadrático, que é dada por:


![cost](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/cost.png)


onde **a** é a saída do neurônio quando a entrada de treinamento x = 1 é usada, e y = 0 é a saída desejada correspondente. Para escrever isso mais explicitamente em termos de peso e viés, lembre-se que a = σ(z), onde z = wx + b. Usando a regra da cadeia para diferenciar em relação ao peso e viés, obtemos:


 


![cost2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/cost2.png)


 


onde substitui x = 1 e y = 0. Para entender o comportamento dessas expressões, vamos olhar mais de perto o termo σ ′ (z) no lado direito. Lembre-se da forma da função σ:


 


![sig](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/sig.png)


 


Podemos ver neste gráfico que quando a saída do neurônio é próxima de 1, a curva fica muito plana, e então σ ′ (z) fica muito pequeno. As equações acima então nos dizem que ∂C/∂w e ∂C/∂b ficam muito pequenos. Esta é a origem da desaceleração da aprendizagem. Além do mais, como veremos mais adiante, a desaceleração do aprendizado ocorre basicamente pelo mesmo motivo em redes neurais mais genéricas, não apenas neste exemplo simples.


### A Função de Custo de Entropia Cruzada


Como podemos abordar a desaceleração da aprendizagem? Acontece que podemos resolver o problema substituindo o custo quadrático por uma função de custo diferente, conhecida como entropia cruzada. Para entender a entropia cruzada, vamos nos afastar um pouco do nosso modelo super-simples. Vamos supor que estamos tentando treinar um neurônio com diversas variáveis de entrada, x1, x2,…, pesos correspondentes w1, w2,… e um viés, b:


 


![neuron2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/neuron2.png)


 


A saída do neurônio é, naturalmente, **a = σ(z)**, onde **z = ∑jwjxj + b** é a soma ponderada das entradas. Nós definimos a função de custo de entropia cruzada para este neurônio assim:


 


![entropy](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/entropy.png)


 


onde **n** é o número total de itens de dados de treinamento, a soma é sobre todas as entradas de treinamento **x,** e **y** é a saída desejada correspondente. Não é óbvio que a expressão anterior resolva o problema de desaceleração do aprendizado. De fato, francamente, nem é óbvio que faz sentido chamar isso de uma função de custo! Antes de abordar a desaceleração da aprendizagem, vamos ver em que sentido a entropia cruzada pode ser interpretada como uma função de custo.


Duas propriedades em particular tornam razoável interpretar a entropia cruzada como uma função de custo. Primeiro, não é negativo, isto é, C > 0. Para visualizar isso, observe na fórmula anterior que: (a) todos os termos individuais na soma são negativos, já que ambos os logaritmos são de números no intervalo de 0 a 1; e (b) há um sinal de menos na frente da soma.


Segundo, se a saída real do neurônio estiver próxima da saída desejada para todas as entradas de treinamento x, então a entropia cruzada será próxima de zero. Para ver isso, suponha, por exemplo, que y = 0 e a ≈ 0 para alguma entrada x. Este é um caso quando o neurônio está fazendo um bom trabalho nessa entrada. Vemos que o primeiro termo (na fórmula acima) para o custo, desaparece, desde que y = 0, enquanto o segundo termo é apenas −ln (1 − a) ≈ 0. Uma análise semelhante é válida quando y = 1 e a ≈ 1. E assim, a contribuição para o custo será baixa, desde que a saída real esteja próxima da saída desejada.


**Em suma, a entropia cruzada é positiva e tende a zero, à medida que o neurônio melhora a computação da saída desejada, y, para todas as entradas de treinamento, x**.


Essas são as duas propriedades que esperamos intuitivamente para uma função de custo. De fato, ambas as propriedades também são satisfeitas pelo custo quadrático. Portanto, isso é uma boa notícia para a entropia cruzada. Mas a função custo de entropia cruzada tem o benefício de que, ao contrário do custo quadrático, evita o problema de desaceleração do aprendizado. Para ver isso, vamos calcular a derivada parcial do custo de entropia cruzada em relação aos pesos. Substituímos a = σ (z) na fórmula acima e aplicamos a regra da cadeia duas vezes, obtendo:


 


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/form1.png)


 


Colocando tudo em um denominador comum e simplificando, isso se torna:


 


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/form2.png)


 


Usando a definição da função sigmóide, σ (z) = 1 / (1 + ez), e um pouco de álgebra, podemos mostrar que σ (z) = σ (z) (1 − σ (z)). Vemos que os termos σ′ (z) e σ (z) (1 − σ (z)) se cancelam na equação acima, e simplificando torna-se:


 


![form3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/form3.png)


 


Esta é uma bela expressão. Ela nos diz que a taxa na qual o peso aprende é controlada por σ (z) −y, ou seja, pelo erro na saída. Quanto maior o erro, mais rápido o neurônio aprenderá. Isso é exatamente o que nós esperamos intuitivamente. Em particular, evita a lentidão de aprendizado causada pelo termo σ′ (z) na equação análoga para o custo quadrático. Quando usamos a entropia cruzada, o termo σ′ (z) é cancelado e não precisamos mais nos preocupar em ser pequeno. Este cancelamento é o milagre especial assegurado pela função de custo de entropia cruzada. Na verdade, não é realmente um milagre. Como veremos mais adiante, a entropia cruzada foi especialmente escolhida por ter apenas essa propriedade.


De maneira semelhante, podemos calcular a derivada parcial para o viés. Eu não vou passar por todos os detalhes novamente, mas você pode facilmente verificar que:


![form4](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/form4.png)


 


Novamente, isso evita a lentidão de aprendizado causada pelo termo σ′ (z) na equação análoga para o custo quadrático.


Agora vamos retornar ao exemplo do início deste capítulo, e explorar o que acontece quando usamos a entropia cruzada em vez do custo quadrático. Para nos reorientarmos, começaremos com o caso em que o custo quadrático foi bom, com peso inicial de 0.6 e viés inicial de 0.9. Veja o que acontece quando substituímos o custo quadrático pela entropia cruzada:


 


![train3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/train3.png)


 


Como era de se esperar, o neurônio aprende perfeitamente bem neste caso, assim como fez anteriormente. E agora vamos olhar para o caso em que nosso neurônio ficou preso antes, com o peso e o viés ambos começando em 2.0:


 


![train4](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/train4.png)


 


**Sucesso!** Desta vez, o neurônio aprendeu rapidamente, exatamente como esperávamos. Se você observar atentamente, pode ver que a inclinação da curva de custo era muito mais íngreme inicialmente do que a região plana inicial na curva correspondente para o custo quadrático. É essa inclinação que a entropia cruzada nos ajuda a resolver, impedindo-nos de ficar presos exatamente quando esperamos que nosso neurônio aprenda mais depressa, ou seja, quando o neurônio começa errado.


Eu não disse qual taxa de aprendizado foi usada nos exemplos que acabei de ilustrar. Anteriormente, com o custo quadrático, usamos η = 0.15. Deveríamos ter usado a mesma taxa de aprendizado nos novos exemplos? De fato, com a mudança na função de custo, não é possível dizer precisamente o que significa usar a “mesma” taxa de aprendizado; é uma comparação de maçãs e laranjas. Para ambas as funções de custo, simplesmente experimentei encontrar uma taxa de aprendizado que possibilitasse ver o que está acontecendo. Se você ainda estiver curioso, aqui está o resumo: usei η = 0.005 nos exemplos que acabei de fornecer.


Você pode contestar que a mudança na taxa de aprendizado torna os gráficos acima sem sentido. Quem se importa com a rapidez com que o neurônio aprende, quando a nossa escolha de taxa de aprendizado foi arbitrária, para começar ?! Mas essa objeção não procede. O ponto dos gráficos não é sobre a velocidade absoluta de aprendizagem. É sobre como a velocidade do aprendizado muda. Em particular, quando usamos o custo quadrático, a aprendizagem é mais lenta quando o neurônio está inequivocamente errado do que é mais tarde durante o treinamento, à medida que o neurônio se aproxima da saída correta; enquanto o aprendizado de entropia cruzada é mais rápido quando o neurônio está inequivocamente errado. Essas declarações não dependem de como a taxa de aprendizado é definida.


Estamos estudando a entropia cruzada para um único neurônio. No entanto, é fácil generalizar a entropia cruzada para redes multicamadas de muitos neurônios. Em particular, suponha que y = y1, y2,… são os valores desejados nos neurônios de saída, ou seja, os neurônios na camada final, enquanto aL1, aL2,… são os valores reais de saída. Então nós definimos a entropia cruzada por:


 


![cost](https://www.deeplearningbook.com.br/wp-content/uploads/2018/05/cost-1.png)


 


Isso é o mesmo que nossa expressão anterior, exceto que agora nós temos o ∑j somando todos os neurônios de saída. Não vou explicitamente trabalhar com uma derivação, mas deve ser plausível que o uso da expressão anterior evite uma desaceleração na aprendizagem em muitas redes de neurônios.


A propósito, estou usando o termo “entropia cruzada” de uma maneira que confundiu alguns dos primeiros leitores, já que parece superficialmente entrar em conflito com outras fontes. Em particular, é comum definir a entropia cruzada para duas distribuições de probabilidade, pj e qj, como ∑jpjlnqj. Esta definição pode ser conectada a fórmula da entropia para um neurônio mostrada anteriormente, se tratarmos um único neurônio sigmóide como saída de uma distribuição de probabilidade que consiste na ativação a do neurônio ae seu complemento 1 − a.


No entanto, quando temos muitos neurônios sigmoides na camada final, o vetor aLj de ativações não costuma formar uma distribuição de probabilidade. Como resultado, uma definição como ∑jpjlnqj não faz sentido, já que não estamos trabalhando com distribuições de probabilidade. Em vez disso, você pode pensar na fórmula da entropia para múltiplos neurônios como um conjunto somado de entropias cruzadas por neurônio, com a ativação de cada neurônio sendo interpretada como parte de uma distribuição de probabilidade de dois elementos. Sim, eu sei que isso não é simples.


Nesse sentido, a fórmula da entropia para múltiplos neurônios é uma generalização da entropia cruzada para distribuições de probabilidade.


Quando devemos usar a entropia cruzada em vez do custo quadrático? De fato, a entropia cruzada é quase sempre a melhor escolha, desde que os neurônios de saída sejam neurônios sigmóides. Para entender por que, considere que, quando estamos configurando a rede, normalmente inicializamos os pesos e vieses usando algum tipo de aleatoriedade. Pode acontecer que essas escolhas iniciais resultem na rede sendo decisivamente errada para alguma entrada de treinamento – isto é, um neurônio de saída terá saturado próximo de 1, quando deveria ser 0, ou vice-versa. Se estamos usando o custo quadrático que irá desacelerar a aprendizagem, ele não vai parar de aprender completamente, já que os pesos continuarão aprendendo com outras entradas de treinamento, mas é obviamente indesejável.


Construir aplicações de IA é uma habilidade com demanda cada vez maior no mercado.


Pensando nisso, a Data Science Academy oferece um programa completo, onde esses e vários outros conceitos são estudados em detalhes e com várias aplicações práticas, usando PyTorch. A [Formação Engenheiro de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia) é composta de 6 cursos, tudo 100% online e 100% em português, que aliam teoria e prática na medida certa, com aplicações reais de Inteligência Artificial. Confira o programa completo dos cursos: [Formação Engenheiro de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia). Várias empresas em todo Brasil já estão treinando seus profissionais conosco! Venha fazer parte da revolução da IA.


Até o próximo capítulo!


Referências:


[Dot Product](https://en.wikipedia.org/wiki/Dot_product)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Derivada](https://pt.wikipedia.org/wiki/Derivada)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


<div id="capitulo-18---entropia-cruzada-para-quantificar-a-diferenca-entre-duas-distribuicoes-de-probabilidade"></div>

# Capítulo 18 – Entropia Cruzada Para Quantificar a Diferença Entre Duas Distribuições de Probabilidade


A Cross-Entropy (ou entropia cruzada, se você preferir o termo em português) é fácil de implementar como parte de um programa que aprende usando gradiente descendente e backpropagation. Faremos isso nos próximos capítulos quando treinarmos uma rede completa, desenvolvendo uma versão melhorada do nosso programa anterior para classificar os dígitos manuscritos do dataset MNIST. O novo programa é chamado de network2.py e incorpora não apenas a entropia cruzada, mas também várias outras técnicas que estudaremos mais adiante. Agora, vejamos como usar a Entropia Cruzada Para Quantificar a Diferença Entre Duas Distribuições de Probabilidade.


Por enquanto, vamos ver como nosso novo programa classifica os dígitos MNIST. Usaremos uma rede com 30 neurônios ocultos, e usaremos um tamanho de mini-lote de 10. Definimos a taxa de aprendizado para η = 0,5 e nós treinamos por 30 épocas. A interface para o network2.py será um pouco diferente do network.py, mas ainda deve estar claro o que está acontecendo. Nos próximos capítulos apresentamos o código completo disponível [aqui](https://drive.google.com/file/d/1esmcuW-aluCZTwS-Yjh1x-uijX8DHK62/view).


 


[![corss-entropy](https://www.deeplearningbook.com.br/wp-content/uploads/2018/06/corss-entropy.png "Entropia Curzada")](https://www.datascienceacademy.com.br/pages/formacao-inteligencia-artificial)


 


Perceba que o comando net.large\_weight\_initializer() é usado para inicializar os pesos e vieses da mesma maneira que já descrevemos anteriormente. Precisamos executar este comando porque mais adiante vamos alterar o peso padrão para inicialização em nossas redes. O resultado da execução da sequência de comandos acima é uma rede com 95,49% de precisão.


Vejamos também o caso em que usamos 100 neurônios ocultos, a entropia cruzada, e mantemos os parâmetros da mesma forma. Neste caso, obtemos uma precisão de 96,82%. Essa é uma melhoria substancial em relação aos resultados que obtivemos nos [capítulos anteriores](https://www.deeplearningbook.com.br/algoritmo-backpropagation-parte-2-treinamento-de-redes-neurais/), onde a precisão de classificação foi de 96,59%, usando o custo quadrático. Isso pode parecer uma pequena mudança, mas considere que a taxa de erro caiu de 3,41% para 3,18%. Ou seja, eliminamos cerca de um em quatorze dos erros originais. Isso é uma melhoria bastante útil.


É encorajador que o custo de entropia cruzada nos dê resultados semelhantes ou melhores do que o custo quadrático. No entanto, esses resultados não provam conclusivamente que a entropia cruzada é uma escolha melhor. A razão é que nós colocamos apenas um pequeno esforço na escolha de hyperparâmetros como taxa de aprendizado, tamanho de mini-lote e assim por diante. Para que a melhoria seja realmente convincente, precisaríamos fazer um trabalho completo de otimização desses hyperparâmetros. Ainda assim, os resultados são encorajadores e reforçam nosso argumento teórico anterior de que a entropia cruzada é uma escolha melhor do que o custo quadrático.


Isso, a propósito, é parte de um padrão geral que veremos nos próximos capítulos e, na verdade, em grande parte do restante do livro. Vamos desenvolver uma nova técnica, vamos experimentá-la e obteremos resultados “aprimorados”. É claro que é bom vermos essas melhorias, mas a interpretação de tais melhorias é sempre problemática. Elas só são verdadeiramente convincentes se virmos uma melhoria depois de nos esforçarmos para otimizar todos os outros hyperparâmetros. Isso é uma grande quantidade de trabalho, exigindo muito poder de computação, e normalmente não vamos fazer uma investigação tão exaustiva. Em vez disso, procederemos com base em testes informais como os realizados até aqui.


Até agora, discutimos a entropia cruzada de forma bem detalhada. Por que tanto esforço quando a entropia cruzada nos dá apenas uma pequena melhora em nossos resultados com o dataset MNIST? Mais adiante veremos outras técnicas, notadamente a regularização, que trazem melhorias muito maiores. Então, por que tanto foco na entropia cruzada? Parte da razão é que a entropia cruzada é uma função de custo amplamente utilizada e, portanto, vale a pena compreendê-la bem. Mas a razão mais importante é que a saturação dos neurônios é um problema importante nas redes neurais, um problema ao qual voltaremos repetidamente ao longo do livro. Por isso discutimos a entropia cruzada em extensão pois é um bom laboratório para começar a entender a saturação dos neurônios e como ela pode ser abordada.


### O que significa a entropia cruzada? De onde isso vem?


Nossa discussão sobre a entropia cruzada se concentrou na análise algébrica e na implementação prática. Isso é útil, mas deixa questões conceituais mais amplas não respondidas, como: o que significa a entropia cruzada? Existe alguma maneira intuitiva de pensar sobre a entropia cruzada? E quanto ao significado intuitivo da entropia cruzada? Como devemos pensar sobre isso?


Explicar isso em profundidade nos levaria mais longe do que queremos ir neste livro. No entanto, vale ressaltar que existe uma maneira padrão de interpretar a entropia cruzada que vem do campo da teoria da informação. Vejamos.


Já sabemos que para treinar uma rede neural, você precisa encontrar o erro entre as saídas calculadas e as saídas alvo desejadas. A medida de erro mais comum é chamada de erro quadrático médio (ou Mean Square Error). No entanto, existem alguns resultados de pesquisa que sugerem o uso de uma medida diferente, denominada erro de entropia cruzada, como método preferível em relação ao erro quadrático médio.


A medida de entropia cruzada tem sido utilizada como alternativa ao erro quadrático médio. A entropia cruzada pode ser usada como uma medida de erro quando as saídas de uma rede podem ser pensadas como representando hipóteses independentes (por exemplo, cada nó significa um conceito diferente) e as ativações dos nós podem ser entendidas como representando a probabilidade (ou a confiança) que cada uma das hipóteses pode ser verdadeira. Nesse caso, o vetor de saída representa uma distribuição de probabilidade, e nossa medida de erro – entropia cruzada – indica a distância entre o que a rede acredita que essa distribuição deve ser e o que realmente deveria ser. Existe também uma razão prática para usar a entropia cruzada. Pode ser mais útil em problemas nos quais os alvos são 0 e 1. A entropia cruzada tende a permitir que erros alterem pesos mesmo quando houver nós saturados (o que significa que suas derivadas são próximas de 0). Vamos compreender melhor isso:


**A entropia cruzada é comumente usada para quantificar a diferença entre duas distribuições de probabilidade.** Geralmente, a distribuição “verdadeira” (dos dados usados para treinamento) é expressa em termos de uma distribuição One-Hot.


Por exemplo, suponha que para uma instância de treinamento específica (uma única linha no seu dataset), a classe seja B (de 3 possíveis possibilidades: A, B e C). A distribuição única para esta instância de treinamento é, portanto:


 


**Pr(Class A)  Pr(Class B)  Pr(Class C)**


**0.0          1.0          0.0**


 


Você pode interpretar a distribuição acima da seguinte forma: a instância de treinamento tem 0% de probabilidade de ser classe A, 100% de probabilidade de ser classe B e 0% de probabilidade de ser a classe C.


Agora, suponha que seu algoritmo de aprendizado de máquina tenha previsto a seguinte distribuição de probabilidade:


 


**Pr(Class A)  Pr(Class B)  Pr(Class C)** 


**0.228          0.619           0.153**


 


Quão próxima é a distribuição prevista da distribuição verdadeira? **É isso que determina o erro de entropia cruzada**. A entropia cruzada é representada por esta fórmula:


 


[![cross-entropy](https://www.deeplearningbook.com.br/wp-content/uploads/2018/06/cross-entropy.png "Entropia Cruzada")](https://www.datascienceacademy.com.br/pages/formacao-inteligencia-artificial)


 


A soma é sobre as três classes A, B e C. Se você completar o cálculo, você achará que a perda é 0.479. Então, é assim que “longe” está a sua previsão da distribuição verdadeira.


A entropia cruzada é uma das muitas funções de perda possíveis. Essas funções de perda são tipicamente escritas como J(theta) e podem ser usadas dentro da descida do gradiente, que é uma estrutura iterativa para mover os parâmetros (ou coeficientes) para os valores ótimos. **A entropia cruzada descreve a perda entre duas distribuições de probabilidade.**


Ao usar uma rede neural para realizar classificação e predição, geralmente é melhor usar o erro de entropia cruzada do que o erro de classificação e um pouco melhor usar o erro de entropia cruzada do que o erro quadrático médio para avaliar a qualidade da rede neural. É importante deixar claro que estamos lidando apenas com uma rede neural que é usada para classificar os dados, como a previsão da concessão de crédito (sim ou não), ou ainda outras classificações como idade, sexo ou dígitos no dataset MNIST e assim por diante. Não estamos lidando com uma rede neural que faz regressão, onde o valor a ser previsto é numérico.


Até o próximo capítulo!


Referências:


[Dot Product](https://en.wikipedia.org/wiki/Dot_product)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Derivada](https://pt.wikipedia.org/wiki/Derivada)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


<div id="capitulo-19---overfitting-e-regularizacao---parte-1"></div>

# Capítulo 19 – Overfitting e Regularização – Parte 1


O físico [Enrico Fermi](https://www.nobelprize.org/nobel_prizes/physics/laureates/1938/fermi-bio.html), ganhador do Prêmio Nobel de Física em 1938, foi questionado sobre sua opinião em relação a um modelo matemático que alguns colegas haviam proposto como a solução para um importante problema de física não resolvido. O modelo teve excelente performance no experimento, mas Fermi estava cético. Ele perguntou quantos parâmetros livres poderiam ser definidos no modelo. “Quatro” foi a resposta. Fermi respondeu: “Eu lembro que meu amigo Johnny Von Neumann costumava dizer: com quatro parâmetros eu posso encaixar um elefante, e com cinco eu posso fazê-lo mexer seu tronco” \*. Com isso, ele quis dizer que não se deve ficar impressionado quando um modelo complexo se ajusta bem a um conjunto de dados. Com parâmetros suficientes, você pode ajustar qualquer conjunto de dados.


(\* A citação vem de um artigo de Freeman Dyson, que é uma das pessoas que propôs o modelo. O artigo “Um elefante de quatro parâmetros” ou “A four-parameter elephant” pode ser encontrado [aqui](https://www.johndcook.com/blog/2011/06/21/how-to-fit-an-elephant/).)


O ponto, claro, é que modelos com um grande número de parâmetros podem descrever uma variedade incrivelmente ampla de fenômenos. Mesmo que tal modelo esteja de acordo com os dados disponíveis, isso não o torna um bom modelo. Isso pode significar apenas que há liberdade suficiente no modelo que pode descrever quase qualquer conjunto de dados de tamanho determinado, sem capturar nenhuma percepção genuína do fenômeno em questão. Quando isso acontece, o modelo funcionará bem para os dados existentes, mas não conseguirá generalizar para novas situações. O verdadeiro teste de um modelo é sua capacidade de fazer previsões em situações que não foram expostas antes.


Fermi e von Neumann suspeitavam de modelos com quatro parâmetros. Nossa rede de 30 neurônios ocultos para classificação de dígitos MNIST possui quase 24.000 parâmetros! Nossa rede de 100 neurônios ocultos tem cerca de 80.000 parâmetros e redes neurais profundas de última geração às vezes contêm milhões ou até bilhões de parâmetros. Devemos confiar nos resultados?


Vamos aguçar este problema construindo uma situação em que a nossa rede faz um mau trabalho ao generalizar para novas situações. Usaremos [nossa rede de 30 neurônios ocultos](https://www.deeplearningbook.com.br/construindo-uma-rede-neural-com-linguagem-python/), com seus 23.860 parâmetros. Mas não treinamos a rede usando todas as imagens de treinamento de 50.000 dígitos MNIST. Em vez disso, usaremos apenas as primeiras 1.000 imagens de treinamento. Usar esse conjunto restrito tornará o problema com a generalização muito mais evidente. Vamos treinar usando a função de custo de entropia cruzada, com uma taxa de aprendizado de η = 0,5 e um tamanho de mini-lote de 10. No entanto, vamos treinar por 400 épocas, pois não estamos usando muitos exemplos de treinamento. Vamos usar network2 para ver como a função de custo muda (o código você encontra [aqui](https://drive.google.com/file/d/1esmcuW-aluCZTwS-Yjh1x-uijX8DHK62/view)[)](https://github.com/dsacademybr/DeepLearningBook):


 


![network](https://www.deeplearningbook.com.br/wp-content/uploads/2018/06/network.png)


 


Usando os resultados, podemos traçar a maneira como o custo muda à medida que a rede aprende (o script overfitting.py contém o código que gera esse resultado):


![overfitting1](https://www.deeplearningbook.com.br/wp-content/uploads/2018/06/overfitting1.png)


Isso parece encorajador, mostrando uma redução suave no custo, exatamente como esperamos. Note que eu só mostrei as épocas de treinamento de 200 a 399. Isso nos dá uma boa visão dos últimos estágios do aprendizado, que, como veremos, é onde está a ação interessante.


Vamos agora ver como a precisão da classificação nos dados de teste muda com o tempo:


![overfitting2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/06/overfitting2.png)


Mais uma vez, eu ampliei um pouco. Nas primeiras 200 épocas (não mostradas), a precisão sobe para pouco menos de 82%. O aprendizado então diminui gradualmente. Finalmente, por volta da época 280, a precisão da classificação praticamente pára de melhorar. As épocas posteriores meramente vêem pequenas flutuações estocásticas perto do valor da precisão na época 280. Compare isso com o gráfico anterior, em que o custo associado aos dados de treinamento continua a cair suavemente. Se olharmos apenas para esse custo, parece que nosso modelo ainda está ficando “melhor”. Mas os resultados da precisão do teste mostram que a melhoria é uma ilusão. Assim como o modelo que Fermi não gostava, o que nossa rede aprende após a época 280 não mais se generaliza para os dados de teste. E assim não é um aprendizado útil. Dizemos que a rede está super adaptando ou com sobreajuste ou ainda com overfitting, a partir da época 280.


Você pode se perguntar se o problema aqui é que eu estou olhando para o custo dos dados de treinamento, ao contrário da precisão da classificação nos dados de teste. Em outras palavras, talvez o problema seja que estamos fazendo uma comparação de maçãs e laranjas. O que aconteceria se comparássemos o custo dos dados de treinamento com o custo dos dados de teste, estaríamos comparando medidas semelhantes? Ou talvez pudéssemos comparar a precisão da classificação tanto nos dados de treinamento quanto nos dados de teste? Na verdade, essencialmente o mesmo fenômeno aparece, não importa como fazemos a comparação. Os detalhes mudam, no entanto. Por exemplo, vamos analisar o custo nos dados de teste:


![overfitting3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/06/overfitting3.png)


Podemos ver que o custo nos dados de teste melhora até a época 15, mas depois disso ele realmente começa a piorar, mesmo que o custo nos dados de treinamento continue melhorando. Este é outro sinal de que nosso modelo está super adaptando (overfitting). No entanto, coloca um enigma, que é se devemos considerar a época 15 ou a época 280 como o ponto em que o overfitting está dominando a aprendizagem? Do ponto de vista prático, o que realmente nos importa é melhorar a precisão da classificação nos dados de teste, enquanto o custo dos dados de teste não é mais do que um proxy para a precisão da classificação. E assim faz mais sentido considerar a época 280 como o ponto além do qual o overfitting está dominando o aprendizado em nossa rede neural.


Outro sinal de overfitting pode ser visto na precisão da classificação nos dados de treinamento:


![overfitting4](https://www.deeplearningbook.com.br/wp-content/uploads/2018/06/overfitting4.png)


A precisão aumenta até 100%. Ou seja, nossa rede classifica corretamente todas as 1.000 imagens de treinamento! Enquanto isso, nossa precisão de teste atinge apenas 82,27%. Portanto, nossa rede realmente está aprendendo sobre as peculiaridades do conjunto de treinamento, não apenas reconhecendo os dígitos em geral. É quase como se nossa rede estivesse apenas memorizando o conjunto de treinamento, sem entender os dígitos suficientemente bem para generalizar o conjunto de testes.


Overfitting é um grande problema em redes neurais. Isso é especialmente verdadeiro em redes modernas, que geralmente têm um grande número de pesos e vieses. Para treinar de forma eficaz, precisamos de uma maneira de detectar quando o overfitting está acontecendo. E precisamos aplicar técnicas para reduzir os efeitos do overfitting (por todo esse trabalho e conhecimento necessário, [Cientistas de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) devem ser muito bem remunerados).


A maneira óbvia de detectar overfitting é usar a abordagem acima, mantendo o controle da precisão nos dados de teste conforme nossos treinos da rede. Se percebermos que a precisão nos dados de teste não está mais melhorando, devemos parar de treinar. É claro que, estritamente falando, isso não é necessariamente um sinal de overfitting. Pode ser que a precisão nos dados de teste e os dados de treinamento parem de melhorar ao mesmo tempo. Ainda assim, a adoção dessa estratégia impedirá o overfitting.


Na verdade, usaremos uma variação dessa estratégia. Lembre-se de que, quando carregamos os dados MNIST, carregamos em três conjuntos de dados:


 


![code](https://www.deeplearningbook.com.br/wp-content/uploads/2018/06/code.png)


 


Até agora, usamos o **training\_data** e **test\_data** e ignoramos o **validation\_data**. O validation\_data contém 10.000 imagens de dígitos, imagens que são diferentes das 50.000 imagens no conjunto de treinamento MNIST e das 10.000 imagens no conjunto de teste MNIST. Em vez de usar o test\_data para evitar overfitting, usaremos o validation\_data. Para fazer isso, usaremos praticamente a mesma estratégia descrita acima para o test\_data. Ou seja, calcularemos a precisão da classificação nos dados de validação no final de cada época. Quando a precisão da classificação nos dados de validação estiver saturada, paramos de treinar. Essa estratégia é chamada de parada antecipada (Early-Stopping). É claro que, na prática, não sabemos imediatamente quando a precisão está saturada. Em vez disso, continuamos treinando até termos certeza de que a precisão está saturada.


Por que usar o validation\_data para evitar overfitting, em vez de test\_data? Na verdade, isso faz parte de uma estratégia mais geral, que é usar o validation\_data para avaliar diferentes opções de avaliação de hiperparâmetros, como o número de épocas para treinamento, a taxa de aprendizado, a melhor arquitetura de rede e assim por diante. Usamos essas avaliações para encontrar e definir bons valores para os hiperparâmetros. De fato, embora eu não tenha mencionado isso até agora, isto é, em parte, como chegamos às escolhas de hiperparâmetros feitas anteriormente neste livro. (Mais sobre isso depois.)


Claro, isso não responde de forma alguma à pergunta de por que estamos usando o validation\_data para evitar overfitting, em vez de test\_data. Para entender o porquê, considere que, ao definir os hiperparâmetros, é provável que tentemos muitas opções diferentes para os hiperparâmetros. Se definirmos os hiperparâmetros com base nas avaliações do test\_data, será possível acabarmos super adequando nossos hiperparâmetros ao test\_data. Ou seja, podemos acabar encontrando hiperparâmetros que se encaixam em peculiaridades particulares dos dados de teste, mas onde o desempenho da rede não se generalizará para outros conjuntos de dados. Protegemos contra isso descobrindo os hiperparâmetros usando o validation\_data. Então, uma vez que tenhamos os hiperparâmetros que queremos, fazemos uma avaliação final da precisão usando o test\_data. Isso nos dá confiança de que nossos resultados nos dados de teste são uma medida real de quão bem nossa rede neural se generaliza. Para colocar de outra forma, você pode pensar nos dados de validação como um tipo de dados de treinamento que nos ajuda a aprender bons parâmetros. Essa abordagem para encontrar bons hiperparâmetros é às vezes conhecida como o método “hold out”, uma vez que os dados de validação são mantidos separados ou “mantidos” a partir dos dados de treinamento.


Agora, na prática, mesmo depois de avaliar o desempenho nos dados de teste, podemos mudar nossa opinião e tentar outra abordagem – talvez uma arquitetura de rede diferente – que envolva a descoberta de um novo conjunto de hiperparâmetros. Se fizermos isso, não há perigo de acabarmos com o test\_data também? Precisamos de uma regressão potencialmente infinita de conjuntos de dados, para que possamos ter certeza de que nossos resultados serão generalizados? Abordar essa preocupação é um problema profundo e difícil. Mas para nossos objetivos práticos, não vamos nos preocupar muito com essa questão. Em vez disso, vamos nos concentrar no método básico de retenção, com base nos dados training\_data, validation\_data e test\_data, conforme descrito acima.


Vimos que o overfitting ocorre quando estamos usando apenas 1.000 imagens de treinamento. O que acontece quando usamos o conjunto completo de treinamento de 50.000 imagens? Manteremos todos os outros parâmetros iguais (30 neurônios ocultos, taxa de aprendizado de 0,5, tamanho de mini-lote de 10), mas treinamos usando todas as 50.000 imagens por 30 épocas. Aqui está um gráfico mostrando os resultados da precisão de classificação nos dados de treinamento e nos dados de teste. Observe que usei os dados de teste aqui, em vez dos dados de validação, para tornar os resultados mais diretamente comparáveis aos gráficos anteriores.


![overfitting_full](https://www.deeplearningbook.com.br/wp-content/uploads/2018/06/overfitting_full.png)


Como você pode ver, a precisão nos dados de teste e treinamento permanece muito mais próxima do que quando estávamos usando 1.000 exemplos de treinamento. Em particular, a melhor precisão de classificação de 97,86% nos dados de treinamento é apenas 2,53% maior do que os 95,33% nos dados de teste. Isso é comparado com a diferença de 17,73% que tivemos anteriormente! Overfitting ainda está acontecendo, mas foi bastante reduzido. Nossa rede está se generalizando muito melhor dos dados de treinamento para os dados de teste. Em geral, uma das melhores maneiras de reduzir o overfitting é aumentar o volume (tamanho) dos dados de treinamento (fica claro agora porque [Big Data](https://www.datascienceacademy.com.br/cursosgratuitos) está revolucionando a Ciência de Dados?). Com dados de treinamento suficientes, é difícil até mesmo uma rede muito grande sofrer de overfitting. Infelizmente, os dados de treinamento podem ser caros ou difíceis de adquirir, por isso nem sempre é uma opção prática.


Aumentar a quantidade de dados de treinamento é uma maneira de reduzir o overfitting. Mas existem outras maneiras de reduzir a extensão do overfitting? Uma abordagem possível é reduzir o tamanho da nossa rede. No entanto, redes grandes têm o potencial de serem mais poderosas do que redes pequenas e, portanto, essa é uma opção que só adotamos em último caso.


Felizmente, existem outras técnicas que podem reduzir o overfitting, mesmo quando temos uma rede fixa e dados de treinamento fixos. Estas técnicas são conhecidas como técnicas de regularização e serão assunto do próximo capítulo.


Até lá!


Referências:


[Formação Engenheiro de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Dot Product](https://en.wikipedia.org/wiki/Dot_product)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


<div id="capitulo-20---overfitting-e-regularizacao---parte-2"></div>

# Capítulo 20 – Overfitting e Regularização – Parte 2


Aumentar a quantidade de dados de treinamento é uma maneira de reduzir o overfitting. Mas existem outras maneiras de reduzir a extensão de ocorrência do overfitting? Uma abordagem possível é reduzir o tamanho da nossa rede. No entanto, redes grandes têm o potencial de serem mais poderosas do que redes pequenas e essa é uma opção que só adotaríamos com relutância.


Felizmente, existem outras técnicas que podem reduzir o overfitting, mesmo quando temos uma rede de tamanho fixo e dados de treinamento em quantidade limitada. Essas técnicas são conhecidos como **técnicas de regularização**. Neste capítulo descrevemos uma das técnicas de regularização mais comumente usadas, uma técnica às vezes conhecida como decaimento de peso (weight decay) ou Regularização L2. A ideia da Regularização L2 é adicionar um termo extra à função de custo, um termo chamado termo de regularização. Aqui está a entropia cruzada regularizada:


 


![form](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/form.png)


Equação 1


 


O primeiro termo é apenas a expressão usual para a entropia cruzada. Mas adicionamos um segundo termo, a soma dos quadrados de todos os pesos da rede. Isto é escalonado por um fator λ / 2n, onde λ > 0 é conhecido como o parâmetro de regularização e **n** é, como de costume, o tamanho do nosso conjunto de treinamento. Vou discutir mais tarde como λ é escolhido. É importante notar também que o termo de regularização não inclui os vieses. Eu também voltarei a isso mais frente.


Claro, é possível regularizar outras funções de custo, como o custo quadrático. Isso pode ser feito de maneira semelhante:


 


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/form2.png)


Equação 2


 


Em ambos os casos, podemos escrever a função de custo regularizada como:


 


![form3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/form3.png)


Equação 3


 


onde C0 é a função de custo original e não regularizada.


Intuitivamente, o efeito da regularização é fazer com que a rede prefira aprender pequenos pesos, sendo todas as outras coisas iguais. Pesos grandes só serão permitidos se melhorarem consideravelmente a primeira parte da função de custo. Dito de outra forma, a regularização pode ser vista como uma forma de se comprometer entre encontrar pequenos pesos e minimizar a função de custo original. A importância relativa dos dois elementos do compromisso depende do valor de λ: quando λ é pequeno, preferimos minimizar a função de custo original, mas quando λ é grande, preferimos pesos pequenos.


Agora, não é de todo óbvio porque fazer este tipo de compromisso deve ajudar a reduzir o overfitting! Mas acontece que sim, reduz. Abordaremos a questão de porque isso ajuda na redução do overfitting no próximo capítulo, mas primeiro vamos trabalhar em um exemplo mostrando como a regularização reduz o overfitting.


Para construir um exemplo, primeiro precisamos descobrir como aplicar nosso algoritmo de aprendizado de [descida de gradiente estocástico](https://www.deeplearningbook.com.br/aprendizado-com-a-descida-do-gradiente/) em uma rede neural regularizada. Em particular, precisamos saber como calcular as derivadas parciais ∂C/∂w e ∂C/∂b para todos os pesos e vieses na rede. Tomando as derivadas parciais da Equação 3 acima, temos:


 


![form4](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/form4.png)


Equação 4


 


Os termos ∂C0/∂w e ∂C0/∂b podem ser calculados usando backpropagation, conforme descrito nos capítulos anteriores. E assim vemos que é fácil calcular o gradiente da função de custo regularizada, pois basta usar backpropagation, como de costume, e depois adicionar **(λ/n).w** à derivada parcial de todos os termos de peso. As derivadas parciais em relação aos vieses são inalteradas e, portanto, a regra de aprendizado de descida de gradiente para os vieses não muda da regra usual:


 


![form5](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/form5.png)


Equação 5


 


A regra de aprendizado para os pesos se torna:


 


![form6](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/form6.png)


Equação 6


 


Isto é exatamente o mesmo que a regra usual de aprendizado de descida de gradiente, exceto pelo fato de primeiro redimensionarmos o peso w por um fator 1 − (ηλ/n). Esse *reescalonamento* é, às vezes, chamado de redução de peso, uma vez que diminui os pesos. À primeira vista, parece que isso significa que os pesos estão sendo direcionados para zero, mas isso não é bem isso, uma vez que o outro termo pode levar os pesos a aumentar, se isso causar uma diminuição na função de custo não regularizada.


Ok, é assim que a descida de gradiente funciona. E quanto à descida de gradiente estocástica? Bem, assim como na descida de gradiente estocástica não-regularizada, podemos estimar ∂C0/∂w pela média de um mini-lote de m exemplos de treinamento. Assim, a regra de aprendizagem regularizada para a descida de gradiente estocástica torna-se:


 


![form7](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/form7.png)


Equação 7


 


onde a soma é sobre exemplos de treinamento x no mini-lote, e Cx é o custo (não-regularizado) para cada exemplo de treinamento. Isto é exatamente o mesmo que a regra usual para descida de gradiente estocástico, exceto pelo fator de decaimento de peso de 1 − (ηλ/n). Finalmente, e por completo, deixe-me declarar a regra de aprendizagem regularizada para os vieses. Isto é, naturalmente, exatamente o mesmo que no caso não regularizado:


 


![form8](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/form8.png)


Equação 8


 


onde a soma é sobre exemplos de treinamento x no mini-lote.


Vamos ver como a regularização altera o desempenho da nossa rede neural. Usaremos uma rede com 30 neurônios ocultos, um tamanho de mini-lote de 10, uma taxa de aprendizado de 0,5 e a função de custo de entropia cruzada. No entanto, desta vez vamos usar um parâmetro de regularização de λ = 0,1. Note que no código, usamos o nome da variável **lmbda**, porque **lambda** é uma palavra reservada em Python, com um significado não relacionado ao que estamos fazendo aqui (caso tenha dúvidas sobre as palavras reservadas em Python, acesse o [curso gratuito de Python](https://www.datascienceacademy.com.br/cursosgratuitos) em nosso portal).


Eu também usei o test\_data novamente, não o validation\_data. Estritamente falando, devemos usar o validation\_data, por todas as razões que discutimos anteriormente. Mas decidi usar o test\_data porque ele torna os resultados mais diretamente comparáveis com nossos resultados anteriores e não regularizados. Você pode facilmente alterar o código para usar o validation\_data e você verá que ele terá resultados semelhantes.


![python](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/python-1024x397.png)


O custo com os dados de treinamento diminui durante todo o tempo, da mesma forma que no caso anterior, não regularizado no [capítulo anterior](https://www.deeplearningbook.com.br/overfitting-e-regularizacao-parte-1/):


 


![regularized1](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/regularized1.png)


 


Mas desta vez a precisão no test\_data continua a aumentar durante as 400 épocas:


 


![regularized2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/regularized2.png)


 


Claramente, o uso da regularização suprimiu o overfitting. Além do mais, a precisão é consideravelmente maior, com uma precisão de classificação de pico de 87.1%, em comparação com o pico de 82.27% obtido no caso não regularizado. De fato, quase certamente poderíamos obter resultados consideravelmente melhores, continuando a treinar mais de 400 épocas. Parece que, empiricamente, a regularização está fazendo com que nossa rede generalize melhor e reduza consideravelmente os efeitos do overfitting.


O que acontece se sairmos do ambiente artificial de ter apenas 1.000 imagens de treinamento e retornar ao conjunto completo de treinamento de 50.000 imagens? É claro, já vimos que o overfitting é muito menos problemático com as 50.000 imagens. A regularização ajuda ainda mais? Vamos manter os hiperparâmetros iguais ao exemplo anterior – 30 épocas, taxa de aprendizado de 0,5, tamanho de mini-lote de 10. No entanto, precisamos modificar o parâmetro de regularização. A razão é porque o tamanho n do conjunto de treinamento mudou de n = 1.000 para n = 50.000, e isso muda o fator de decaimento de peso 1 − (ηλ/n). Se continuássemos a usar λ = 0,1, isso significaria muito menos perda de peso e, portanto, muito menos efeito de regularização. Nós compensamos mudando para λ = 5.0.


Ok, vamos treinar nossa rede, parando primeiro para reinicializar os pesos:


![python2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/python2-1024x185.png)


Obtemos os resultados:


![regularized_full](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/regularized_full.png)


Há muitas boas notícias aqui. Primeiro, nossa precisão de classificação nos dados de teste aumentou de 95.49%, quando não foi regularizada, para 96.49%. Isso é uma grande melhoria. Em segundo lugar, podemos ver que a diferença entre os resultados nos dados de treinamento e teste é muito menor do que antes, com um percentual abaixo de zero. Essa ainda é uma lacuna significativa, mas obviamente fizemos um progresso substancial para reduzir o overfitting.


Finalmente, vamos ver qual a precisão da classificação de teste que obtemos quando usamos 100 neurônios ocultos e um parâmetro de regularização de λ = 5.0. Eu não vou passar por uma análise detalhada de overfitting aqui, isso é puramente por diversão, só para ver a precisão que podemos obter quando usamos nossos novos truques: a função de custo de entropia cruzada e a Regularização L2.


![python3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/python3-1024x232.png)


O resultado final é uma precisão de classificação de 97.92% nos dados de validação. É um grande salto do caso dos 30 neurônios ocultos. Na verdade, ajustando um pouco mais, para executar por 60 épocas com η = 0.1 e λ = 5.0, quebramos a barreira de 98%, alcançando uma precisão de classificação de 98.04% nos dados de validação. Nada mal para o que acaba sendo 152 linhas de código!


Descrevi a regularização como uma forma de reduzir o overfitting e aumentar as precisões de classificação. Na verdade, esse não é o único benefício. Empiricamente, ao executar várias execuções de nossas redes com o dataset MNIST, mas com diferentes inicializações de peso (aleatórias), descobrimos que as execuções não-regularizadas ocasionalmente ficarão “presas”, aparentemente capturadas em mínimos locais da função de custo. O resultado é que diferentes execuções às vezes fornecem resultados bastante diferentes. Por outro lado, as execuções regularizadas forneceram resultados muito mais facilmente replicáveis.


Por que isso está acontecendo? Heuristicamente, se a função de custo for *desregularizada*, o comprimento do vetor de peso provavelmente crescerá, todas as outras coisas sendo iguais. Com o tempo, isso pode levar o vetor de peso a ser realmente muito grande. Isso pode fazer com que o vetor de peso fique preso apontando mais ou menos na mesma direção, já que as mudanças devido a descida do gradiente fazem apenas pequenas alterações na direção, quando o comprimento é longo. Acredito que esse fenômeno esteja dificultando o nosso algoritmo de aprendizado para explorar adequadamente o espaço de pesos e, consequentemente, mais difícil encontrar bons mínimos da função de custo.


Ainda não acabamos sobre regularização. Mais sobre isso no próximo capítulo! Até lá!


Referências:


[Dot Product](https://en.wikipedia.org/wiki/Dot_product)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


<div id="capitulo-21---afinal,-por-que-a-regularizacao-ajuda-a-reduzir-o-overfitting?"></div>

# Capítulo 21 – Afinal, Por Que a Regularização Ajuda a Reduzir o Overfitting?


Vimos no [capítulo anterior](https://www.deeplearningbook.com.br/overfitting-e-regularizacao-parte-2/) que a regularização ajuda a reduzir o overfitting. Isso é encorajador, mas, infelizmente, não é óbvio porque a regularização ajuda a resolver o overfitting! Uma história padrão que as pessoas contam para explicar o que está acontecendo segue mais ou menos esse raciocínio: pesos menores são, em certo sentido, de menor complexidade e, portanto, fornecem uma explicação mais simples e mais poderosa para os dados e devem, normalmente, ser preferidos. É uma história bastante concisa e contém vários elementos que talvez pareçam dúbios ou mistificadores. Vamos descompactar essa explicação e examiná-la criticamente. Afinal, Por Que a Regularização Ajuda a Reduzir o Overfitting?


Para fazer isso, vamos supor que temos um conjunto de dados simples para o qual desejamos construir um modelo:


![graph](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/graph-1024x672.png)


Implicitamente, estamos estudando algum fenômeno do mundo real aqui, com x e y representando dados desse fenômeno. Nosso objetivo é construir um modelo que nos permita prever y como uma função de x (isso é o que fazemos em [Machine Learning](https://www.datascienceacademy.com.br/course/machine-learning-engineer)). Poderíamos tentar usar redes neurais para construir esse modelo, mas vou fazer algo ainda mais simples: vou tentar modelar y como um polinômio em x. Estou fazendo isso em vez de usar redes neurais porque usar polinômios tornará as coisas particularmente transparentes. Uma vez que tenhamos entendido o caso polinomial, vamos traduzir para redes neurais.


Há dez pontos no gráfico acima, o que significa que podemos encontrar um único polinômio de 9ª ordem y = a0x9 + a1x8 +… + a9 que se ajusta exatamente aos dados. Aqui está o gráfico desse polinômio:


![graph2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/graph2-1024x698.png)


Isso fornece um ajuste exato. Mas também podemos obter um bom ajuste usando o modelo linear y = 2x:


![graph3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/graph3-1024x648.png)


Qual destes é o melhor modelo? E qual modelo é mais provável de generalizar bem a outros exemplos do mesmo fenômeno do mundo real?


Essas são questões difíceis. De fato, não podemos determinar com certeza a resposta para qualquer uma das perguntas acima, sem muito mais informações sobre o fenômeno do mundo real que estamos analisando (é onde entra a experiência do [Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) sobre áreas de negócio). Mas vamos considerar duas possibilidades: (1) o polinômio de 9ª ordem é, de fato, o modelo que realmente descreve o fenômeno do mundo real, e o modelo, portanto, generalizará perfeitamente; (2) o modelo correto é y = 2x, mas há um pequeno ruído adicional devido a, digamos, erros de medição, e é por isso que o modelo não é um ajuste exato.


Não é possível a priori dizer qual dessas duas possibilidades está correta (ou, na verdade, se alguma terceira possibilidade é válida). Logicamente, qualquer uma poderia ser verdade. E não é uma diferença trivial. É verdade que nos dados fornecidos há apenas uma pequena diferença entre os dois modelos. Mas suponha que queremos predizer o valor de y correspondendo a um grande valor de x, muito maior do que qualquer um mostrado nos gráficos acima. Se tentarmos fazer isso, haverá uma diferença dramática entre as previsões dos dois modelos, já que o modelo polinomial de 9ª ordem passa a ser dominado pelo termo x9, enquanto o modelo linear permanece, bem, linear.


Um ponto de vista é dizer que, na ciência, devemos seguir a explicação mais simples, a menos que sejamos obrigados a fazer o contrário. Quando encontramos um modelo simples que parece explicar muitos dados, somos tentados a gritar “Eureka!” Afinal, parece improvável que uma explicação simples ocorra apenas por coincidência. Em vez disso, suspeitamos que o modelo deve estar expressando alguma verdade subjacente sobre o fenômeno. No caso em questão, o modelo y = 2x + ruído parece muito mais simples que y = a0x9 + a1x8 +…. Seria surpreendente se essa simplicidade tivesse ocorrido por acaso, e então suspeitamos que y = 2x + ruído expressa alguma verdade subjacente. Nesse ponto de vista, o modelo de 9ª ordem está realmente aprendendo apenas os efeitos do ruído local. E assim, enquanto o modelo de 9ª ordem funciona perfeitamente para esses pontos de dados particulares, o modelo não conseguirá generalizar para outros pontos de dados, e o modelo linear terá maior poder preditivo.


Vamos ver o que esse ponto de vista significa para redes neurais. Suponha que nossa rede tenha, na maioria das vezes, pequenos pesos, como tenderá a acontecer em uma rede regularizada. O tamanho menor dos pesos significa que o comportamento da rede não mudará muito se alterarmos algumas entradas aleatórias aqui e ali. Isso dificulta que uma rede regularizada aprenda os efeitos do ruído local nos dados. Pense nisso como uma maneira de fazer com que as evidências não importem muito para a saída da rede. Em vez disso, uma rede regularizada aprende a responder a tipos de evidências que são vistas com frequência em todo o conjunto de treinamento. Por outro lado, uma rede com grandes pesos pode alterar bastante seu comportamento em resposta a pequenas alterações na entrada. Assim, uma rede não regularizada pode usar grandes pesos para aprender um modelo complexo que contém muitas informações sobre o ruído nos dados de treinamento. Em suma, as redes regularizadas são levadas a construir modelos relativamente simples baseados em padrões vistos frequentemente nos dados de treinamento e são resistentes às peculiaridades de aprendizagem do ruído nos dados de treinamento. A esperança é que isso forçará nossas redes a aprender de verdade sobre o fenômeno em questão e a generalizar melhor o que aprendem.


Com isso dito, e mantendo a necessidade de cautela em mente, é um fato empírico que as redes neurais regularizadas geralmente generalizam melhor do que as redes não regularizadas. A verdade é que ninguém ainda desenvolveu uma explicação teórica inteiramente convincente para explicar porque a regularização ajuda a generalizar as redes. De fato, os pesquisadores continuam a escrever artigos nos quais tentam abordagens diferentes à regularização, comparam-nas para ver qual funciona melhor e tentam entender por que diferentes abordagens funcionam melhor ou pior. Embora muitas vezes ajude, não temos uma compreensão sistemática inteiramente satisfatória do que está acontecendo, apenas heurísticas incompletas e regras gerais.


Há um conjunto mais profundo de questões aqui, questões que vão para o coração da ciência. É a questão de como generalizamos. A regularização pode nos dar uma varinha mágica computacional que ajuda nossas redes a generalizar melhor, mas não nos dá uma compreensão baseada em princípios de como a generalização funciona, nem de qual é a melhor abordagem.


Isso é particularmente irritante porque na vida cotidiana, nós humanos generalizamos bem. Mostradas apenas algumas imagens de um elefante, uma criança aprenderá rapidamente a reconhecer outros elefantes. É claro que eles podem ocasionalmente cometer erros, talvez confundindo um rinoceronte com um elefante, mas em geral esse processo funciona notavelmente com precisão. Então nós temos um sistema – o cérebro humano – com um grande número de parâmetros livres. E depois de ser mostrado apenas uma ou algumas imagens de treinamento, o sistema aprende a generalizar para outras imagens. Nossos cérebros estão, em certo sentido, se regularizando incrivelmente bem! Como fazemos isso? Neste ponto não sabemos. Espero que nos próximos anos desenvolvamos técnicas mais poderosas de regularização em redes neurais artificiais, técnicas que permitirão que as redes neurais generalizem bem, mesmo a partir de pequenos conjuntos de dados.


De fato, nossas redes já generalizam melhor do que se poderia esperar a priori. Uma rede com 100 neurônios ocultos tem quase 80.000 parâmetros. Temos apenas 50.000 imagens em nossos dados de treinamento. É como tentar encaixar um polinômio de grau 80.000 em 50.000 pontos de dados. Consequentemente, nossa rede deve se ajustar muito bem. E, no entanto, como vimos anteriormente, essa rede realmente faz um ótimo trabalho generalizando. Por que esse é o caso? Não é bem entendido. Foi conjecturado que “a dinâmica do aprendizado de gradiente descendente em redes multicamadas tem um efeito de ‘autorregulação'”. Isso é excepcionalmente bom, mas também é um tanto inquietante que não entendemos porque exatamente isso ocorre e por isso muitas vezes modelos de redes neurais profundas são chamados de “caixa preta”. Enquanto isso, adotaremos a abordagem pragmática e usaremos a regularização sempre que pudermos. Nossas redes neurais serão melhores assim.


Deixe-me concluir esta seção voltando a um detalhe que deixei inexplicado antes: o fato de que a regularização L2 não restringe os vieses. É claro que seria fácil modificar o procedimento de regularização para regularizar os vieses. Empiricamente, fazendo isso muitas vezes não muda muito os resultados, então, em certa medida, é apenas uma convenção se regularizar os vieses ou não. No entanto, vale a pena notar que ter um grande viés não torna um neurônio sensível às suas entradas da mesma maneira que ter pesos grandes. Portanto, não precisamos nos preocupar com grandes vieses que permitem que nossa rede aprenda o ruído em nossos dados de treinamento. Ao mesmo tempo, permitir grandes vieses dá às nossas redes mais flexibilidade no comportamento – em particular, grandes vieses facilitam a saturação dos neurônios, o que às vezes é desejável. Por essas razões, geralmente não incluímos termos de viés quando regularizamos a rede neural.


Você já percebeu que regularização é um assunto importante quando tratamos de redes neurais. Nos próximos capítulos estudaremos mais duas técnicas de regularização: Regularização L1 e Dropout! Não perca!


Referências:


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


<div id="capitulo-22---regularizacao-l1"></div>

# Capítulo 22 – Regularização L1


Existem muitas técnicas de regularização além da Regularização L2 que vimos no [capítulo anterior](https://www.deeplearningbook.com.br/afinal-por-que-a-regularizacao-ajuda-a-reduzir-o-overfitting/). De fato, tantas técnicas foram desenvolvidas que é difícil resumir todas elas. Neste e nos próximos dois capítulos, vamos descrever brevemente três outras abordagens para reduzir o overfitting: Regularização L1, Dropout e aumento artificial do tamanho do conjunto de treinamento. Não aprofundaremos tanto nessas técnicas como fizemos com a Regularização L2. Em vez disso, o objetivo é familiarizar você com as ideias principais e apreciar a diversidade de técnicas de regularização disponíveis.


Regularização L1
----------------


Nesta abordagem, modificamos a função de custo não regularizada, adicionando a soma dos valores absolutos dos pesos:


 


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/form1.png)


Equação 1


 


Intuitivamente, isso é semelhante à Regularização L2, penalizando grandes pesos e tendendo a fazer com que a rede prefira pequenos pesos. Naturalmente, o termo de Regularização L1 não é o mesmo que o termo de Regularização L2 e, portanto, não devemos esperar obter exatamente o mesmo comportamento. Vamos tentar entender como o comportamento de uma rede treinada usando a Regularização L1 difere de uma rede treinada usando a Regularização L2.


Para fazer isso, vejamos as derivadas parciais da função de custo. A partir da fórmula anterior obtemos:


 


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/form2-1.png)


Equação 2


 


onde sgn(w) é o sinal de w, isto é, +1 se w é positivo e −1 se w é negativo. Usando essa expressão, podemos facilmente modificar a retropropagação (backpropagation) para fazer a descida de gradiente estocástica usando a Regularização L1. A regra de atualização resultante para uma rede regularizada L1 é:


 


![form3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/form3-1.png)


Equação 3 – Regra de atualização L1


 


onde, como de costume, podemos estimar ∂C0/∂w usando uma média de mini-lote, se desejarmos. Compare isso com a regra de atualização para a Regularização L2:


 


![form4](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/form4-1.png)


Equação 4 – Regra de atualização L2


 


Em ambas as expressões, o efeito da regularização é diminuir os pesos. Isso está de acordo com a nossa intuição de que ambos os tipos de regularização penalizam grandes pesos. Mas a maneira como os pesos diminuem é diferente. Na Regularização L1, os pesos diminuem em uma quantidade constante para 0. Na Regularização L2, os pesos diminuem em um valor proporcional a w. E assim, quando um peso específico tem uma grande magnitude, a Regularização L1 reduz o peso muito menos do que a Regularização L2. Em contraste, quando |w| é pequena, a Regularização L1 reduz o peso muito mais do que a Regularização L2. O resultado é que a Regularização L1 tende a concentrar o peso da rede em um número relativamente pequeno de conexões de alta importância, enquanto os outros pesos são direcionados para zero.


Mas há ainda um pequeno detalhe na discussão acima. A derivada parcial ∂C/∂w não é definida quando w = 0. A razão é que a função |w| tem um “canto” agudo em w = 0 e, portanto, não é diferenciável nesse ponto. Tudo bem, no entanto. O que faremos é aplicar a regra usual (não regularizada) para descida de gradiente estocástica quando w = 0. Isso ajuda a resolver a questão – intuitivamente, o efeito da regularização é diminuir os pesos e, obviamente, não pode reduzir um peso que já é 0. Para colocá-lo com mais precisão, usaremos as Equações (2) e (3) com a convenção que sgn(0) = 0. Isso dá uma regra legal e compacta para se fazer uma descida gradiente estocástica com Regularização L1.


Agora vamos para o Dropout, no próximo capítulo!


Referências:


[Formação Engenheiro de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


<div id="capitulo-23---como-funciona-o-dropout?"></div>

# Capítulo 23 – Como Funciona o Dropout?


Dropout é uma técnica radicalmente diferente para regularização. Ao contrário da Regularização L1 e L2, o Dropout não depende da modificação da função de custo. Em vez disso, no Dropout, modificamos a própria rede. Deixe-me descrever a mecânica básica de **Como Funciona o Dropout?** antes de entender porque ele funciona e quais são os resultados. Suponha que estamos tentando treinar uma rede neural:


 


![rede](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/rede.png)


 


Em particular, suponha que tenhamos uma entrada de treinamento x e a saída desejada correspondente y. Normalmente, nós treinamos pela propagação direta de x através da rede, e depois retrocedemos (retropropagação) para determinar a contribuição do erro para o gradiente. Com o Dropout, esse processo é modificado. Começamos por eliminar aleatoriamente (e temporariamente) alguns dos neurônios ocultos na rede, deixando os neurônios de entrada e saída intocados. Depois de fazer isso, terminaremos com uma rede da seguinte forma (observe as linhas tracejadas na figura abaixo). Note os neurônios que foram temporariamente eliminados:


 


![rede2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/07/rede2.png)


 


Nós encaminhamos para frente a entrada x através da rede modificada, e depois retropropagamos o resultado, também através da rede modificada. Depois de fazer isso em um mini-lote de exemplos, atualizamos os pesos e vieses apropriados. Em seguida, repetimos o processo, primeiro restaurando os neurônios removidos, depois escolhendo um novo subconjunto aleatório de neurônios ocultos para excluir, estimando o gradiente para um mini-lote diferente e atualizando os pesos e vieses na rede.


Ao repetir esse processo várias vezes, nossa rede aprenderá um conjunto de pesos e vieses. Naturalmente, esses pesos e vieses terão sido aprendidos sob condições em que parte dos neurônios ocultos foram descartados. Quando realmente executamos a rede completa, isso significa que mais neurônios ocultos estarão ativos. Para compensar isso, reduzimos pela metade os pesos que saem dos neurônios ocultos.


Esse procedimento de desistência pode parecer estranho e ad-hoc. Por que esperamos que ajude com a regularização? Para explicar o que está acontecendo, gostaria que você parasse brevemente de pensar sobre o Dropout e, em vez disso, imagine o treinamento de redes neurais no modo padrão (sem Dropout). Em particular, imagine que treinamos várias redes neurais diferentes, todas usando os mesmos dados de treinamento. 


É claro que as redes podem não começar idênticas e, como resultado, após o treinamento, elas podem, às vezes, dar resultados diferentes. Quando isso acontece, podemos usar algum tipo de esquema de média ou votação para decidir qual saída aceitar. Por exemplo, se nós treinamos cinco redes, e três delas estão classificando um dígito como um “3”, então provavelmente é um “3”. As outras duas redes provavelmente estão cometendo um erro. Este tipo de esquema de média é frequentemente encontrado como uma maneira poderosa (embora requeira mais capacidade computacional) de reduzir o overfitting. A razão é que as diferentes redes podem se sobrepor de diferentes maneiras e a média pode ajudar a eliminar esse tipo de overfitting.


O que isso tem a ver com o Dropout? Heuristicamente, quando abandonamos diferentes conjuntos de neurônios, é como se estivéssemos treinando redes neurais diferentes. E assim, o procedimento de eliminação é como calcular a média dos efeitos de um grande número de redes diferentes. As diferentes redes se adaptarão de diferentes maneiras, e assim, esperançosamente, o efeito líquido do Dropout será reduzir o overfitting.


Uma explicação heurística relacionada ao Dropout é dada em um dos primeiros artigos a usar a técnica: “Esta técnica reduz co-adaptações complexas de neurônios, já que um neurônio não pode confiar na presença de outros neurônios em particular. É, portanto, forçado a aprenda recursos mais robustos que são úteis em conjunto com muitos subconjuntos aleatórios diferentes dos outros neurônios”. Em outras palavras, se pensarmos em nossa rede como um modelo que está fazendo previsões, então podemos pensar no Dropout como uma forma de garantir que o modelo seja robusto para a perda de qualquer evidência individual. Nesse ponto, é um pouco semelhante à Regularização L1 e L2, que tendem a reduzir os pesos e, assim, tornar a rede mais robusta para perder qualquer conexão individual na rede.


Naturalmente, a verdadeira medida do Dropout é que ele foi muito bem sucedido em melhorar o desempenho das redes neurais. O [artigo original](https://arxiv.org/pdf/1207.0580.pdf), introduzindo a técnica, aplicou-a a muitas tarefas diferentes. Para nós, é de particular interesse que eles aplicaram o Dropout na classificação de dígitos MNIST, usando uma rede neural feedforward “vanilla” ao longo de linhas similares àquelas que estamos considerando. O documento observou que o melhor resultado que alguém alcançou até aquele ponto usando tal arquitetura foi a precisão de classificação de 98,4% no conjunto de testes. Eles melhoraram isso para 98,7% de precisão usando uma combinação de Dropout e uma forma modificada de Regularização L2. Da mesma forma, resultados impressionantes foram obtidos para muitas outras tarefas, incluindo problemas de reconhecimento de imagem e fala e processamento de linguagem natural. O Dropout tem sido especialmente útil no treinamento de redes grandes e profundas, nas quais o problema do overfitting é frequentemente agudo.


Até o próximo capítulo!


Referências:


[Formação Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


[ImageNet Classification with Deep Convolutional Neural Networks](https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf)


[Improving neural networks by preventing co-adaptation of feature detectors](https://arxiv.org/pdf/1207.0580.pdf)


<div id="capitulo-24---expandir-artificialmente-os-dados-de-treinamento"></div>

# Capítulo 24 – Expandir Artificialmente os Dados de Treinamento


Vimos [anteriormente](https://www.deeplearningbook.com.br/algoritmo-backpropagation-parte-2-treinamento-de-redes-neurais/) que a precisão da classificação com o dataset MNIST caiu para porcentagens em torno de 80%, quando usamos apenas 1.000 imagens de treinamento. Não é de surpreender que isso aconteça, uma vez que menos dados de treinamento significam que nossa rede será exposta a menos variações na forma como os seres humanos escrevem dígitos. Vamos tentar treinar nossa rede de 30 neurônios ocultos com uma variedade de diferentes tamanhos de conjuntos de dados de treinamento, para ver como o desempenho varia. 


Nós treinaremos usando um tamanho de mini-lote de 10, uma taxa de aprendizado η = 0,5, um parâmetro de regularização λ = 5.0 e a função de custo de entropia cruzada. Treinaremos por 30 épocas quando o conjunto completo de dados de treinamento for usado e aumentaremos o número de épocas proporcionalmente quando conjuntos de treinamento menores forem usados. Para garantir que o fator de decaimento do peso (weight decay factor) permaneça o mesmo nos conjuntos de treinamento, usaremos um parâmetro de regularização de λ = 5.0 quando o conjunto de dados de treinamento completo for usado, e reduziremos proporcionalmente quando conjuntos de treinamento menores forem usados. Observe esse gráfico:


 


![more_data](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/more_data.png)


 


Como você pode ver analisando o gráfico acima, as precisões de classificação melhoram consideravelmente à medida que usamos mais dados de treinamento. Presumivelmente, essa melhoria continuaria se houvesse mais dados disponíveis. É claro que, olhando para o gráfico acima, parece que estamos chegando perto da saturação. Suponha, no entanto, que refizemos o gráfico com o tamanho do conjunto de treinamento plotado logaritmicamente:


 


![more_data_log](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/more_data_log.png)


 


Parece claro que o gráfico ainda está subindo em direção aos 100% de precisão. Isso sugere que, se usássemos muito mais dados de treinamento – digamos, milhões ou até bilhões de amostras de dígitos manuscritos, em vez de apenas 50.000, provavelmente teríamos um desempenho consideravelmente melhor, mesmo nessa rede muito pequena.


Obter mais dados de treinamento é uma ótima ideia. Infelizmente, pode ser caro e nem sempre é possível na prática. No entanto, há outra técnica que pode funcionar quase tão bem, que é expandir artificialmente os dados de treinamento. Suponha, por exemplo, que tomemos uma imagem de treinamento MNIST, o dígito 5:


 


![more_data_5](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/more_data_5-150x150.png)


 


e rotacionamos por um pequeno ângulo, digamos 15 graus:


 


![more_data_rotated_5](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/more_data_rotated_5-150x150.png)


 


Ainda é reconhecivelmente o mesmo dígito. E ainda no nível do pixel é bem diferente de qualquer imagem atualmente nos dados de treinamento MNIST. É possível que adicionar essa imagem aos dados de treinamento possa ajudar nossa rede a aprender mais sobre como classificar os dígitos. Além do mais, obviamente, não estamos limitados a adicionar apenas uma imagem. Podemos expandir nossos dados de treinamento fazendo muitas rotações pequenas de todas as imagens de treinamento MNIST e, em seguida, usando os dados de treinamento expandidos para melhorar o desempenho de nossa rede.


Essa técnica é muito poderosa e tem sido amplamente usada. Vejamos alguns dos resultados de um [artigo](https://ieeexplore.ieee.org/document/1227801/) que aplicou diversas variações da técnica ao MNIST. Uma das arquiteturas de redes neurais que eles consideraram foi similar às que estamos usando, uma rede feedforward com 800 neurônios ocultos e usando a função de custo de entropia cruzada. Executando a rede com os dados de treinamento MNIST padrão, eles obtiveram uma precisão de classificação de 98,4% em seu conjunto de testes. Eles então expandiram os dados de treinamento, usando não apenas rotações, como descrevi acima, mas também traduzindo e distorcendo as imagens. Ao treinar no conjunto de dados expandido, aumentaram a precisão de sua rede para 98,9%. 


Eles também experimentaram o que chamaram de “distorções elásticas”, um tipo especial de distorção de imagem destinada a emular as oscilações aleatórias encontradas nos músculos da mão. Usando as distorções elásticas para expandir os dados, eles alcançaram uma precisão ainda maior, 99,3%. Efetivamente, eles estavam ampliando a experiência de sua rede, expondo-a ao tipo de variações encontradas na caligrafia real. Caso queira aprender sobre estas técnicas, elas são estudadas em detalhes em [Análise de Imagens com Inteligência Artificial](https://www.datascienceacademy.com.br/course/analise-de-imagens-com-inteligencia-artificial).


Variações sobre essa técnica podem ser usadas para melhorar o desempenho em muitas tarefas de aprendizado, não apenas no reconhecimento de manuscrito. O princípio geral é expandir os dados de treinamento aplicando operações que reflitam a variação do mundo real. Não é difícil pensar em maneiras de fazer isso. Suponha, por exemplo, que você esteja construindo uma rede neural para fazer o reconhecimento de fala. Nós humanos podemos reconhecer a fala mesmo na presença de distorções como ruído de fundo e assim você pode expandir seus dados adicionando ruído de fundo. Também podemos reconhecer a fala se ela estiver acelerada ou desacelerada. Então, essa é outra maneira de expandir os dados de treinamento. Essas técnicas nem sempre são usadas – por exemplo, em vez de expandir os dados de treinamento adicionando ruído, pode ser mais eficiente limpar a entrada para a rede aplicando primeiro um filtro de redução de ruído. Ainda assim, vale a pena manter a ideia de expandir os dados de treinamento e buscar oportunidades para aplicar a técnica.


Agora você compreende melhor o poder do [Big Data](https://www.datascienceacademy.com.br/cursosgratuitos), pois com mais dados, em maior variedade e gerados em alta velocidade, conseguimos chegar a resultados nunca antes vistos em Inteligência Artificial. Vamos ver novamente como a precisão da nossa rede neural varia com o tamanho do conjunto de treinamento:


 


![more_data_log2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/more_data_log2.png)


 


Suponha que, em vez de usar uma rede neural, usemos alguma outra técnica de aprendizado de máquina para classificar os dígitos. Por exemplo, vamos tentar usar as máquinas de vetores de suporte (SVMs). Não se preocupe se você não estiver familiarizado com SVMs, não precisamos entender seus detalhes (caso queira aprender sobre SVMs, elas são estudadas em detalhes em [Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-machine-learning)). Vamos usar o SVM fornecido pela biblioteca scikit-learn. Veja como o desempenho do SVM varia em função do tamanho do conjunto de treinamento. Eu tracei os resultados da rede neural também, para facilitar a comparação:


 


![more_data_comparison](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/more_data_comparison.png)


 


Provavelmente, a primeira coisa que chama a atenção sobre esse gráfico é que nossa rede neural supera o SVM para cada tamanho de conjunto de treinamento. Isso é bom, embora tenhamos usado as configurações prontas do SVM do scikit-learn, enquanto fizemos um bom trabalho customizando nossa rede neural. Um fato sutil, porém interessante, sobre o gráfico é que, se treinarmos o SVM usando 50.000 imagens, ele terá melhor desempenho (94,48% de precisão) do que a nossa rede neural quando treinado usando 5.000 imagens (precisão de 93,24%). **Em outras palavras, mais dados de treinamento podem, às vezes, compensar diferenças no algoritmo de aprendizado de máquina usado**.


Algo ainda mais interessante pode ocorrer. Suponha que estamos tentando resolver um problema usando dois algoritmos de aprendizado de máquina, algoritmo A e algoritmo B. Às vezes acontece que o algoritmo A superará o algoritmo B com um conjunto de dados de treinamento, enquanto o algoritmo B superará o algoritmo A com um conjunto diferente de dados de treinamento. Não vemos isso acima – seria necessário que os dois gráficos se cruzassem – mas a resposta correta à pergunta “O algoritmo A é melhor que o algoritmo B?” seria: “Qual o tamanho do conjunto de dados de treinamento que você está usando?”


Tudo isso é uma precaução a ter em mente, tanto ao fazer o desenvolvimento quanto ao ler artigos de pesquisa. Muitos artigos concentram-se em encontrar novos truques para obter melhor desempenho em conjuntos de dados de referência padrão. “Nossa técnica XPTO nos deu uma melhoria de X por cento no benchmark padrão Y” é uma forma canônica de alegação de pesquisa. Tais alegações são, com frequência, genuinamente interessantes, mas devem ser entendidas como aplicáveis ​​apenas no contexto do conjunto de dados de treinamento específico usado. Imagine uma história alternativa na qual as pessoas que originalmente criaram o conjunto de dados de referência tinham uma concessão de pesquisa maior. Eles podem ter usado o dinheiro extra para coletar mais dados de treinamento. É perfeitamente possível que o “aprimoramento” devido à técnica de “XPTO” desapareça em um conjunto maior de dados. Em outras palavras, a suposta melhoria pode ser apenas um acidente da história. 


A mensagem a ser retirada, especialmente em aplicações práticas, é que o que queremos é melhores algoritmos e melhores dados de treinamento. Não há problema em procurar algoritmos melhores, mas certifique-se de não estar se concentrando apenas em melhores algoritmos, excluindo a busca por mais ou melhores dados de treinamento.


Com isso concluímos nosso mergulho no overfitting e na regularização. Claro, voltaremos novamente ao assunto. Como já mencionamos várias vezes, o overfitting é um grande problema nas redes neurais, especialmente à medida que os computadores se tornam mais poderosos e temos a capacidade de treinar redes maiores. Como resultado, há uma necessidade premente de desenvolver técnicas poderosas de regularização para reduzir o overfitting, e esta é uma área extremamente ativa de pesquisa.


No próximo capítulo vamos tratar de um outro importante assunto: a inicialização de pesos. Até lá.


Referências:


[Formação Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Best practices for convolutional neural networks applied to visual document analysis](https://ieeexplore.ieee.org/document/1227801/)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Scaling to very very large corpora for natural language disambiguation](https://dl.acm.org/citation.cfm?doid=1073012.1073017)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Understanding Activation Functions in Neural Networks](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0)


[Redes Neurais, princípios e práticas](https://www.amazon.com.br/Redes-Neurais-Princ%C3%ADpios-e-Pr%C3%A1tica-ebook/dp/B073QSG69Y/ref=tmm_kin_swatch_0?_encoding=UTF8&qid=1516302804&sr=1-1)


[ImageNet Classification with Deep Convolutional Neural Networks](https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf)


[Improving neural networks by preventing co-adaptation of feature detectors](https://arxiv.org/pdf/1207.0580.pdf)


<div id="capitulo-25---inicializacao-de-pesos-em-redes-neurais-artificiais"></div>

# Capítulo 25 – Inicialização de Pesos em Redes Neurais Artificiais


Quando criamos nossas redes neurais, temos que fazer escolhas para os valores iniciais de pesos e vieses (bias). Até agora, nós os escolhemos de acordo com uma prescrição que discutimos nos [capítulos anteriores](https://www.deeplearningbook.com.br/construindo-uma-rede-neural-com-linguagem-python/). 


Só para lembrar, a prescrição era escolher tanto os pesos quanto os vieses usando variáveis aleatórias Gaussianas independentes, normalizadas para ter a média 0 e desvio padrão 1 (esse é um conceito fundamental em Estatística e caso queira adquirir conhecimento em Estatística na prática através de projetos, acesse aqui: [Formação Análise Estatística](https://www.datascienceacademy.com.br/bundle/formacao-analise-estatistica).


Embora esta abordagem tenha funcionado bem, foi bastante *ad-hoc*, e vale a pena revisitar para ver se podemos encontrar uma maneira melhor de definir nossos pesos e vieses iniciais, e talvez ajudar nossas redes neurais a aprender mais rápido. É o que iremos estudar neste capítulo.


Para começar, vamos compreender porque podemos fazer um pouco melhor do que inicializar pesos e vieses com valores Gaussianos normalizados. Para ver porque, suponha que estamos trabalhando com uma rede com um grande número – digamos 1.000 – de neurônios de entrada. E vamos supor que usamos valores Gaussianos normalizados para inicializar os pesos conectados à primeira camada oculta. Por enquanto, vou me concentrar especificamente nos pesos que conectam os neurônios de entrada ao primeiro neurônio na camada oculta e ignorar o restante da rede:


 


![rede](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/rede-1.png)


 


Vamos supor, por simplicidade, que estamos tentando treinar usando uma entrada de treinamento x na qual metade dos neurônios de entrada estão ativados, isto é, configurados para 1, e metade dos neurônios de entrada estão desligados, ou seja, ajustados para 0. O argumento a seguir aplica-se de forma mais geral, mas você obterá a essência deste caso especial. Vamos considerar a soma ponderada **z = ∑jwjxj + b** de entradas para nosso neurônio oculto. Ocorre que 500 termos nesta soma desaparecem, porque a entrada correspondente xj é zero e, assim, z é uma soma sobre um total de 501 variáveis aleatórias Gaussianas normalizadas, representando os 500 termos de peso e o termo extra de viés (bias). Logo, z é ele próprio uma distribuição Gaussiana com média zero e desvio padrão ≈ 22.4 (raiz quadrada de 501). Ou seja, z tem uma distribuição Gaussiana muito ampla, sem um pico agudo, conforme a figura abaixo:


 


![rede2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/rede2.png)


 


Em particular, podemos ver neste gráfico que é bem provável que | z | será bastante grande, isto é, z > 1 ou z < -1. Se for esse o caso, a saída σ(z) do neurônio oculto estará muito próxima de 1 ou 0. Isso significa que nosso neurônio oculto terá saturado. E quando isso acontece, como sabemos, fazer pequenas mudanças nos pesos fará apenas mudanças absolutamente minúsculas na ativação de nosso neurônio oculto. Essa mudança minúscula na ativação do neurônio oculto, por sua vez, dificilmente afetará o resto dos neurônios na rede, e veremos uma mudança minúscula correspondente na função de custo. 


Como resultado, esses pesos só aprenderão muito lentamente quando usarmos o algoritmo de descida do gradiente. É semelhante ao problema que discutimos anteriormente em outros capítulos, no qual os neurônios de saída que saturaram o valor errado fizeram com que o aprendizado diminuísse. Abordamos esse problema anterior com uma escolha inteligente de função de custo. Infelizmente, enquanto isso ajudou com os neurônios de **saída** saturados, ele não faz nada pelo problema dos neurônios **ocultos** saturados.


Temos falado sobre a entrada de pesos para a primeira camada oculta. Naturalmente, argumentos semelhantes aplicam-se também a camadas ocultas posteriores: se os pesos em camadas ocultas posteriores forem inicializados usando Gaussianos normalizados, então as ativações estarão frequentemente muito próximas de 0 ou 1, e o aprendizado prosseguirá muito lentamente.


Existe alguma maneira de escolhermos melhores inicializações para os pesos e vieses, para que não tenhamos esse tipo de saturação e, assim, evitar uma desaceleração na aprendizagem? Suponha que tenhamos um neurônio com pesos de entrada **nin**. Então, inicializaremos esses pesos como variáveis ​​aleatórias gaussianas com média 0 e desvio padrão:


 


![form](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/form.png)


 


Isto é, vamos “esmagar os gaussianos”, tornando menos provável que nosso neurônio seja saturado. Continuaremos a escolher o viés como um Gaussiano com média 0 e desvio padrão 1, por motivos pelos quais voltaremos daqui a pouco. Com essas escolhas, a soma ponderada **z = ∑jwjxj + b** será novamente uma variável aleatória Gaussiana com média 0, mas será muito mais aguda que antes. Suponha, como fizemos anteriormente, que 500 das entradas são zero e 500 são 1. Então é fácil mostrar (veja o gráfico abaixo) que z tem uma distribuição Gaussiana com média 0 e desvio padrão igual a 1,22…(raiz quadrada de 3/2). Isso é muito mais agudo do que antes, tanto que até o gráfico abaixo subestima a situação, já que precisamos redimensionar o eixo vertical, quando comparado ao gráfico anterior:


 


![rede3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/rede3.png)


 


É muito menos provável que tal neurônio sature e, correspondentemente, é muito menos provável que tenha problemas com a lentidão do aprendizado.


Eu afirmei acima que nós continuaremos a inicializar os vieses como antes, como variáveis ​​aleatórias Gaussianas com uma média de 0 e um desvio padrão de 1. Isto não tem problema, pois é pouco provável que nossos neurônios vão saturar. Na verdade, não importa muito como inicializamos os vieses, desde que evitemos o problema com a saturação dos neurônios. Algumas pessoas vão tão longe a ponto de inicializar todos os vieses com 0, e dependem da descida de gradiente para aprender vieses apropriados. Mas como é improvável que faça muita diferença, continuaremos com o mesmo procedimento de inicialização de antes.


Vamos comparar os resultados para as nossas abordagens antiga e nova para inicialização de peso, usando a tarefa de classificação de dígitos MNIST. Como antes, usaremos 30 neurônios ocultos, um tamanho de mini-lote de 10, um parâmetro de regularização λ = 5.0 e a função de custo de entropia cruzada. Diminuiremos ligeiramente a taxa de aprendizado de η = 0,5 para 0,1, pois isso torna os resultados um pouco mais visíveis nos gráficos. Podemos treinar usando o antigo método de inicialização de peso (você pode baixar os arquivos [aqui](https://drive.google.com/file/d/1esmcuW-aluCZTwS-Yjh1x-uijX8DHK62/view)):


 


![rede4](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/rede4.png)


 


Também podemos treinar usando a nova abordagem para inicializar o peso. Na verdade, isso é ainda mais fácil, já que a maneira padrão de inicializar os pesos da rede2 é usar essa nova abordagem. Isso significa que podemos omitir a chamada net.large\_weight\_initializer () acima:


 


![rede5](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/rede5.png)


 


Plotando os resultados, obtemos:


 


![rede6](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/rede6.png)


 


Em ambos os casos, acabamos com uma precisão de classificação um pouco acima de 96%. A precisão final da classificação é quase exatamente a mesma nos dois casos, mas a nova técnica de inicialização é muito, muito mais rápida. No final da primeira época de treinamento, a antiga abordagem de inicialização de peso tem uma precisão de classificação abaixo de 87%, enquanto a nova abordagem já chega a quase 93%. O que parece estar acontecendo é que nossa nova abordagem para a inicialização do peso nos leva a um processo muito melhor, o que nos permite obter bons resultados muito mais rapidamente. O mesmo fenômeno também é visto se traçarmos resultados com 100 neurônios ocultos:


 


![rede7](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/rede7.png)


 


Neste caso, as duas curvas não se encontram. No entanto, nossas experiências sugerem que, com apenas mais algumas épocas de treinamento (não mostradas), as precisões se tornam quase exatamente as mesmas. Portanto, com base nesses experimentos, parece que a inicialização do peso aprimorado apenas acelera o aprendizado, não altera o desempenho final de nossas redes. No entanto, veremos mais a frente alguns exemplos de redes neurais em que o comportamento de longo prazo é significativamente melhor com a inicialização de peso usando:


 


![form](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/form.png)


 


Assim, não é apenas a velocidade de aprendizado que é melhorada, mas também o desempenho final.


A abordagem acima para a inicialização do peso ajuda a melhorar a maneira como nossas redes neurais aprendem. Outras técnicas para inicialização de peso também foram propostas, muitas baseadas nessa ideia básica. Não vamos rever as outras abordagens aqui, já que a descrita anteriormente funciona bem o suficiente para nossos propósitos. Se você estiver interessado em pesquisar mais, recomendamos a leitura das páginas 14 e 15 de um artigo de 2012 de Yoshua Bengio (um dos padrinhos do Deep Learning), bem como as referências nele contidas: [Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf). 


Para aplicar esses conceitos na prática com Linguagem Python, acesse aqui: [Deep Learning Para Aplicações de IA com PyTorch e Lightning](https://www.datascienceacademy.com.br/course/deep-learning-para-aplicacoes-de-ia-com-pytorch-e-lightning)


Até o próximo capítulo!


Referências:


[Formação Engenheiro de Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-machine-learning)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


<div id="capitulo-26---como-escolher-os-hiperparametros-de-uma-rede-neural"></div>

# Capítulo 26 – Como Escolher os Hiperparâmetros de Uma Rede Neural


Até agora não explicamos como foram escolhidos os valores dos hiperparâmetros como a taxa de aprendizado, η, o parâmetro de regularização, λ e assim por diante. Fornecemos valores que funcionaram muito bem, mas, na prática, quando você está usando redes neurais para resolver um problema, pode ser difícil encontrar bons parâmetros. Neste capítulo, começamos nosso estudo sobre Como Escolher os Hiperparâmetros de Uma Rede Neural. Vamos começar?


Imagine, por exemplo, que acabamos de ser apresentados ao dataset MNIST e começamos a trabalhar nele, sem saber nada sobre quais hiperparâmetros usar. Vamos supor que, por sorte, em nossos primeiros experimentos, escolhemos muitos dos hiperparâmetros da mesma forma como foi feito nos [capítulos anteriores](https://www.deeplearningbook.com.br/construindo-uma-rede-neural-com-linguagem-python/): 30 neurônios ocultos, um tamanho de mini-lote de 10, treinando por 30 épocas usando a entropia cruzada. Mas escolhemos uma taxa de aprendizado η = 10.0 e o parâmetro de regularização λ = 1000.0. Aqui está um exemplo de execução da rede (o script está disponível [aqui](https://drive.google.com/file/d/1esmcuW-aluCZTwS-Yjh1x-uijX8DHK62/view)):


 


![net1](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/net1.png)


 


Nossas precisões de classificação não são melhores do que o acaso! Nossa rede está agindo como um gerador de ruído aleatório!


“Bem, isso é fácil de consertar”, você pode dizer, “apenas diminua a taxa de aprendizado e os hiperparâmetros de regularização”. Infelizmente, você não sabe a priori quais são os hiperparâmetros que você precisa ajustar. Talvez o verdadeiro problema seja que nossa rede de neurônios ocultos nunca funcionará bem, não importa como os outros hiperparâmetros sejam escolhidos? Talvez realmente precisemos de pelo menos 100 neurônios ocultos? Ou 300 neurônios ocultos? Ou várias camadas ocultas? Ou uma abordagem diferente para codificar a saída? Talvez nossa rede esteja aprendendo, mas precisamos treinar em mais épocas? Talvez os mini-lotes sejam pequenos demais? Talvez seja melhor voltarmos para a função de custo quadrático? Talvez precisemos tentar uma abordagem diferente para inicializar o peso? E assim por diante. Se fosse fácil, não precisaríamos de um [Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados), não é verdade?


É fácil sentir-se perdido com tantas escolhas e combinações possíveis para os hiperparâmetros. Isso pode ser particularmente frustrante se sua rede for muito grande ou usar muitos dados de treinamento, pois você pode treinar por horas, dias ou semanas, apenas para não obter resultados. Se a situação persistir, prejudicará sua confiança. Talvez as redes neurais sejam a abordagem errada para o seu problema? Talvez você devesse largar o emprego e trabalhar com a apicultura?


Nos próximos capítulos, explicaremos algumas heurísticas que podem ser usadas para definir os hiperparâmetros em uma rede neural. O objetivo é ajudá-lo a desenvolver um fluxo que permita que você faça um bom trabalho definindo hiperparâmetros. Claro, não vamos cobrir tudo sobre otimização de hiperparâmetros. Esse é um assunto enorme, e não é, de qualquer forma, um problema que já está completamente resolvido, nem existe um acordo universal entre os profissionais sobre as estratégias corretas a serem usadas. Há sempre mais um truque que você pode tentar para obter um pouco mais de desempenho da sua rede. Mas temos algumas heurísticas com as quais podemos começar.


Compreendendo a Situação – Estratégia Geral
-------------------------------------------


Ao usar redes neurais para atacar um novo problema, o primeiro desafio é obter qualquer aprendizado não-trivial, ou seja, para que a rede obtenha resultados melhores que o acaso. Isso pode ser surpreendentemente difícil, especialmente ao confrontar uma nova classe de problemas. Vejamos algumas estratégias que você pode usar se tiver esse tipo de problema.


Suponha, por exemplo, que você esteja atacando o MNIST pela primeira vez. Você começa entusiasmado, mas fica um pouco desanimado quando sua primeira rede falha completamente, como no exemplo acima. O caminho a percorrer é reduzir o tamanho do problema. Livre-se de todas as imagens de treinamento e validação, exceto imagens de 0s ou 1s. Em seguida, tente treinar uma rede para distinguir 0s de 1s. Não só isso é um problema inerentemente mais fácil do que distinguir todos os dez dígitos, como também reduz a quantidade de dados de treinamento em 80%, acelerando o treinamento por um fator de 5. Isso permite experimentações muito mais rápidas e, portanto, fornece uma visão mais rápida sobre como construir uma boa rede.


Você pode acelerar ainda mais a experimentação, desmembrando sua rede na rede mais simples, provavelmente fazendo aprendizado significativo. Se você acredita que uma rede [784, 10] provavelmente faz uma classificação melhor que o acaso com o dataset de dígitos MNIST, então comece sua experimentação com essa rede. Vai ser muito mais rápido do que treinar uma rede [784, 30, 10], e você pode “falhar” mais rápido (este é um conceito muito comum nos EUA: “fail fast”, ou seja, cometa falhas o mais rápido possível e aprenda com elas. Não se preocupe em tentar atingir a perfeição, pois você não vai conseguir de qualquer forma).


Você pode acelerar mais na experimentação aumentando a frequência de monitoramento. No network2.py, monitoramos o desempenho no final de cada época de treinamento. Com 50.000 imagens por época, isso significa esperar um pouco – cerca de dez segundos por época, no meu laptop, ao treinar uma rede [784, 30, 10] – antes de obter feedback sobre o quanto a rede está aprendendo. 


É claro que dez segundos não são muito longos, mas se você quiser testar dezenas de opções de hiperparâmetros, é irritante, e se você quiser testar centenas ou milhares de opções, isso começa a ficar debilitante. Podemos obter feedback mais rapidamente, monitorando a precisão da validação com mais frequência, digamos, a cada 1.000 imagens de treinamento. Além disso, em vez de usar o conjunto completo de 10.000 imagens de validação para monitorar o desempenho, podemos obter uma estimativa muito mais rápida usando apenas 100 imagens de validação. 


Tudo o que importa é que a rede veja imagens suficientes para aprender de verdade e obter uma boa estimativa aproximada de desempenho. Claro, nosso programa network2.py atualmente não faz esse tipo de monitoramento. Mas, como um clímax para obter um efeito semelhante para fins de ilustração, vamos reduzir nossos dados de treinamento para apenas as primeiras 1.000 imagens de treinamento MNIST. Vamos tentar e ver o que acontece. (Para manter o código abaixo simples, não implementei a ideia de usar apenas imagens 0 e 1. Claro, isso pode ser feito com um pouco mais de trabalho).


 


![net2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/net2.png)


 


Ainda estamos recebendo puro ruído! Mas há uma grande vitória: agora estamos obtendo feedback em uma fração de segundo, em vez de uma vez a cada dez segundos. Isso significa que você pode experimentar mais rapidamente outras opções de hiperparâmetros, ou até mesmo conduzir experimentos testando muitas opções diferentes de hiperparâmetros quase simultaneamente.


No exemplo acima, eu deixamos λ como λ = 1000.0, como usamos anteriormente. Mas como mudamos o número de exemplos de treinamento, deveríamos realmente mudar λ para manter *weight decay* o mesmo. Isso significa mudar λ para 20.0. Se fizermos isso, então é o que acontece:


 


![net3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/net3.png)


 


Ah! Nós temos um sinal. Não é um sinal muito bom, mas um sinal, no entanto. Isso é algo que podemos construir, modificando os hiperparâmetros para tentar melhorar ainda mais. Talvez nós achemos que nossa taxa de aprendizado precisa ser maior. (Como você talvez perceba, é um palpite bobo, por razões que discutiremos em breve, mas chegaremos lá. Não existe atalho para o aprendizado). Então, para testar nosso palpite, tentamos alterar η até 100.0:


 


![net4](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/net4.png)


 


Isso não é bom, pois sugere que nosso palpite estava errado e o problema não era que a taxa de aprendizado fosse muito baixa. Então, em vez disso, tentamos alterar η para η = 1.0:


 


![net5](https://www.deeplearningbook.com.br/wp-content/uploads/2018/08/net5.png)


 


Agora ficou melhor! E assim podemos continuar, ajustando individualmente cada hiperparâmetro, melhorando gradualmente o desempenho. Uma vez feita a exploração para encontrar um valor melhor para η, seguimos para encontrar um bom valor para λ. Em seguida, experimente uma arquitetura mais complexa, digamos uma rede com 10 neurônios ocultos e ajuste os valores para η e λ novamente. Depois, aumente para 20 neurônios ocultos e então, ajuste outros hiperparâmetros um pouco mais e assim por diante, em cada estágio avaliando o desempenho usando nossos dados de validação e usando essas avaliações para encontrar melhores hiperparâmetros. Ao fazer isso, normalmente leva mais tempo para testemunhar o impacto devido a modificações dos hiperparâmetros, e assim podemos diminuir gradualmente a frequência de monitoramento.


Tudo isso parece muito promissor como uma estratégia ampla. No entanto, quero voltar a esse estágio inicial de encontrar hiperparâmetros que permitem que uma rede aprenda qualquer coisa. De fato, mesmo a discussão acima transmite uma perspectiva muito positiva. Pode ser extremamente frustrante trabalhar com uma rede que não está aprendendo nada. 


Você pode ajustar os hiperparâmetros por dias e ainda não obter uma resposta significativa. Por isso, gostaria de enfatizar novamente que, durante os primeiros estágios, você deve se certificar de que pode obter um feedback rápido dos experimentos. Intuitivamente, pode parecer que simplificar o problema e a arquitetura apenas irá atrasá-lo. Na verdade, isso acelera as coisas, pois você encontra muito mais rapidamente uma rede com um sinal significativo. Uma vez que você tenha recebido tal sinal, muitas vezes você pode obter melhorias rápidas aprimorando os hiperparâmetros. Assim como em tudo na vida, começar pode ser a coisa mais difícil a se fazer.


Ok, essa é a estratégia geral. Vamos agora olhar algumas recomendações específicas para definir hiperparâmetros. Vou me concentrar na taxa de aprendizado, η, no parâmetro de regularização L2, λ e no tamanho do mini-lote. No entanto, muitas das observações também se aplicam a outros hiperparâmetros, incluindo aqueles associados à arquitetura de rede, outras formas de regularização e alguns hiperparâmetros que encontraremos mais adiante aqui no Deep Learning Book, como o coeficiente momentum.


Oh não! O capítulo acabou! Fique tranquilo, continuamos no próximo. Até lá!


Referências:


[Machine Learning Para Advogados](https://blog.dsacademy.com.br/machine_learning_para_advogados/)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-27---a-taxa-de-aprendizado-de-uma-rede-neural"></div>

# Capítulo 27 – A Taxa de Aprendizado de Uma Rede Neural


Vamos continuar a discussão do [capítulo anterior](https://www.deeplearningbook.com.br/capitulo-26-como-escolher-os-hiperparametros-de-uma-rede-neural/) sobre a escolha dos hiperparâmetros de um modelo de rede neural, estudando um dos mais importantes, a taxa de aprendizado. 


Suponha que executemos três redes neurais artificiais sendo treinadas com o dataset MNIST com três taxas de aprendizado diferentes, η = 0.025, η = 0.25 e η = 2.5, respectivamente. Vamos definir os outros hiperparâmetros de acordo com as experiências nos capítulos anteriores, executando mais de 30 epochs, com um tamanho de mini-lote de 10 e com λ = 5.0. Também voltaremos a usar todas as 50.000 imagens de treinamento. Aqui está um gráfico mostrando o comportamento do custo de treinamento enquanto treinamos:


![multiple_eta](https://www.deeplearningbook.com.br/wp-content/uploads/2018/09/multiple_eta.png)


 


Com η = 0.025, o custo diminui suavemente até a época final. Com η = 0.25 o custo inicialmente diminui, mas após cerca de 20 épocas ele está próximo da saturação, e daí em diante a maioria das mudanças são meramente pequenas e aparentemente oscilações aleatórias. Finalmente, com η = 2.5, o custo faz grandes oscilações desde o início. Para entender o motivo das oscilações, lembre-se de que a descida estocástica do gradiente supostamente nos levará gradualmente a um vale da função de custo (conforme explicado [aqui](https://www.deeplearningbook.com.br/aprendizado-com-a-descida-do-gradiente/)):


![taxa de aprendizado](https://www.deeplearningbook.com.br/wp-content/uploads/2018/09/tikz33.png)


No entanto, se η for muito grande, os passos serão tão grandes que poderão, na verdade, ultrapassar o mínimo, fazendo com que o algoritmo simplesmente fique perdido durante o treinamento. Isso é provavelmente o que está causando a oscilação do custo quando η = 2.5. Quando escolhemos η = 0.25, os passos iniciais nos levam a um mínimo da função de custo, e é só quando chegamos perto desse mínimo que começamos a sofrer com o problema de *overshooting*. E quando escolhemos η = 0.025, não sofremos este problema durante as primeiras 30 épocas. 


Claro, escolher η tão pequeno cria outro problema, que reduz a velocidade da descida estocástica do gradiente, aumentando o tempo total de treinamento. Uma abordagem ainda melhor seria começar com η = 0.25, treinar por 20 épocas e então mudar para η = 0.025. Discutiremos essas tabelas de taxas de aprendizado variáveis posteriormente. Por enquanto, porém, vamos nos ater a descobrir como encontrar um único valor bom para a taxa de aprendizado, η.


Com esta imagem em mente, podemos definir η da seguinte maneira. Primeiro, estimamos o valor limite para η no qual o custo nos dados de treinamento começa imediatamente a diminuir, em vez de oscilar ou aumentar. Essa estimativa não tem que ser muito precisa. Você pode estimar a ordem de magnitude começando com η = 0.01. Se o custo diminuir durante as primeiras épocas, então você deve sucessivamente tentar η = 0.1, 1.0,… até encontrar um valor para η onde o custo oscile ou aumente durante as primeiras poucas épocas (isso faz parte do trabalho de um [Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados)). 


Alternativamente, se o custo oscilar ou aumentar durante as primeiras épocas, quando η = 0.01, então tente η = 0.001 ,0.0001,… até encontrar um valor para η onde o custo diminui durante as primeiras poucas épocas. Seguindo este procedimento, obteremos uma estimativa da ordem de magnitude para o valor limite de η. Você pode, opcionalmente, refinar sua estimativa, para escolher o maior valor de η no qual o custo diminui durante as primeiras poucas épocas, digamos η = 0.5 ou η = 0.2 (não há necessidade de que isso seja super-preciso). Isso nos dá uma estimativa para o valor limite de η. E claro, documente tudo!!!!


Obviamente, o valor real de η que você usa não deve ser maior que o valor limite. De fato, se o valor de η permanecer utilizável ao longo de muitas épocas, então você provavelmente desejará usar um valor para η que seja menor, digamos, um fator de dois abaixo do limite. Essa escolha normalmente permitirá que você treine por muitas épocas, sem causar muita lentidão no aprendizado.


No caso dos dados MNIST, seguir esta estratégia leva a uma estimativa de 0.1 para a ordem de magnitude do valor limite de η. Depois de um pouco mais de refinamento, obtemos um valor limite η = 0.5. Seguindo a prescrição acima, isso sugere usar η = 0.25 como nosso valor para a taxa de aprendizado. De fato, eu descobri que usar η = 0.5 funcionava bem o suficiente em 30 épocas que, na maioria das vezes, eu não me preocupava em usar um valor menor de η.


Tudo isso parece bastante simples. No entanto, usar o custo de treinamento para escolher η parece contradizer o que dissemos anteriormente, que escolheríamos os hiperparâmetros avaliando o desempenho usando nossos dados de validação. Na verdade, usaremos a precisão de validação para escolher o hiperparâmetro de regularização, o tamanho do mini-lote e os parâmetros de rede, como o número de camadas e neurônios ocultos, e assim por diante (estudaremos isso nos próximos capítulos). 


Por que as coisas diferem para a taxa de aprendizado? Francamente, essa escolha é uma preferência estética pessoal e talvez seja um tanto idiossincrática. O raciocínio é que os outros hiperparâmetros são destinados a melhorar a precisão final da classificação no conjunto de testes, e por isso faz sentido selecioná-los com base na precisão da validação. No entanto, a taxa de aprendizado é apenas para influenciar a precisão final da classificação. Sua finalidade principal é realmente controlar o tamanho da etapa na descida do gradiente e monitorar o custo do treinamento é a melhor maneira de detectar se o tamanho da etapa é muito grande. Com isso dito, essa é uma preferência pessoal. No início, durante o aprendizado, o custo do treinamento geralmente diminui apenas se a precisão da validação melhorar e assim, na prática, é improvável que faça muita diferença em qual critério você usa.


No próximo capítulo tem mais. Até lá!


Referências:


[Machine Learning com Python e C++](https://www.datascienceacademy.com.br/course/machine-learning-em-python-e-c)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-28---usando-early-stopping-para-definir-o-numero-de-epocas-de-treinamento"></div>

# Capítulo 28 – Usando Early Stopping Para Definir o Número de Épocas de Treinamento


Ao treinar redes neurais, várias decisões precisam ser tomadas em relação às configurações ([hiperparâmetros](https://www.deeplearningbook.com.br/capitulo-26-como-escolher-os-hiperparametros-de-uma-rede-neural/)) usadas, a fim de obter um bom desempenho. Um desses hiperparâmetros é o número de épocas de treinamento: ou seja, quantas passagens completas do conjunto de dados (épocas) devem ser usadas? Se usarmos poucas épocas, poderemos ter problemas de underfitting (ou seja, não aprender tudo o que pudermos com os dados de treinamento); se usarmos muitas épocas, podemos ter o problema oposto, overfitting (“aprender demais”, ou seja, ajustar o “ruído” nos dados de treinamento, e não o sinal).


Usamos o Early Stopping (“Parada Antecipada” ou “Parada Precoce”) exatamente para tentar definir manualmente esse valor. Também pode ser considerado um tipo de método de regularização (como L1/L2 weight decay e dropout estudados [anteriormente](https://www.deeplearningbook.com.br/capitulo-22-regularizacao-l1/) aqui no livro), pois pode impedir o overfitting da rede neural. A imagem abaixo ajuda a definir claramente o que é o Early Stopping:


 


![earlystopping](https://www.deeplearningbook.com.br/wp-content/uploads/2018/09/earlystopping.png)


 


Ao treinar uma rede neural, geralmente se está interessado em obter uma rede com desempenho ideal de generalização. No entanto, todas as arquiteturas de rede neural padrão, como o perceptron multicamada totalmente conectado, são propensas a overfitting. Enquanto a rede parece melhorar, isto é, o erro no conjunto de treinamento diminui, em algum momento durante o treinamento na verdade começa a piorar novamente, ou seja, o erro em exemplos invisíveis aumenta. 


Normalmente, o erro de generalização é estimado pelo erro de validação, isto é, o erro médio em um conjunto de validação, um conjunto fixo de exemplos que não são do conjunto de treino. Existem basicamente duas maneiras de combater o overfitting: reduzindo o número de dimensões do espaço de parâmetros ou reduzindo o tamanho efetivo de cada dimensão. Técnicas para reduzir o número de parâmetros são aprendizagem construtiva gananciosa, poda ou compartilhamento de peso. Técnicas para reduzir o tamanho de cada dimensão de parâmetro são a regularização, como weight decay ou dropout, ou a Parada Precoce (Early Stopping). A parada precoce é amplamente usada porque é simples de entender e implementar e foi relatada como sendo superior aos métodos de regularização em muitos casos.


Usar Early Stopping significa que, no final de cada época, devemos calcular a precisão da classificação nos dados de validação. Quando a precisão parar de melhorar, terminamos o treinamento. Isso torna a configuração do número de épocas muito simples. Em particular, isso significa que não precisamos nos preocupar em descobrir explicitamente como o número de épocas depende dos outros hiperparâmetros, pois isso é feito automaticamente. Além disso, a Parada Antecipada também impede automaticamente o overfitting. Isto é, obviamente, uma coisa boa, embora nos estágios iniciais da experimentação possa ser útil desligar a Parada Antecipada, para que você possa ver quaisquer sinais de overfitting e usá-los para definir sua abordagem de regularização.


Para implementar a Parada Antecipada, precisamos dizer com mais precisão o que significa que a precisão da classificação parou de melhorar. Como já vimos, a precisão pode se mover um pouco, mesmo quando a tendência geral é melhorar. Se pararmos pela primeira vez, a precisão diminui, então quase certamente pararemos quando houver mais melhorias a serem feitas. Uma regra melhor é terminar se a melhor precisão de classificação não melhorar por algum tempo. Suponha, por exemplo, que estamos trabalhando com o dataset MNIST. Poderíamos optar por terminar se a precisão da classificação não melhorou durante as últimas dez épocas. Isso garante que não paremos cedo demais, em resposta à má sorte no treinamento, mas também que não estamos esperando para sempre uma melhoria que nunca acontece.


Esta regra de “parar o treinamento se não melhorar em dez épocas” é boa para a exploração inicial do MNIST. No entanto, as redes podem às vezes estabilizar-se perto de uma determinada precisão de classificação por algum tempo, apenas para começar a melhorar novamente. Se você está tentando obter um desempenho realmente bom, a regra de “parar o treinamento se não melhorar em dez épocas” pode ser muito agressiva. Nesse caso, sugerimos usar essa regra para a experimentação inicial e, gradualmente, adotar regras mais brandas, conforme entender melhor a maneira como sua rede treina: sem melhoria em vinte épocas, sem melhoria em cinquenta épocas e assim por diante. Claro, isso introduz um novo hiperparâmetro para otimizar! Na prática, no entanto, geralmente é fácil definir esse hiperparâmetro para obter bons resultados. Da mesma forma, para problemas diferentes do MNIST, a regra de não-melhoria-em-dez pode ser agressiva demais ou não ser agressiva o suficiente, dependendo dos detalhes do problema. No entanto, com um pouco de experimentação, geralmente é fácil encontrar uma boa estratégia para o Early Stopping. Isso faz parte do trabalho do [Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) ou do [Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia).


Até aqui, nós não usamos o Early Stopping em nossos experimentos MNIST. A razão é que temos feito muitas comparações entre diferentes abordagens de aprendizado. Para tais comparações, é útil usar o mesmo número de épocas em cada caso. No entanto, vale a pena modificar o network2.py para implementar o Early Stopping, e deixaremos isso como tarefa para você. Se precisar de ajuda, o Early Stopping é estudado em detalhes [aqui](https://www.datascienceacademy.com.br/course/deep-learning-para-aplicacoes-de-ia-com-pytorch-e-lightning).


Até o próximo capítulo!


Referências:


[Formação Linguagem Python Para Data Science](https://www.datascienceacademy.com.br/bundle/formacao-linguagem-python-para-data-science)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-29---definindo-o-tamanho-do-mini-batch"></div>

# Capítulo 29 – Definindo o Tamanho do Mini-Batch


Quando os dados de treinamento são divididos em pequenos lotes, cada lote recebe o nome de Mini-Batch (ou Mini-Lote). Suponha que os dados de treinamento tenham 32.000 instâncias e que o tamanho de um Mini-Batch esteja definido como 32. Então, haverá 1.000 Mini-Batches. Mas qual deve ser o tamanho do Mini-Batch? Isso é o que veremos neste capítulo: Definindo o Tamanho do Mini-Batch.


Mas porque usamos Mini-Batches? Digamos que você tenha cerca de 1 bilhão de dados de treinamento. Se você decidir usar o conjunto completo de treinamento em cada época, você precisará de muita memória RAM e armazenamento para processar esses dados, sendo bem provável que sua máquina (ou mesmo um [cluster de computadores](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-dados)) não tenha memória suficiente. Se você decidir usar um exemplo de treinamento em cada época, de um bilhão de dados, de uma só vez, você está ignorando a filosofia de vetorização e isso tornará o processo de treinamento muito mais lento.


Portanto, usamos um subconjunto de dados de treinamento (chamamos de “Mini-Batch”) de cada vez em cada época. Isso nos permitirá manter os dois objetivos: ajustar dados suficientes na memória do computador e manter a filosofia de vetorização ao mesmo tempo. Uma coisa importante sobre o Mini-Batch é que, é melhor escolher o tamanho do Mini-Batch como múltiplo de 2 e os valores comuns são: 64, 128, 256 e 512. Sinta-se à vontade para usar outros valores e discutiremos mais sobre isso mais a frente aqui mesmo neste capítulo.


Veja um exemplo: digamos que você tenha 1 bilhão de dados de treinamento. Você define seu tamanho de Mini-Batch para, digamos, 512. Portanto, em cada época você tem 512 dados de treinamento para processar. Esta configuração levará aproximadamente: (1.000.000.000 / 512) = 1.953.125 épocas para ser concluída. Portanto, o tamanho do Mini-Batch é a quantidade de dados que você deseja processar em cada época.


Se atualizarmos os parâmetros do modelo após o processamento de todos os dados de treinamento (ou seja, época), levaria muito tempo para obter uma atualização do modelo no treinamento, e os dados de treinamento inteiros provavelmente não caberiam na memória. Se atualizarmos os parâmetros do modelo após o processamento de cada instância (por exemplo, descida de gradiente estocástico), as atualizações do modelo seriam demasiado ruidosas e o processo não seria computacionalmente eficiente.


Portanto, a utilização do Mini-Batch (principalmente na descida do gradiente) é introduzida como um trade-off entre {atualizações rápidas do modelo, eficiência de memória} e {atualizações precisas do modelo, eficiência computacional}. É trabalho do [Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) ajustar mais esse parâmetro no processo de treinamento.



Mas Como Devemos Definir o Tamanho do Mini-Batch?
-------------------------------------------------


Para responder a essa pergunta, vamos primeiro supor que estamos fazendo aprendizado on-line, ou seja, que estamos usando um tamanho de Mini-Batch igual a 1.


A preocupação óbvia sobre o aprendizado online é que o uso de Mini-Lotes que contêm apenas um único exemplo de treinamento causará erros significativos em nossa estimativa do gradiente. A razão é que as estimativas graduais individuais não tem que ser super precisas. Tudo o que precisamos é de uma estimativa precisa o suficiente para que nossa função de custo continue diminuindo. É como se você estivesse tentando chegar ao Pólo Norte, mas tivesse uma bússola informando 10 a 20 graus cada vez que você olhasse para ela. Desde que você pare para checar a bússola com frequência, e a bússola acerte na direção, você acabará chegando ao Pólo Norte.


Com base nesse argumento, parece que devemos usar o aprendizado on-line. De fato, a situação acaba sendo mais complicada do que isso. Em um problema do capítulo [anterior](https://www.deeplearningbook.com.br/usando-early-stopping-para-definir-o-numero-de-epocas-de-treinamento/), mostramos que é possível usar técnicas de matriz para calcular a atualização de gradiente para todos os exemplos em um Mini-Lote simultaneamente, em vez de fazer um loop sobre eles. Dependendo dos detalhes de seu hardware e da biblioteca de [álgebra linear](https://www.datascienceacademy.com.br/course/matematica-para-data-science), pode ser um pouco mais rápido calcular a estimativa de gradiente para um Mini-Lote de (por exemplo) tamanho 100, em vez de computar a estimativa de gradiente Mini-Lote fazendo um loop sobre os 100 exemplos de treinamento separadamente. Pode levar (digamos) apenas 50 vezes mais tempo, em vez de 100 vezes mais tempo.


Agora, a princípio, parece que isso não nos ajuda muito. Com nosso Mini-Lote de tamanho 100, a regra de aprendizado para os pesos se parece com:


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2018/09/form1.png)


onde a soma é sobre exemplos de treinamento no Mini-Lote. Isso é equivalente a:


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/09/form2.png)


para aprendizagem online. Mesmo que demore 50 vezes mais para fazer a atualização do Mini-Batch, ainda parece ser melhor fazer o aprendizado online, porque estaríamos atualizando com muito mais frequência. Suponha, no entanto, que no caso do Mini-Lote nós aumentemos a taxa de aprendizado por um fator 100, então a regra de atualização se torna:


![form3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/09/form3.png)


Isso é muito parecido com 100 instâncias separadas de aprendizado online com uma taxa de aprendizado de η. Mas leva apenas 50 vezes mais tempo do que fazer uma única instância de aprendizado online. Naturalmente, não é exatamente o mesmo que 100 instâncias de aprendizado online, já que no Mini-Lote os ∇Cxs são todos avaliados para o mesmo conjunto de pesos, ao contrário do aprendizado cumulativo que ocorre no caso online. Ainda assim, parece claramente possível que o uso do Mini-Lote maior acelere as coisas.


Com esses fatores em mente, escolher o melhor tamanho de Mini-Lote é um trade-off (escolha). Muito pequeno, e você não consegue aproveitar ao máximo os benefícios de boas bibliotecas de matrizes otimizadas para hardware veloz. Demasiado grande e você simplesmente não está atualizando seus pesos com frequência suficiente. O que você precisa é escolher um valor que maximize a velocidade de aprendizado. Felizmente, a escolha do tamanho do Mini-Lote no qual a velocidade é maximizada é relativamente independente dos outros hiperparâmetros (além da arquitetura geral), portanto, você não precisa ter otimizado esses hiperparâmetros para encontrar um bom tamanho Mini-Lote. 


O caminho a percorrer é, portanto, usar alguns valores aceitáveis ​​(mas não necessariamente ideais) para os outros hiperparâmetros, e então testar vários tamanhos diferentes de Mini-Lotes, escalando η como fizemos no exemplo acima. Plote a precisão da validação em relação ao tempo (como em tempo real decorrido, não em época!) e escolha o tamanho do Mini-Lote que forneça a melhoria mais rápida no desempenho. Com o tamanho do Mini-Lote escolhido, você pode continuar a otimizar os outros hiperparâmetros. Entendeu agora porque [Cientistas de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) devem ser muito bem remunerados?


Claro, como você, sem dúvida, percebeu, não fizemos essa otimização em nossa rede de exemplo estudada nos capítulos anteriores. De fato, nossa implementação não usa a abordagem mais rápida para atualizações de Mini-Batch. Nós simplesmente usamos um tamanho de Mini-Lote de 10 sem comentários ou explicações em quase todos os exemplos. Por causa disso, poderíamos ter acelerado o aprendizado reduzindo o tamanho do Mini-Lote. Não fizemos isso, em parte porque queríamos ilustrar o uso de Mini-Lotes além do tamanho 1, e em parte porque nossos experimentos preliminares sugeriam que a aceleração seria bastante modesta, uma vez que nossa rede de exemplo é bem simples. Em implementações práticas, no entanto, certamente implementaríamos a abordagem mais rápida para atualizações de Mini-Batch e, em seguida, faríamos um esforço para otimizar o tamanho do Mini-Lote, a fim de maximizar nossa velocidade geral.


Até o próximo capítulo.


Referências:


[Matemática Para Data Science](https://www.datascienceacademy.com.br/course/matematica-para-data-science)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-30---variacoes-do-stochastic-gradient-descent---hessian-optimization-e-momentum"></div>

# Capítulo 30 – Variações do Stochastic Gradient Descent – Hessian Optimization e Momentum


Cada técnica mostrada até [aqui](https://www.deeplearningbook.com.br/definindo-o-tamanho-do-mini-batch/) é valiosa e deve ser dominada por aqueles que pretendem trabalhar com redes neurais artificiais e aplicações de Inteligência Artificial, mas essa não é a única razão pela qual nós as explicamos. 


O ponto principal é familiarizar você com alguns dos problemas que podem ocorrer nas redes neurais e com um estilo de análise que pode ajudar a superar esses problemas. De certo modo, aprendemos a pensar sobre redes neurais. 


Agora neste capítulo, esquematizamos brevemente algumas outras técnicas. Esses esboços são menos aprofundados do que as discussões anteriores, mas devem transmitir algum sentimento pela diversidade de técnicas disponíveis para uso em redes neurais. Lembrando que você sempre pode estudar todas essas técnicas em detalhes nos cursos da [Formação Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia).


Variações do Stochastic Gradient Descent
----------------------------------------


A descida de gradiente estocástico pela retropropagação tem nos servido bem no ataque ao problema de classificação de dígitos do dataset MNIST. No entanto, existem muitas outras abordagens para otimizar a função de custo e, às vezes, essas outras abordagens oferecem desempenho superior ao gradiente estocástico em mini-lote. Neste capítulo discutiremos duas dessas abordagens, Hessian Optimization e Momentum.


### Hessian Optimization


Para iniciar nossa discussão, ajuda a colocar as redes neurais de lado por um tempo. Em vez disso, vamos apenas considerar o problema abstrato de minimizar uma função de custo C que é uma função de muitas variáveis, w = w1, w2,…, então C = C(w). Pelo teorema de Taylor, a função custo pode ser aproximada perto de um ponto w por:


 


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2018/10/form1.png)


Fórmula 1


 


Podemos reescrever isso de forma mais compacta:


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/10/form2.png)


Fórmula 2


 


onde ∇C é o vetor gradiente usual e H é uma matriz conhecida como Matriz Hessiana. Suponha que nós aproximemos C descartando os termos de ordem superior representados por … acima:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2018/10/form3.png)


Fórmula 3


 


Usando o cálculo, podemos mostrar que a expressão do lado direito pode ser minimizada escolhendo:


 


![form4](https://www.deeplearningbook.com.br/wp-content/uploads/2018/10/form4.png)


Fórmula 4


 


Considerando que a Fórmula 3 é uma boa expressão aproximada para a função custo, então esperamos que a mudança do ponto w para ![form6](https://www.deeplearningbook.com.br/wp-content/uploads/2018/10/form6.png) deva diminuir significativamente a função custo. Isso sugere um algoritmo possível para minimizar o custo:


* Escolha um ponto de partida, w.
* Atualize w para um novo ponto w ′ = w − H ^ − 1 ∇C, onde o Hessian H e ∇C são calculados em w.
* Atualize w′ para um novo ponto w′′ = w′ − H′ ^ − 1 ∇′C, onde o Hessian H′ e ∇′C são calculados em w′.  

…


Na prática, a Fórmula 3 é apenas uma aproximação e é melhor dar passos menores. Fazemos isso alterando repetidamente w por uma quantidade ![form8](https://www.deeplearningbook.com.br/wp-content/uploads/2018/10/form8-1.png) onde η é conhecido como taxa de aprendizado.


Essa abordagem para minimizar uma função de custo é conhecida como Hessian Technique ou Hessian Optimization. Existem resultados teóricos e empíricos mostrando que os métodos de Hessian convergem em um mínimo em menos etapas do que a descida de gradiente padrão. Em particular, ao incorporar informações sobre mudanças de segunda ordem na função de custo, é possível que a abordagem Hessiana evite muitas patologias que podem ocorrer na descida de gradiente. Além disso, há versões do algoritmo de retropropagação que podem ser usadas para computar o Hessian.


Se a Hessian Optimization é tão bom, por que não a estamos usando em nossas redes neurais? Infelizmente, embora tenha muitas propriedades desejáveis, tem uma propriedade muito indesejável: é muito difícil de aplicar na prática. Parte do problema é o tamanho da matriz Hessiana. Suponha que você tenha uma rede neural com 107 pesos e vieses. Em seguida, a matriz Hessiana correspondente conterá 107 × 107 = 1014 entradas. Isso é um número grande de entradas! E isso torna a computação H ^ − 1 ∇C extremamente difícil na prática. No entanto, isso não significa que não seja útil entender. De fato, há muitas variações na descida de gradiente que são inspiradas pela Hessian Optimization, mas que evitam o problema com matrizes excessivamente grandes. Vamos dar uma olhada em uma dessas técnicas, a descida do gradiente baseada em Momentum.


### Momentum


Intuitivamente, a vantagem da Hessian Optimization é que ela incorpora não apenas informações sobre o gradiente, mas também informações sobre como o gradiente está mudando. A descida do gradiente baseada no Momentum baseia-se em uma intuição similar, mas evita grandes matrizes de derivadas secundárias. Para entender a técnica de Momentum, pense em nossa imagem original de descida do gradiente, na qual consideramos uma bola rolando em um vale (veja figura abaixo). Observamos que a descida do gradiente é, apesar de seu nome, apenas vagamente semelhante a uma bola caindo no fundo de um vale. 


A técnica de Momentum modifica a descida do gradiente de duas maneiras que a tornam mais semelhante à imagem física. Primeiro, introduz uma noção de “velocidade” para os parâmetros que estamos tentando otimizar. O gradiente atua para alterar a velocidade, não (diretamente) a “posição”, da mesma maneira que as forças físicas alteram a velocidade, afetando apenas indiretamente a posição. Em segundo lugar, o método Momentum introduz um tipo de termo de fricção, que tende a reduzir gradualmente a velocidade.


Vamos dar uma descrição matemática mais precisa. Introduzimos variáveis de velocidade v = v1, v2,…, uma para cada variável wj correspondente. Então nós substituímos a regra de atualização de descida de gradiente w → w′ = w − η∇C por:


 


![form5](https://www.deeplearningbook.com.br/wp-content/uploads/2018/10/form5.png)


 


Nessas equações, μ é um hiperparâmetro que controla a quantidade de amortecimento ou atrito no sistema. Para entender o significado das equações, é útil considerar primeiro o caso onde μ = 1, o que corresponde a nenhum atrito. Quando esse é o caso, a inspeção das equações mostra que a “força” ∇C está agora modificando a velocidade, v, e a velocidade está controlando a taxa de variação de w. Intuitivamente, nós aumentamos a velocidade adicionando repetidamente termos de gradiente a ela. Isso significa que se o gradiente estiver na (aproximadamente) mesma direção através de várias rodadas de aprendizado, poderemos desenvolver um pouco de vapor movendo-se nessa direção. Pense, por exemplo, no que acontece se estivermos nos movendo diretamente por um declive:


![gradient](https://www.deeplearningbook.com.br/wp-content/uploads/2018/10/gradient.png)


 


A cada passo a velocidade se torna maior no declive, então nos movemos mais e mais rapidamente para o fundo do vale. Isso pode permitir que a técnica de Momentum funcione muito mais rapidamente do que a descida de gradiente padrão. Claro, um problema é que, uma vez que chegarmos ao fundo do vale, vamos ultrapassar. Ou, se o gradiente deve mudar rapidamente, então podemos nos encontrar indo na direção errada. Essa é a razão para o hiperparâmetro µ nas equações acima. 


Eu disse anteriormente que μ controla a quantidade de atrito no sistema; para ser um pouco mais preciso, você deve pensar em 1 − μ como a quantidade de atrito no sistema. Quando μ = 1, como vimos, não há atrito e a velocidade é completamente controlada pelo gradiente ∇C. Em contraste, quando μ = 0 há muito atrito, a velocidade não pode se acumular e as equações acima reduzem à equação usual para o gradiente descendente, w → w ′ = w − η∇C. Na prática, usar um valor intermediário entre 0 e 1 pode nos dar muito do benefício de ser capaz de aumentar a velocidade, mas sem causar overshooting. Podemos escolher um valor para μ usando os dados de validação retidos, da mesma maneira que selecionamos η e λ. 


Evitei nomear o hiperparâmetro μ até agora. A razão é que o nome padrão para μ é mal escolhido: é chamado de coeficiente de momentum. Isso é potencialmente confuso, já que μ não é de maneira alguma a noção de momento da física. Pelo contrário, está muito mais relacionado ao atrito. No entanto, o termo coeficiente de momentum é amplamente utilizado, por isso continuaremos a usá-lo.


Uma coisa boa sobre a técnica do Momentum é que não é preciso quase nenhum trabalho para modificar uma implementação de descida de gradiente para incorporar o Momentum. Ainda podemos usar a retropropagação para calcular os gradientes, assim como antes, e usar ideias como a amostragem de mini-lotes estocasticamente escolhidos. Desta forma, podemos obter algumas das vantagens da Hessian Optimization, usando informações sobre como o gradiente está mudando, mas sem as desvantagens e com apenas pequenas modificações no nosso código. Na prática, a técnica do Momentum é comumente usada e, muitas vezes, acelera o aprendizado.


Até o próximo capítulo!


Referências:


[Deep Learning Para Aplicações de IA com PyTorch e Lightning](https://www.datascienceacademy.com.br/course/deep-learning-para-aplicacoes-de-ia-com-pytorch-e-lightning)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-31---as-redes-neurais-artificiais-podem-computar-qualquer-funcao?"></div>

# Capítulo 31 – As Redes Neurais Artificiais Podem Computar Qualquer Função?


Um dos fatos mais impressionantes sobre redes neurais é que elas podem computar qualquer função. Isto é, suponha que alguém lhe dê alguma função complicada, f(x):


 


![image1](https://www.deeplearningbook.com.br/wp-content/uploads/2018/10/image1.png)


 


Não importa qual seja a função, é garantido que existe uma rede neural de modo que, para cada entrada possível, x, o valor f(x) (ou alguma aproximação) seja transmitido da rede, por exemplo:


 


![image2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/10/image2.png)


 


Este resultado é válido mesmo se a função tiver muitas entradas, f = f(x1,…, xm) e muitas saídas. Por exemplo, aqui está uma rede computando uma função com m = 3 entradas e n = 2 saídas:


![image3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/10/image3.png)


 


Este resultado nos diz que as redes neurais têm um tipo de universalidade. Não importa qual função queremos computar, sabemos que existe uma rede neural que pode fazer o trabalho.


Além do mais, esse teorema da universalidade é válido mesmo se restringirmos nossas redes a ter apenas uma única camada intermediária entre os neurônios de entrada e de saída – uma chamada camada oculta única. Portanto, mesmo arquiteturas de rede muito simples podem ser extremamente poderosas e isso ajuda a explicar porque as redes neurais vem sendo usadas em aplicações avançadas de Inteligência Artificial.


O teorema da universalidade é bem conhecido por pessoas que usam redes neurais. Mas porque é verdade não é tão amplamente compreendido. A maioria das explicações disponíveis é bastante técnica. Por exemplo, um dos artigos originais que comprovou o resultado utilizou o teorema de Hahn-Banach, o teorema da representação de Riesz e alguma análise de Fourier. Se você é um matemático, o argumento não é difícil de seguir, mas não é tão fácil para a maioria das pessoas. É uma pena, já que as razões subjacentes à universalidade são simples e belas.


Nos próximos capítulos, faremos uma explicação simples e principalmente visual do teorema da universalidade. Nós vamos passo a passo através das idéias principais. Você entenderá porque é verdade que as redes neurais podem computar qualquer função. Você entenderá algumas das limitações do resultado. E você entenderá como o resultado se relaciona com redes neurais profundas (Deep Learning).


Os capítulos serão estruturados para ser agradáveis e objetivos. Desde que você tenha apenas um pouco de familiaridade básica com redes neurais, você deve ser capaz de seguir a explicação. No entanto, iremos fornecer links ocasionais para materiais anteriores, para ajudar a preencher quaisquer lacunas em seu conhecimento.


Os teoremas da universalidade são um lugar comum na ciência da computação, tanto que às vezes nos esquecemos do quão surpreendentes eles são. Mas vale a pena lembrar-nos: a capacidade de calcular uma função arbitrária é verdadeiramente notável. Quase qualquer processo que você possa imaginar pode ser considerado como computação de função. Considere o problema de nomear uma peça musical com base em uma pequena amostra da peça. Isso pode ser pensado como computação de uma função. Ou considere o problema de traduzir um texto chinês para o inglês. Mais uma vez, isso pode ser pensado como computação de uma função. Ou considere o problema de analisar um arquivo de filme mp4 e gerar uma descrição do enredo do filme e uma discussão sobre a qualidade da atuação dos atores. Novamente, isso pode ser pensado como um tipo de computação de função. Universalidade significa que, em princípio, as redes neurais podem fazer tudo isso e muito mais.


É claro, só porque sabemos que existe uma rede neural que pode (por exemplo) traduzir o texto chinês para o inglês, isso não significa que temos boas técnicas para construir ou mesmo reconhecer tal rede. Essa limitação se aplica também aos teoremas da universalidade tradicionais para modelos como circuitos booleanos. Mas, como vimos anteriormente no livro, as redes neurais possuem algoritmos poderosos para funções de aprendizado. Essa combinação de algoritmos de aprendizado + universalidade é uma mistura atraente. Até agora, o livro se concentrou nos algoritmos de aprendizado. Nos próximos capítulos, nos concentramos na universalidade e no que ela significa.


A compreensão desse conceito é a chave para as arquiteturas mais avançadas de Deep Learning, que estão por vir mais a frente, neste livro!


Referências:


[Deploy de Modelos de Machine Learning](https://www.datascienceacademy.com.br/course/deploy-de-modelos-de-machine-learning)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-32---como-uma-rede-neural-artificial-encontra-a-aproximacao-de-uma-funcao"></div>

# Capítulo 32 – Como Uma Rede Neural Artificial Encontra a Aproximação de Uma Função


Este é um capítulo muito importante para compreender como as redes neurais realmente funcionam e **Como Uma Rede Neural Artificial Encontra a Aproximação de Uma Função**. Acompanhe a explicação passo a passo analisando cada um dos gráficos apresentados.


Mas antes de explicar porque o teorema da universalidade é verdadeiro, quero mencionar duas advertências a esta declaração informal: “uma rede neural pode computar qualquer função”, que vimos no capítulo [anterior](https://www.deeplearningbook.com.br/as-redes-neurais-artificiais-podem-computar-qualquer-funcao/).


Primeiro, isso não significa que uma rede possa ser usada para calcular exatamente qualquer função. Em vez disso, podemos obter uma aproximação que seja tão boa quanto desejamos. Aumentando o número de neurônios ocultos, podemos melhorar a aproximação. Por exemplo, anteriormente ilustramos uma rede computando alguma função f(x) usando três neurônios ocultos. Para a maioria das funções, apenas uma aproximação de baixa qualidade será possível usando três neurônios ocultos. Ao aumentar o número de neurônios ocultos (digamos, para cinco), podemos obter uma melhor aproximação:


![rede](https://www.deeplearningbook.com.br/wp-content/uploads/2018/11/rede.png)


E podemos melhorar ainda mais aumentando o número de neurônios ocultos.


Para tornar esta afirmação mais precisa, suponha que tenhamos uma função f(x) que gostaríamos de computar com alguma precisão desejada ϵ > 0. A garantia é que usando neurônios ocultos suficientes sempre podemos encontrar uma rede neural cuja saída g(x) satisfaça | g(x) − f(x) | < ϵ, para todas as entradas x. Em outras palavras, a aproximação será boa dentro da precisão desejada para cada entrada possível.


A segunda ressalva é que a classe de funções que podem ser aproximadas da maneira descrita são as funções contínuas. Se uma função é descontínua, isto é, faz saltos bruscos e repentinos, então, em geral, não será possível aproximar usando uma rede neural. Isso não é surpreendente, já que nossas redes neurais calculam funções contínuas de sua entrada. 


No entanto, mesmo que a função que realmente gostaríamos de computar fosse descontínua, muitas vezes a aproximação contínua é boa o suficiente. Se é assim, então podemos usar uma rede neural. Na prática, isso geralmente não é uma limitação importante.


Em suma, uma afirmação mais precisa do teorema da universalidade é que redes neurais com uma única camada oculta podem ser usadas para aproximar qualquer função contínua a qualquer precisão desejada. Neste e no próximo capítulo, vamos provar uma versão desse resultado.


Universalidade Com Uma Entrada e Uma Saída
------------------------------------------


Para entender por que o teorema da universalidade é verdadeiro, vamos começar entendendo como construir uma rede neural que se aproxima de uma função com apenas uma entrada e uma saída:


![rede2](https://www.deeplearningbook.com.br/wp-content/uploads/2018/11/rede2.png)


Este é o cerne do problema da universalidade. Uma vez que entendemos esse caso especial, é realmente fácil estender para funções com muitas entradas e muitas saídas (tema do próximo capítulo).


Para construir um insight sobre como construir uma rede para calcular f, vamos começar com uma rede contendo apenas uma camada oculta, com dois neurônios ocultos e uma camada de saída contendo um único neurônio de saída:


![rede](https://www.deeplearningbook.com.br/wp-content/uploads/2018/11/rede-1.png)


Para ter uma ideia de como funcionam os componentes da rede, vamos nos concentrar no neurônio oculto superior. No diagrama abaixo, aumentando o valor de w, podemos ver imediatamente como a função computada pelo neurônio oculto superior muda:


![rede](https://www.deeplearningbook.com.br/wp-content/uploads/2018/11/rede-3-1024x517.png)


Como aprendemos anteriormente no livro, o que está sendo computado pelo neurônio oculto é σ(wx + b), onde σ(z) ≡ 1 / (1 + e^-z) é a função sigmóide. Até agora, fizemos uso frequente dessa forma algébrica. Mas, para a prova da universalidade, obteremos mais discernimento ignorando inteiramente a álgebra e, em vez disso, manipulando e observando a forma mostrada no gráfico. Isso não apenas nos dará uma ideia melhor do que está acontecendo, mas também nos dará uma prova de universalidade que se aplica a outras funções de ativação que não a função sigmóide.


Para começar esta prova, podemos aumentar o bias, b, no diagrama acima. Você verá que, conforme o bias aumenta, o gráfico se move para a esquerda, mas sua forma não muda.


Em seguida, podemos diminuir o viés (bias). Você verá que conforme o viés diminui, o gráfico se move para a direita, mas, novamente, sua forma não muda. Em seguida, diminuímos o peso para cerca de 2 ou 3. Você verá que à medida que diminui o peso, a curva se alarga. Talvez seja necessário alterar o bias também, para manter a curva no quadro.


Finalmente, aumentamos o peso acima de w = 100. A curva fica mais íngreme, até que, eventualmente, ela começa a parecer uma função de passo (Step Function). A imagem a seguir mostra como deve ser resultado:


![rede3](https://www.deeplearningbook.com.br/wp-content/uploads/2018/11/rede3-1.png)


Podemos simplificar um pouco nossa análise aumentando o peso para que a saída realmente seja uma Step Function, para uma aproximação muito boa. Abaixo eu plotei a saída do neurônio oculto superior quando o peso é w = 999. 


![rede4](https://www.deeplearningbook.com.br/wp-content/uploads/2018/11/rede4.png)


Na verdade, é um pouco mais fácil trabalhar com funções step do que com funções gerais sigmóides. A razão é que, na camada de saída, somamos contribuições de todos os neurônios ocultos. É fácil analisar a soma de várias funções step, mas é mais difícil pensar sobre o que acontece quando você adiciona um monte de curvas em forma de sigmóide. 


E assim torna as coisas muito mais fáceis de assumir que nossos neurônios ocultos estão emitindo funções step. Mais concretamente, fazemos isso fixando o peso w como sendo um valor muito grande e, em seguida, definindo a posição da etapa modificando o bias. É claro que tratar a saída como uma função step é uma aproximação, mas é uma aproximação muito boa e, por enquanto, vamos tratá-la como exata. Voltarei mais tarde para discutir o impacto dos desvios dessa aproximação.


Em que valor de x a etapa ocorre? Em outras palavras, como a posição da etapa depende do peso e do viés?


Para responder a essa pergunta, podemos modificar o peso e o viés no diagrama acima. Você consegue descobrir como a posição da etapa depende de w e b. Com um pouco de trabalho, você deve ser capaz de se convencer de que a posição da etapa é proporcional a b e inversamente proporcional a w.


Na verdade, a etapa está na posição s = −b / w, como você pode ver modificando o peso e o bias no diagrama a seguir:


![rede5](https://www.deeplearningbook.com.br/wp-content/uploads/2018/11/rede5.png)


Isso simplificará muito nossas vidas para descrever os neurônios ocultos usando apenas um único parâmetro, s, que é a posição do passo, s = −b / w. 


![rede6](https://www.deeplearningbook.com.br/wp-content/uploads/2018/11/redd6.png)


Como mencionado acima, nós implicitamente definimos o peso w na entrada como um valor grande – grande o suficiente para que a função de passo seja uma boa aproximação. Podemos facilmente converter um neurônio parametrizado dessa maneira de volta ao modelo convencional, escolhendo o viés b = −ws.


Até agora, nos concentramos na saída apenas do neurônio oculto superior. Vamos dar uma olhada no comportamento de toda a rede. Em particular, vamos supor que os neurônios ocultos estejam computando funções de passos parametrizadas pelos pontos de degrau s1 (neurônio superior) e s2 (neurônio de baixo). E eles terão os respectivos pesos de saída w1 e w2. Aqui está a rede:


![rede7](https://www.deeplearningbook.com.br/wp-content/uploads/2018/11/rede7.png)


O que está sendo plotado à direita é a saída ponderada w1a1 + w2a2 da camada oculta. Aqui, a1 e a2 são as saídas dos neurônios ocultos superior e inferior, respectivamente. Essas saídas são frequentemente conhecidas como ativações dos neurônios.


Podemos aumentar ou diminuir o ponto de passo s1 do neurônio oculto superior e isso nos dá uma ideia de como isso altera a saída ponderada da camada oculta. Vale a pena entender o que acontece quando o s1 passa do s2. Você verá que o gráfico muda de forma quando isso acontece, já que nos movemos de uma situação em que o neurônio oculto superior é o primeiro a ser ativado para uma situação em que o neurônio oculto na parte inferior é o primeiro a ser ativado.


Da mesma forma, podemos manipular o ponto de passo s2 do neurônio oculto na parte inferior e ter uma ideia de como isso altera a saída combinada dos neurônios ocultos.


Finalmente, podemos definir w1 como 0.8 e w2 como −0.8. Você recebe uma função “bump”, que começa no ponto s1, termina no ponto s2 e tem a altura 0.8. Por exemplo, a saída ponderada pode ser assim:


![rede8](https://www.deeplearningbook.com.br/wp-content/uploads/2018/11/rede8.png)


Claro, podemos redimensionar o bump para ter qualquer altura. Vamos usar um único parâmetro, h, para indicar a altura. Para reduzir a confusão, também removerei as notações “s1 = …” e “w1 = …”.


![rede9](https://www.deeplearningbook.com.br/wp-content/uploads/2018/11/rede9.png)


Podemos alterar o valor de h para cima e para baixo, para ver como a altura do bump muda. 


Você notará, a propósito, que estamos usando nossos neurônios de uma forma que pode ser pensada não apenas em termos gráficos, mas em termos de programação mais convencionais, como uma espécie de declaração if-then-else, por exemplo:


![code](https://www.deeplearningbook.com.br/wp-content/uploads/2018/11/code.png)


Na maior parte eu vou ficar com o ponto de vista gráfico. Mas, no que se segue, às vezes você pode achar útil trocar pontos de vista e pensar sobre as coisas em termos de se-então-senão (uma das bases da programação convencional).


Podemos usar o nosso truque de fazer bump para obter dois solavancos, colando dois pares de neurônios ocultos na mesma rede:


![rede11](https://www.deeplearningbook.com.br/wp-content/uploads/2018/11/rede11.png)


Eu suprimi os pesos aqui, simplesmente escrevendo os valores h para cada par de neurônios ocultos. 


De maneira mais geral, podemos usar essa ideia para obter o máximo de picos que quisermos, de qualquer altura. Em particular, podemos dividir o intervalo [0,1] em um número grande, N, de subintervalos, e usar N pares de neurônios ocultos para configurar picos de qualquer altura desejada. Vamos ver como isso funciona para N = 5. Desculpa pela a complexidade do diagrama abaixo (eu poderia esconder a complexidade abstraindo mais, mas acho que vale a pena colocar um pouco de complexidade, para obter uma ideia mais concreta de como essas redes funciona):


![rede](https://www.deeplearningbook.com.br/wp-content/uploads/2018/11/rede-2.png)


Você pode ver que existem cinco pares de neurônios ocultos. Os pontos escalonados para os respectivos pares de neurônios são 0,1 / 5, depois 1 / 5,2 / 5 e assim por diante, para 4 / 5,5 / 5. Esses valores são fixos – eles fazem com que tenhamos cinco saliências uniformemente espaçadas no gráfico.


Cada par de neurônios tem um valor de h associado a ele. Lembre-se, as conexões saídas dos neurônios têm pesos h e −h (não marcados). Ao alterar os pesos de saída, estamos realmente projetando a função!


Conforme alteramos as alturas, é possível ver a mudança correspondente nos valores h. E há também uma mudança nos pesos de saída correspondentes, que são + h e −h.


Em outras palavras, podemos manipular diretamente a função que aparece no gráfico à direita e ver isso refletido nos valores h à esquerda. 


Mas aqui consideramos uma entrada e uma saída, o que é bem simples. Com múltiplas entradas o conceito é basicamente o mesmo, mas iremos discutir as particularidades nos próximos capítulos, quando mergulharmos nas redes neurais profundas. Até lá.


Referências:


[Machine Learning Automation](https://www.datascienceacademy.com.br/course/machine-learning-automation)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning (material utilizado com autorização do autor)](http://neuralnetworksanddeeplearning.com/)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)



<div id="capitulo-33---por-que-as-redes-neurais-profundas-sao-dificeis-de-treinar?"></div>

# Capítulo 33 – Por que as Redes Neurais Profundas São Difíceis de Treinar?


Iniciamos agora a terceira e última parte deste livro, em que estudaremos como funciona Deep Learning e os principais modelos e arquiteturas de redes neurais profundas, com diversos exemplos e aplicações. Mas primeiro temos que responder a seguinte pergunta: Por que as Redes Neurais Profundas São Difíceis de Treinar?


Imagine que você é um engenheiro que foi solicitado a projetar um computador do zero. Um dia, você está trabalhando em seu escritório, projetando circuitos lógicos, estabelecendo portas AND e OU, e assim por diante, quando seu chefe chega com más notícias. O cliente acaba de adicionar um requisito de design surpreendente: o circuito para o computador inteiro deve ter apenas duas camadas de profundidade:


 


![shallow_circuit](https://www.deeplearningbook.com.br/wp-content/uploads/2018/12/shallow_circuit.png)


 


Você fica estupefato e diz ao seu chefe: “O cliente está louco!”


Seu chefe responde: “Eu acho que eles são loucos também. Mas precisamos atender este requisito.”


Na verdade, há um sentido limitado em que o cliente não é louco. Suponha que você tenha permissão para usar uma porta lógica especial que permite a você aplicar o AND (o “e” da lógica) e juntar quantas entradas desejar. E você também tem permissão para uma porta NAND com muitas entradas, ou seja, uma porta que pode aplicar o AND a várias entradas e depois nega a saída. Com essas portas especiais, é possível calcular qualquer função usando um circuito com apenas duas camadas de profundidade.


Mas só porque algo é possível, não é uma boa ideia. Na prática, quando resolvemos problemas de projeto de circuitos (ou quase todos os tipos de problemas algorítmicos), geralmente começamos descobrindo como resolver sub-problemas, e então gradualmente integramos as soluções. Em outras palavras, criamos uma solução através de várias camadas de abstração.


Por exemplo, suponha que estamos projetando um circuito lógico para multiplicar dois números. Provavelmente, queremos construí-lo a partir de sub-circuitos, fazendo operações como adicionar dois números. Os sub-circuitos para adicionar dois números serão, por sua vez, construídos a partir de sub-sub-circuitos para adicionar dois bits. Muito grosso modo, nosso circuito será parecido com:


 


![circuit_multiplication](https://www.deeplearningbook.com.br/wp-content/uploads/2018/12/circuit_multiplication.png)


 


Ou seja, nosso circuito final contém pelo menos três camadas de elementos de circuito. Na verdade, provavelmente conterá mais de três camadas, pois dividimos as sub-tarefas em unidades menores do que as descritas anteriormente. Mas você compreendeu a ideia geral.


Então circuitos profundos facilitam o processo de design. Mas eles não são apenas úteis para o design. Existem, de fato, provas matemáticas mostrando que, para algumas funções, circuitos muito superficiais requerem exponencialmente mais elementos de circuitos para serem computados do que circuitos profundos. Por exemplo, uma famosa série de [artigos](https://eccc.weizmann.ac.il//report/2012/137/) no início dos anos 1980 mostrou que calcular a paridade de um conjunto de bits requer muitos portões exponencialmente, se feito com um circuito superficial. 


Por outro lado, se você usa circuitos mais profundos, é fácil calcular a paridade usando um pequeno circuito: basta calcular a paridade de pares de bits, depois usar esses resultados para calcular a paridade de pares de pares de bits e assim por diante. construindo rapidamente a paridade geral. Os circuitos profundos, portanto, podem ser intrinsecamente muito mais poderosos que os circuitos superficiais.


Até agora, este livro abordou redes neurais como o cliente louco. Quase todas as redes com as quais trabalhamos têm apenas uma camada oculta de neurônios (mais as camadas de entrada e saída):


 


![rede neural profunda](https://www.deeplearningbook.com.br/wp-content/uploads/2018/12/tikz35.png)


 


Essas redes simples têm sido extraordinariamente úteis: nos capítulos anteriores, usamos redes como essa para classificar dígitos manuscritos com precisão superior a 98%! No entanto, intuitivamente, esperamos que as redes com muito mais camadas ocultas sejam mais poderosas:


 


![rede neural profunda](https://www.deeplearningbook.com.br/wp-content/uploads/2018/12/tikz36.png)


 


Tais redes poderiam usar as camadas intermediárias para construir múltiplas camadas de abstração, assim como fazemos em circuitos booleanos. Por exemplo, se estamos fazendo reconhecimento de padrões visuais, então os neurônios da primeira camada podem aprender a reconhecer bordas, os neurônios da segunda camada podem aprender a reconhecer formas mais complexas, digamos, triângulo ou retângulos, construídos a partir de bordas. A terceira camada reconheceria formas ainda mais complexas. E assim por diante. **Essas múltiplas camadas de abstração parecem propiciar às redes profundas uma vantagem convincente em aprender a resolver problemas complexos de reconhecimento de padrões.** Além disso, assim como no caso dos circuitos, existem resultados teóricos sugerindo que as redes profundas são intrinsecamente mais poderosas do que as redes superficiais.


Como podemos treinar essas redes profundas? Nos próximos capítulos, tentaremos treinar redes profundas usando nosso algoritmo de aprendizado: descendente de gradiente estocástico por retropropagação (que já estudamos em detalhes nos capítulos anteriores, mas que agora aplicaremos em redes neurais profundas). Mas vamos nos deparar com problemas, com nossas redes profundas não realizando muito (se for o caso) melhor do que redes rasas.


Essa falha parece surpreendente à luz da discussão acima. Em vez de desistir de redes profundas, vamos nos aprofundar e tentar entender o que está dificultando o treinamento de nossas redes profundas. Quando olharmos de perto, descobriremos que as diferentes camadas da nossa rede profunda estão aprendendo em velocidades muito diferentes. 


Em particular, quando as camadas posteriores da rede estão aprendendo bem, as camadas iniciais geralmente ficam presas durante o treinamento, aprendendo quase nada. Este empecilho não é simplesmente devido à má sorte. Em vez disso, descobriremos que existem razões fundamentais para a lentidão do aprendizado, conectadas ao nosso uso de técnicas de aprendizado baseadas em gradientes.


À medida que nos aprofundamos no problema, aprenderemos que o fenômeno oposto também pode ocorrer: as primeiras camadas podem estar aprendendo bem, mas as camadas posteriores podem ficar presas. Na verdade, descobriremos que existe uma instabilidade intrínseca associada ao aprendizado por gradiente descendente em redes neurais profundas de muitas camadas. Essa instabilidade tende a resultar em camadas anteriores ou posteriores ficando presas durante o treinamento.


Mas, ao nos debruçarmos sobre essas dificuldades, podemos começar a entender o que é necessário para treinar redes profundas de maneira eficaz. E isso é exatamente o que faremos nos próximos capítulos. 


Agora é que começa a diversão. Até lá.


Referências:


[Análise Estatística Para Data Science com Linguagem Python](https://www.datascienceacademy.com.br/course/analise-estatistica-para-data-science-com-linguagem-python)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)



<div id="capitulo-34---o-problema-da-dissipacao-do-gradiente"></div>

# Capítulo 34 – O Problema da Dissipação do Gradiente


Então, [por que as redes neurais profundas são difíceis de treinar](https://www.deeplearningbook.com.br/por-que-as-redes-neurais-profundas-sao-dificeis-de-treinar/)?


Para responder a essa pergunta, primeiro revisitemos o caso de uma rede com apenas uma camada oculta. Como de costume, usaremos o problema de classificação de dígitos MNIST o mesmo já estudado nos capítulos anteriores e que você encontra [aqui](https://drive.google.com/file/d/1esmcuW-aluCZTwS-Yjh1x-uijX8DHK62/view).


A partir de um shell do Python, nós carregamos os dados MNIST:


 


![mnist](https://www.deeplearningbook.com.br/wp-content/uploads/2018/12/image1-2.png)


 


Montamos nossa rede:


 


![mnist](https://www.deeplearningbook.com.br/wp-content/uploads/2018/12/image2-2.png)


 


Esta rede possui 784 neurônios na camada de entrada, correspondendo a 28 × 28 = 784 pixels na imagem de entrada. Utilizamos 30 neurônios ocultos, assim como 10 neurônios de saída, correspondentes às 10 classificações possíveis para os dígitos MNIST (‘0’, ‘1’, ‘2’,…, ‘9’).


Vamos tentar treinar nossa rede por 30 épocas completas, usando mini-lotes de 10 exemplos de treinamento por vez, uma taxa de aprendizado η = 0.1 e um parâmetro de regularização λ = 5.0. À medida que treinarmos, monitoramos a precisão da classificação no conjunto de dados validation\_data. Podemos executar o script test.py com todos os comandos. Via prompt de comando ou terminal, digitamos: **python test.py** (o treinamento pode levar muitos minutos dependendo da velocidade do computador).


 


![treinamento](https://www.deeplearningbook.com.br/wp-content/uploads/2018/12/image3-1.png)


 


Ao final do treinamento, obtemos uma precisão de classificação de 96,48% (aproximadamente), comparável a nossos resultados anteriores com uma configuração semelhante. Agora, vamos adicionar outra camada oculta, também com 30 neurônios, e tentar treinar com os mesmos hiperparâmetros. Usamos:


 


**net = network2.Network([784, 30, 30, 10])**


 


Isto dá uma melhor precisão de classificação 96,90%. Isso é encorajador: um pouco mais de profundidade está ajudando. Vamos adicionar outra camada oculta de 30 neurônios.


 


**net = network2.Network([784, 30, 30, 30, 10])**


 


Isso não ajuda em nada. Na verdade, o resultado cai para 96,57%, próximo à nossa rede original. E suponha que inserimos mais uma camada oculta.


 


**net = network2.Network([784, 30, 30, 30, 30, 10])**


 


Esse comportamento parece estranho. Intuitivamente, camadas ocultas extras devem tornar a rede capaz de aprender funções de classificação mais complexas e, assim, fazer uma melhor classificação. Certamente, as coisas não devem piorar, já que as camadas extras podem, no pior dos casos, simplesmente não fazer nada. Mas não é isso que está acontecendo.


Então, o que está acontecendo? Vamos supor que as camadas ocultas extras realmente possam ajudar em princípio e o problema é que nosso algoritmo de aprendizado não está encontrando os pesos e vieses corretos. Gostaríamos de descobrir o que está errado em nosso algoritmo de aprendizado e como fazer melhor.


Para entender melhor o que está errado, vamos visualizar como a rede aprende. Abaixo, traçamos parte de uma rede [784,30,30,10], ou seja, uma rede com duas camadas ocultas, cada uma contendo 30 neurônios ocultos. Cada neurônio no diagrama tem uma pequena barra nele, representando a rapidez com que o neurônio está mudando à medida que a rede aprende. Uma barra grande significa que o peso e o viés do neurônio estão mudando rapidamente, enquanto uma barra pequena significa que os pesos e o viés estão mudando lentamente. Mais precisamente, as barras indicam o gradiente ∂C / ∂b para cada neurônio, ou seja, a taxa de mudança do custo em relação ao viés do neurônio. 


Nos capítulos anteriores, vimos que essa quantidade de gradiente controlava não apenas a rapidez com que o viés muda durante o aprendizado, mas também a rapidez com que os pesos inseridos no neurônio também mudam. Não se preocupe se você não se lembrar dos detalhes: a única coisa a ter em mente é simplesmente que essas barras mostram a rapidez com que os pesos e os vieses de cada neurônio mudam conforme a rede aprende.


Para manter o diagrama simples, mostrei apenas os seis principais neurônios nas duas camadas ocultas. Eu omiti os neurônios de entrada, pois eles não têm pesos nem viés para aprender. Eu também omiti os neurônios de saída, já que estamos fazendo comparações por camadas, e faz mais sentido comparar camadas com o mesmo número de neurônios. Os resultados foram plotados no início do treinamento, ou seja, imediatamente após a inicialização da rede. Aqui estão eles:


 


![rede](https://www.deeplearningbook.com.br/wp-content/uploads/2018/12/download.png)


 


A rede foi inicializada aleatoriamente e, portanto, não é surpreendente que haja muita variação na rapidez com que os neurônios aprendem. Ainda assim, uma coisa que vale ressaltar é que as barras na segunda camada oculta são em sua maioria muito maiores que as barras na primeira camada oculta. Como resultado, os neurônios da segunda camada oculta aprendem um pouco mais rápido que os neurônios da primeira camada oculta. Isso é meramente uma coincidência, ou os neurônios da segunda camada oculta provavelmente aprenderão mais rápido do que os neurônios na primeira camada oculta em geral?


Para determinar se esse é o caso, é útil ter uma maneira global de comparar a velocidade de aprendizado na primeira e segunda camadas ocultas. Para fazer isso, vamos indicar o gradiente como δlj = ∂C / ∂blj, ou seja, o gradiente para o neurônio jth na camada lth.


Podemos pensar no gradiente δ1 como um vetor cujas entradas determinam a rapidez com que a primeira camada oculta aprende, e δ2 como um vetor cujas entradas determinam a rapidez com que a segunda camada oculta aprende. Em seguida, usaremos os comprimentos desses vetores como medidas globais da velocidade na qual as camadas estão aprendendo. Assim, por exemplo, o comprimento “δ1” mede a velocidade na qual a primeira camada oculta está aprendendo, enquanto o comprimento “δ2” mede a velocidade na qual a segunda camada oculta está aprendendo.


Com essas definições, e na mesma configuração que foi plotada acima, encontramos δδ1 = 0.07… e δδ2 = 0.31…. Isso confirma nossa suspeita anterior: os neurônios na segunda camada oculta realmente estão aprendendo muito mais rápido que os neurônios da primeira camada oculta.


O que acontece se adicionarmos mais camadas ocultas? Se tivermos três camadas ocultas, em uma rede [784,30,30,30,10], então as respectivas velocidades de aprendizado serão 0,012, 0,060 e 0,283. Novamente, as camadas ocultas anteriores estão aprendendo muito mais lentamente que as camadas ocultas posteriores. Suponha que adicionemos mais uma camada com 30 neurônios ocultos. Nesse caso, as respectivas velocidades de aprendizado são 0,003, 0,017, 0,070 e 0,285. O padrão é válido: as camadas iniciais aprendem mais lentamente que as camadas posteriores.


Temos observado a velocidade de aprendizado no início do treinamento, ou seja, logo após as redes serem inicializadas. Como a velocidade do aprendizado muda à medida que treinamos nossas redes? Vamos voltar para ver a rede com apenas duas camadas ocultas. A velocidade de aprendizado muda da seguinte forma:


 


![training_speed_2_layers](https://www.deeplearningbook.com.br/wp-content/uploads/2018/12/training_speed_2_layers.png)


 


Para gerar esses resultados, usamos a descida do gradiente em lote com apenas 1.000 imagens de treinamento, treinadas em mais de 500 épocas. Isso é um pouco diferente do que normalmente treinamos nos capítulos anteriores, mas acontece que o uso de gradiente estocástico em mini-lote dá resultados muito mais ruidosos (embora muito similares, quando você mede o ruído). Usar os parâmetros que escolhemos é uma maneira fácil de suavizar os resultados, para que possamos ver o que está acontecendo.


Em qualquer caso, como você pode ver, as duas camadas começam a aprender em velocidades muito diferentes (como já sabemos). A velocidade em ambas as camadas cai muito rapidamente, antes de se recuperar. Mas, apesar de tudo, a primeira camada oculta aprende muito mais lentamente do que a segunda camada oculta.


E quanto a redes mais complexas? Aqui estão os resultados de uma experiência semelhante, mas desta vez com três camadas ocultas (uma rede [784,30,30,30,10]):


 


![training_speed_3_layers](https://www.deeplearningbook.com.br/wp-content/uploads/2018/12/training_speed_3_layers.png)


 


Mais uma vez, as primeiras camadas ocultas aprendem muito mais lentamente do que as camadas ocultas posteriores. Finalmente, vamos adicionar uma quarta camada oculta (uma rede [784,30,30,30,30,10]) e ver o que acontece quando treinamos:


 


![training_speed_4_layers](https://www.deeplearningbook.com.br/wp-content/uploads/2018/12/training_speed_4_layers.png)


 


Mais uma vez, as primeiras camadas ocultas aprendem muito mais lentamente do que as camadas ocultas posteriores. Nesse caso, a primeira camada oculta está aprendendo aproximadamente 100 vezes mais lenta que a camada oculta final. Natural que estivéssemos tendo problemas para treinar essas redes antes!


Temos aqui uma observação importante: em pelo menos algumas redes neurais profundas, o gradiente tende a diminuir à medida que nos movemos para trás através das camadas ocultas. Isso significa que os neurônios nas camadas anteriores aprendem muito mais lentamente que os neurônios nas camadas posteriores. E, embora tenhamos visto isso em apenas uma única rede, há razões fundamentais pelas quais isso acontece em muitas redes neurais. O fenômeno é conhecido como **O Problema da Dissipação do Gradiente** ou **The Vanishing Gradient Problem**. Esse é um problema muito comum e ainda mais evidente em Redes Neurais Recorrentes, usadas em aplicações de Processamento de Linguagem Natural.


Por que o problema de dissipação do gradiente ocorre? Existem maneiras de evitar isso? E como devemos lidar com isso no treinamento de redes neurais profundas? Na verdade, aprenderemos rapidamente que não é inevitável, embora a alternativa também não seja muito atraente: às vezes, o gradiente fica muito maior nas camadas anteriores! Este problema é chamado de explosão do gradiente, e não é uma notícia muito melhor do que o problema da dissipação do gradiente. Geralmente, verifica-se que o gradiente em redes neurais profundas é instável, tendendo a explodir ou a desaparecer nas camadas anteriores. Essa instabilidade é um problema fundamental para o aprendizado baseado em gradiente em redes neurais profundas. É algo que precisamos entender e, se possível, tomar medidas para resolver.


Momentaneamente se afastando das redes neurais, imagine que estamos tentando minimizar numericamente uma função f(x) de uma única variável. Não seria uma boa notícia se a derivada f′(x) fosse pequena? Isso não significaria que já estávamos perto de um extremo? De forma semelhante, o pequeno gradiente nas primeiras camadas de uma rede profunda pode significar que não precisamos fazer muito ajuste dos pesos e vieses?


Claro, isso não é o caso. Lembre-se de que inicializamos aleatoriamente o peso e os vieses na rede. É extremamente improvável que nossos pesos e vieses iniciais façam um bom trabalho em qualquer coisa que desejamos que nossa rede faça. Para ser concreto, considere a primeira camada de pesos em uma rede [784,30,30,30,10] para o problema MNIST. 


A inicialização aleatória significa que a primeira camada elimina a maior parte das informações sobre a imagem de entrada. Mesmo que as camadas posteriores tenham sido extensivamente treinadas, elas ainda acharão extremamente difícil identificar a imagem de entrada, simplesmente porque elas não possuem informações suficientes. E assim, não é possível que não seja preciso aprender muito na primeira camada. Se vamos treinar redes profundas, precisamos descobrir como resolver o problema da dissipação do gradiente.


Se eu fosse você, não perderia o próximo capítulo com uma explicação matemática para esse importante fenômeno no treinamento de redes neurais profundas (Deep Learning).


Referências:


[Matemática Para Data Science](https://www.datascienceacademy.com.br/course/matematica-para-data-science)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)(material usado com autorização do autor)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)




<div id="capitulo-35---a-matematica-do-problema-de-dissipacao-do-gradiente-em-deep-learning"></div>

# Capítulo 35 – A Matemática do Problema de Dissipação do Gradiente em Deep Learning


Vamos continuar a discussão iniciada no capítulo [anterior](https://www.deeplearningbook.com.br/o-problema-da-dissipacao-do-gradiente/). Para entender porque o problema da dissipação do gradiente ocorre, vamos considerar a rede neural profunda mais simples: uma com apenas um único neurônio em cada camada. Aqui está uma rede com três camadas ocultas:


 


![tikz37](https://www.deeplearningbook.com.br/wp-content/uploads/2019/01/tikz37.png)


 


Aqui, w1, w2,… são os pesos, b1, b2,… são os vieses e C é alguma função de custo. Apenas para lembrar como isso funciona, a saída aj do neurônio j é σ(zj), onde σ é a função de ativação sigmóide usual, e zj = wjaj − 1 + bj é a entrada ponderada para o neurônio. Eu desenhei o custo C no final para enfatizar que o custo é uma função da saída da rede, a4: se a saída real da rede estiver próxima da saída desejada, então o custo será baixo, enquanto se estiver longe, o custo será alto.


Vamos estudar o gradiente ∂C / ∂b1 associado ao primeiro neurônio oculto. Definiremos uma expressão para ∂C / ∂b1 e, estudando essa expressão, entenderemos porque o problema da dissipação do gradiente ocorre.


Vou começar simplesmente mostrando a expressão para ∂C / ∂b1. Parece assustador, mas na verdade tem uma estrutura simples, que descreverei em breve. Aqui está a expressão (ignore a rede, por enquanto, e note que σ ′ é apenas a derivada da função σ):


 


![tikz38](https://www.deeplearningbook.com.br/wp-content/uploads/2019/01/tikz38.png)


 


A estrutura na expressão é a seguinte: existe um termo σ ′ (zj) no produto para cada neurônio na rede; um peso wj para cada peso na rede; e um termo final ∂C / ∂a4, correspondente à função de custo no final. Observe que coloquei cada termo na expressão acima da parte correspondente da rede. Então a rede em si é um mnemônico para a expressão.


Há também uma explicação simples de porque a expressão acima é verdadeira e, portanto, é divertido (e talvez esclarecedor) dar uma olhada nessa explicação.


Imagine que fazemos uma pequena mudança Δb1 no viés b1. Isso irá desencadear uma série de mudanças em cascata no resto da rede. Primeiro, causa uma mudança Δa1 na saída do primeiro neurônio oculto. Isso, por sua vez, causará uma mudança Δz2 na entrada ponderada para o segundo neurônio oculto. Então, uma mudança Δa2 na saída do segundo neurônio oculto. E assim por diante, até chegar a uma mudança de C no custo na saída. Nós temos


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/01/form1.png)


Isso sugere que podemos descobrir uma expressão para o gradiente ∂C / ∂b1, acompanhando cuidadosamente o efeito de cada etapa dessa cascata.


Para fazer isso, vamos pensar em como Δb1 faz com que a saída a1 do primeiro neurônio oculto mude. Nós temos a1 = σ (z1) = σ (w1a0 + b1), então:


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/01/form2.png)


Esse termo σ ′ (z1) deve parecer familiar: é o primeiro termo em nossa expressão reivindicada para o gradiente ∂C / ∂b1. Intuitivamente, esse termo converte uma mudança Δb1 no viés em uma mudança Δa1 na ativação de saída. Essa mudança Δa1 por sua vez causa uma mudança na entrada ponderada z2 = w2a1 + b2 para o segundo neurônio oculto:


![form3](https://www.deeplearningbook.com.br/wp-content/uploads/2019/01/form3.png)


Combinando nossas expressões para Δz2 e Δa1, vemos como a mudança no viés b1 se propaga ao longo da rede para afetar z2:


![form](https://www.deeplearningbook.com.br/wp-content/uploads/2019/02/form.png)


Novamente, isso deve parecer familiar: agora temos os dois primeiros termos em nossa expressão reivindicada para o gradiente ∂C / ∂b1.


Podemos continuar dessa maneira, rastreando a maneira como as alterações se propagam pelo resto da rede. Em cada neurônio, pegamos um termo σ ′ (zj) e, em cada peso, escolhemos um termo wj. O resultado final é uma expressão que relaciona a mudança final ΔC no custo para a mudança inicial Δb1 no viés:


![form5](https://www.deeplearningbook.com.br/wp-content/uploads/2019/01/form5.png)


Dividindo por Δb1, de fato, obtemos a expressão desejada para o gradiente:


![form6](https://www.deeplearningbook.com.br/wp-content/uploads/2019/01/form6.png)




Por que o problema da dissipação do gradiente ocorre afinal?
------------------------------------------------------------


Para entender porque o problema da dissipação do gradiente ocorre, vamos escrever explicitamente a expressão inteira para o gradiente:


![form7](https://www.deeplearningbook.com.br/wp-content/uploads/2019/01/form7.png)


Com exceção do último termo, essa expressão é um produto de termos da forma wjσ ′ (zj). Para entender como cada um desses termos se comporta, vamos ver um gráfico da função σ ′:


![form9](https://www.deeplearningbook.com.br/wp-content/uploads/2019/01/form9.png)


A derivada atinge um máximo em σ ′ (0) = 1/4. Agora, se usarmos nossa abordagem padrão para inicializar os pesos na rede, escolheremos os pesos usando uma distribuição normal (Gaussiana) com média 0 e desvio padrão 1. Assim, os pesos geralmente satisfazem | wj | < 1. Reunindo essas observações, vemos que os termos wjσ ′ (zj) geralmente satisfazem | wjσ ′ (zj) | < 1/4. E quando tomamos um produto de muitos desses termos, o produto tenderá a diminuir exponencialmente: quanto mais termos, menor será o produto. Isso está começando a cheirar como uma possível explicação para o problema da dissipação do gradiente.


Para tornar tudo isso um pouco mais explícito, vamos comparar a expressão para ∂C / ∂b1 com uma expressão para o gradiente em relação a um viés posterior, digamos ∂C / ∂b3. Naturalmente, não explicamos explicitamente uma expressão para ∂C / ∂b3, mas segue o mesmo padrão descrito acima para ∂C / ∂b1. Aqui está a comparação das duas expressões:


![form10](https://www.deeplearningbook.com.br/wp-content/uploads/2019/01/form10-1024x542.png)


As duas expressões compartilham muitos termos. Mas o gradiente ∂C / ∂b1 inclui dois termos extras, cada um da forma wjσ ′ (zj). Como vimos, esses termos são tipicamente menores que 1/4 de magnitude. E assim o gradiente ∂C / ∂b1 normalmente será um fator de 16 (ou mais) menor que ∂C / ∂b3. Esta é a origem essencial do problema da dissipação do gradiente.


É claro que este é um argumento informal, não uma prova rigorosa de que o problema da dissipação do gradiente ocorrerá. Existem várias cláusulas de escape possíveis. Em particular, podemos nos perguntar se os pesos wj poderiam crescer durante o treinamento. Se o fizerem, é possível que os termos wjσ ′ (zj) no produto deixem de satisfazer | wjσ ′ (zj) | < 1/4. De fato, se os termos se tornarem grandes o suficiente – maiores que 1 – então não teremos mais um problema de dissipação do gradiente. Em vez disso, o gradiente crescerá exponencialmente à medida que nos movemos para trás pelas camadas. Em vez de um problema de dissipação do gradiente, teremos um problema de explosão do gradiente. Mas isso é assunto para o próximo capítulo!


Para aprender todos os detalhes matemáticos por trás desse processo, confira nosso curso único e exclusivo no Brasil: [Matemática Para Data Science](https://www.datascienceacademy.com.br/course/matematica-para-data-science). 


Até o próximo capítulo.


Referências:


[Formação Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)(material usado com autorização do autor)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-36---outros-problemas-com-o-gradiente-em-redes-neurais-artificiais"></div>

# Capítulo 36 – Outros Problemas com o Gradiente em Redes Neurais Artificiais


No capítulo [anterior](https://www.deeplearningbook.com.br/a-matematica-do-problema-de-dissipacao-do-gradiente-em-deep-learning/) descrevemos para você a Matemática que ajuda a explicar a causa do problema da dissipação do gradiente. Mas a dissipação não é o único problema que pode ocorrer. Neste capítulo vamos descrever outros possíveis problemas com o gradiente em redes neurais artificiais.


### Explosão do Gradiente


Vamos ver um exemplo explícito em que ocorre a explosão dos gradientes. O exemplo é bem simples e vamos alterar alguns parâmetros na rede de maneira a garantir que tenhamos a explosão do gradiente. Mesmo fazendo essa alteração para forçar o problema, a explosão do gradiente não é apenas uma possibilidade hipotética e realmente pode acontecer.


Há duas etapas para obter a explosão do gradiente. Primeiro, escolhemos todos os pesos na rede como grandes, digamos w1 = w2 = w3 = w4 = 100. Segundo, vamos escolher os vieses para que os termos σ ′ (zj) não sejam muito pequenos. Isso é realmente muito fácil de fazer: tudo o que precisamos é escolher os vieses para garantir que a entrada ponderada para cada neurônio seja zj = 0 (e então σ ′ (zj) = 1/4). Então, por exemplo, queremos z1 = w1a0 + b1 = 0. Podemos conseguir isso ajustando b1 = −100 ∗ a0. Podemos usar a mesma ideia para selecionar os outros vieses. Quando fazemos isso, vemos que todos os termos wjσ ′ (zj) são iguais a 100 ∗ 1/4 = 25. Com estas escolhas ocorre o problema da explosão do gradiente.


### Instabilidade do Gradiente


O problema fundamental aqui não é tanto o problema do gradiente que desaparece ou o problema do gradiente que explode. É que o gradiente nas camadas iniciais é o produto dos termos de todas as camadas posteriores. Quando há muitas camadas, essa é uma situação intrinsecamente instável. A única maneira que todas as camadas podem aprender perto da mesma velocidade é se todos esses produtos de termos estiverem próximos de se equilibrar. Sem algum mecanismo ou razão subjacente para que o equilíbrio ocorra, é altamente improvável que aconteça simplesmente por acaso. Em suma, o problema real aqui é que as redes neurais sofrem de um problema de instabilidade do gradiente. Como resultado, se usarmos técnicas de aprendizado baseadas em gradiente padrão, camadas diferentes na rede tenderão a aprender em velocidades totalmente diferentes.


### O Problema Mais Comum é Mesmo a Dissipação do Gradiente


Vimos que o gradiente pode desaparecer ou explodir nas camadas iniciais de uma rede profunda. De fato, ao usar neurônios sigmóides, o gradiente geralmente desaparece. Para ver porque, considere novamente a expressão | wσ ′ (z) |. Para evitar o problema da dissipação do gradiente, precisamos | wσ ′ (z) | ≥1. Você pode pensar que isso pode acontecer facilmente se w for muito grande. No entanto, é mais difícil do que parece. A razão é que o termo σ ′ (z) também depende de w: σ ′ (z) = σ ′ (wa + b), onde a é a ativação da entrada. 


Então, quando fazemos w grande, precisamos ter cuidado para que não tornemos simultaneamente σ ′ (wa + b) pequeno. Isso acaba sendo uma restrição considerável. A razão é que quando fazemos w grande, tendemos a tornar o wa + b muito grande. Olhando para um gráfico de σ ′ você pode ver que isso nos coloca fora das “asas” da função σ ′, onde é preciso valores muito pequenos. A única maneira de evitar isso é se a ativação de entrada estiver dentro de um intervalo bastante estreito de valores. Às vezes isso vai acontecer, mas frequentemente, porém, isso não acontece. E assim, no caso genérico, temos a dissipação dos gradientes.


### Gradientes Instáveis em Redes Mais Complexas


Temos estudado redes simples como exemplo, com apenas um neurônio em cada camada oculta. E quanto a redes profundas mais complexas, com muitos neurônios em cada camada oculta (tipicamente Deep Learning)?


![network](https://www.deeplearningbook.com.br/wp-content/uploads/2019/02/network.png)


 


De fato, o mesmo comportamento ocorre em tais redes. Nos capítulos anteriores onde estudamos retropropagação, vimos que o gradiente na camada l de uma rede de camada L é dado por:


![form](https://www.deeplearningbook.com.br/wp-content/uploads/2019/02/form-1.png)


Aqui, Σ ′ (zl) é uma matriz diagonal cujas entradas são os valores σ ′ (z) para as entradas ponderadas para a camada l. As wl são as matrizes de peso para as diferentes camadas. E ∇aC é o vetor de derivadas parciais de C em relação às ativações de saída.


Essa é uma expressão muito mais complicada do que no caso de um único neurônio. Ainda assim, se você olhar de perto, a forma essencial é muito semelhante, com muitos pares da forma:


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/02/form2.png)


Além disso, as matrizes Σ′ (zj) possuem pequenas entradas na diagonal, nenhuma maior que 1/4. Desde que as matrizes de peso wj não sejam muito grandes, cada termo adicional:![form3](https://www.deeplearningbook.com.br/wp-content/uploads/2019/02/form3.png) 


tende a fazer o vetor gradiente menor, levando a uma dissipação do gradiente. Mais genericamente, o grande número de termos no produto tende a levar a um gradiente instável, assim como no nosso exemplo anterior. Na prática isso é tipicamente encontrado em redes sigmóides que os gradientes desaparecem exponencialmente de forma rápida nas camadas anteriores. Como resultado, o aprendizado diminui nessas camadas. Essa desaceleração não é apenas um acidente ou uma inconveniência: é uma consequência fundamental da abordagem que estamos adotando para o aprendizado da rede.


### Outros Obstáculos Para a Aprendizagem Profunda


Nestes últimos capítulos, nos concentramos na dissipação de gradientes – e, em geral, gradientes instáveis – como um obstáculo à aprendizagem profunda. De fato, gradientes instáveis são apenas um obstáculo para o aprendizado profundo, embora seja um importante obstáculo fundamental. Muitas pesquisas em andamento têm como objetivo entender melhor os desafios que podem ocorrer quando se treinam redes profundas. Vamos mencionar brevemente alguns artigos, para dar a você o sabor de algumas das perguntas que as pessoas estão fazendo.


Como primeiro exemplo, em 2010 [Glorot e Bengio](http://proceedings.mlr.press/v9/glorot10a/glorot10a.pdf) encontraram evidências sugerindo que o uso de funções de ativação sigmóide pode causar problemas ao treinamento de redes profundas. Em particular, eles encontraram evidências de que o uso de sigmóides fará com que as ativações na camada oculta final saturem perto de 0 no início do treinamento, diminuindo substancialmente o aprendizado. Eles sugeriram algumas funções de ativação alternativas, que parecem não sofrer tanto com esse problema de saturação.


Como um segundo exemplo, em 2013, [Sutskever, Martens, Dahl e Hinton](http://www.cs.toronto.edu/~hinton/absps/momentum.pdf) estudaram o impacto na aprendizagem profunda tanto da inicialização de peso aleatório quanto do cronograma de momentum na descida de gradiente estocástica baseada no momento. Em ambos os casos, fazer boas escolhas fez uma diferença substancial na capacidade de treinar redes profundas.


Esses exemplos sugerem que “O que dificulta o treinamento de redes profundas?” é uma questão complexa. Nestes últimos capítulos, nos concentramos nas instabilidades associadas ao aprendizado baseado em gradiente em redes profundas. Os resultados dos dois últimos parágrafos sugerem que há também um papel desempenhado pela escolha da função de ativação, a forma como os pesos são inicializados e até mesmo detalhes de como a aprendizagem por gradiente descendente é implementada. E, claro, a escolha da arquitetura de rede e outros hiperparâmetros também é importante. Assim, muitos fatores podem desempenhar um papel em dificultar a formação de redes profundas, e a compreensão de todos esses fatores ainda é objeto de pesquisas em andamento. A boa notícia é que, a partir do próximo capítulo, vamos mudar isso e desenvolver várias abordagens para o aprendizado profundo que, até certo ponto, conseguem superar ou direcionar todos esses desafios.


Não é incrível o que estamos vivenciando neste exato momento da história humana? Tudo isso que estudamos até aqui forma a base de aplicações de Inteligência Artificial que já são encontradas no mercado, em diversas aplicações e até mesmo em nossos smartphones. E ainda estamos apenas no começo. 


E você, quer ou não fazer parte desta incrível revolução trazida pela Inteligência Artificial? Se a resposta for sim, o que está esperando?


Referências:


[Formação Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)(material usado com autorização do autor)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-37---o-efeito-do-batch-size-no-treinamento-de-redes-neurais-artificiais"></div>

# Capítulo 37 – O Efeito do Batch Size no Treinamento de Redes Neurais Artificiais


A partir deste capítulo você vai compreender em mais detalhes a arquitetura dos principais modelos de [Deep Learning](https://www.datascienceacademy.com.br/course/deep-learning-para-aplicacoes-de-ia-com-pytorch-e-lightning), com ênfase nas escolhas dos hiperparâmetros e abordagens de treinamento. Vamos começar com O Efeito do Batch Size no Treinamento de Redes Neurais Artificiais.


Neste experimento, vamos investigar o efeito do tamanho do lote (Batch Size) na dinâmica de treinamento. Tamanho do lote (Batch Size) é um termo usado em aprendizado de máquina e refere-se ao número de exemplos de treinamento usados em uma iteração. O Batch Size pode ser uma das três opções:


* **batch mode**: onde o tamanho do lote é igual ao conjunto de dados total, tornando os valores de iteração e épocas equivalentes.
* **mini-batch mode**: onde o tamanho do lote é maior que um, mas menor que o tamanho total do conjunto de dados. Geralmente, um número que pode ser dividido no tamanho total do conjunto de dados.
* **stochastic mode**: onde o tamanho do lote é igual a um. Portanto, o gradiente e os parâmetros da rede neural são atualizados após cada amostra.


A métrica em que nos concentraremos é o *gap de generalização*, que é definido como a diferença entre o valor do tempo de treinamento e o valor do tempo de teste. Vamos investigar o tamanho do lote no contexto da classificação de imagens (o mesmo usado em diversos capítulos anteriores). Especificamente, usaremos o conjunto de dados MNIST. 


No nosso caso, a diferença de generalização é simplesmente a diferença entre a precisão da classificação no tempo de teste e o tempo de treinamento. Estas experiências foram destinadas a fornecer alguma intuição básica sobre os efeitos do tamanho do lote. É bem conhecido na comunidade de aprendizado de máquina que a dificuldade de fazer afirmações gerais sobre os efeitos de hiperparâmetros geralmente varia de conjunto de dados a conjunto de dados e modelo a modelo. Portanto, as conclusões que fazemos aqui só podem servir como indicações em vez de declarações gerais sobre o tamanho do lote.


O tamanho do lote é um dos hiperparâmetros mais importantes para sintonizar os modernos sistemas de aprendizagem profunda. Os [Cientistas de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) muitas vezes querem usar um tamanho de lote maior para treinar seu modelo, uma vez que permite acelerações computacionais do paralelismo das GPUs. No entanto, é bem conhecido que um tamanho de lote muito grande levará a uma generalização deficiente (embora atualmente não se saiba exatamente porque isso acontece). Para as funções convexas que estamos tentando otimizar, há uma disputa inerente entre os benefícios de tamanhos de lotes menores e maiores. 


Por um lado, usar um lote igual a todo o conjunto de dados garante a convergência para o ótimo global da função objetivo. No entanto, isso é à custa de uma convergência empírica mais lenta para esse ótimo. Por outro lado, o uso de tamanhos menores de lotes mostrou empiricamente uma convergência mais rápida para soluções “boas”. Isso é intuitivamente explicado pelo fato de que tamanhos de lote menores permitem que o modelo “inicie o aprendizado antes de ver todos os dados”. A desvantagem de usar um tamanho de lote menor é que não há garantia que o modelo vai convergir para o ótimo global. Ele irá saltar em torno do ótimo global, dependendo da relação entre o tamanho do lote e o tamanho do conjunto de dados. 


Portanto, sob nenhuma restrição computacional, muitas vezes é aconselhável que se comece com um pequeno tamanho de lote, colhendo os benefícios de uma dinâmica de treinamento mais rápida, e aumente o tamanho do lote por meio de treinamento, aproveitando também os benefícios da convergência garantida.


Observou-se empiricamente que tamanhos de lote menores não só têm uma dinâmica de treinamento mais rápida, mas também generalização para o conjunto de dados de teste versus tamanhos de lote maiores. Mas esta afirmação tem seus limites. Sabemos que um tamanho de lote de 1 geralmente funciona muito mal. É geralmente aceito que existe um “ponto ideal” para o tamanho do lote entre 1 e todo o conjunto de dados de treinamento que fornecerá a melhor generalização. Esse “ponto ideal” geralmente depende do conjunto de dados e do modelo em questão. 


A razão para uma melhor generalização é vagamente atribuída à existência de “ruído” no treinamento de pequeno tamanho de lote. Como os sistemas de redes neurais são extremamente propensos a ajustes excessivos (overfitting), a ideia é que a visualização de vários tamanhos de lote pequenos, cada lote sendo uma representação “ruidosa” de todo o conjunto de dados, causará uma espécie de dinâmica de “tug-and-pull”. Essa dinâmica evita que a rede neural se ajuste excessivamente no conjunto de treinamento e, portanto, tenha um desempenho ruim no conjunto de testes.


Definição do Problema
---------------------


O problema exato que será investigado é o da classificação. Dada uma imagem X, o objetivo é prever o rótulo da imagem y. No caso do conjunto de dados MNIST, X são imagens em preto-e-branco dos dígitos 0 a 9 e y são as etiquetas de dígitos correspondentes “0” a “9”. Nosso modelo de escolha é uma rede neural. Especificamente, usaremos um Perceptron Multicamada (MLP). Salvo disposição em contrário, este é o modelo padrão foi usado no experimento:


* 2 camadas ocultas totalmente conectadas (FC), 1024 unidades cada
* Função de ativação ReLU
* Função de perda: logaritmo negativo
* Otimizador: SGD (Stochastic Gradient Descent)
* Taxa de aprendizagem: 0,01
* Épocas: 30


Em última análise, a pergunta que queremos responder é “qual tamanho de lote devo usar ao treinar uma rede neural?”


Efeito do Tamanho do Lote
-------------------------


A primeira coisa que devemos fazer para confirmar o problema que estamos tentando investigar é mostrar a dependência entre o intervalo de generalização e o tamanho do lote. Eu tenho me referido à métrica que estamos considerando como “gap de generalização”. Essa é tipicamente a medida de autores sobre o tema usada em artigos e papers, mas para simplicidade em nosso estudo nós apenas nos preocuparemos com a precisão do teste sendo a mais alta possível. Como veremos, a precisão de treinamento e teste dependerá do tamanho do lote, por isso é mais significativo falar sobre a precisão de teste em vez do gap de generalização. Mais especificamente, queremos que a precisão do teste depois de um grande número de épocas de treinamento, seja alta. Quantas épocas é um “grande número de épocas”? Idealmente, isso é definido como o número de épocas de treinamento necessárias, de modo que qualquer treinamento adicional forneça pouco ou nenhum aumento na precisão de teste. Na prática, isso é difícil de determinar e teremos que adivinhar quantas épocas são apropriadas para alcançar um comportamento ideal. Apresento as precisões de teste do nosso modelo de rede neural treinado usando diferentes tamanhos de lote abaixo (para aprender a fazer tudo isso na prática, clique [aqui](https://www.datascienceacademy.com.br/pages/formacao-inteligencia-artificial)).


 


![grafico](https://www.deeplearningbook.com.br/wp-content/uploads/2019/02/grafico.png)


![grafico2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/02/grafico2.png)


 


Curvas em laranja: tamanho do lote 64  

Curvas em verde: tamanho do lote 256  

Curvas em lilás: tamanho do lote 1024


**Descoberta: tamanhos maiores de lotes levam a uma precisão menor nos dados de teste.**


O eixo x mostra o número de épocas de treinamento. O eixo y é rotulado para cada plotagem. MNIST é obviamente um conjunto de dados fácil de treinar; podemos alcançar 100% de precisão em treino e 98% em teste com apenas nosso modelo MLP base no tamanho de lote 64. Além disso, vemos uma clara tendência entre o tamanho do lote e a precisão do teste (e treinamento!). A nossa primeira conclusão é a seguinte: maiores tamanhos de lotes levam a uma menor precisão nos dados de teste. Esses padrões parecem existir em seu extremo para o conjunto de dados MNIST. Eu tentei tamanho de lote igual a 2 e alcançou uma precisão de teste ainda melhor de 99% (versus 98% para tamanho de lote 64)! Como aviso prévio, não espere que tamanhos de lote muito baixos, como 2, funcionem bem em conjuntos de dados mais complexos.


Mas neste experimento não consideramos alterações na taxa de aprendizagem. Poderíamos aumentar a acurácia em teste com tamanhos de lote maiores, ajustando a taxa de aprendizagem (learning rate)? Não perca o próximo capítulo para descobrir! Até lá.


Referências:


[Don’t Decay the Learning Rate, Increase the Batch Size](https://arxiv.org/pdf/1711.00489.pdf)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Effect of batch size on training dynamics](https://medium.com/mini-distill/effect-of-batch-size-on-training-dynamics-21c14f7a716e)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)(material usado com autorização do autor)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-38---o-efeito-da-taxa-de-aprendizagem-no-treinamento-de-redes-neurais-artificiais"></div>

# Capítulo 38 – O Efeito da Taxa de Aprendizagem no Treinamento de Redes Neurais Artificiais


Vamos retomar a discussão do capítulo [anterior](https://www.deeplearningbook.com.br/o-efeito-do-batch-size-no-treinamento-de-redes-neurais-artificiais/) e tentar melhorar a precisão do modelo nos dados de teste a partir de um tamanho de lote maior, aumentando a taxa de aprendizado (learning rate). Vamos estudar O Efeito da Taxa de Aprendizagem no Treinamento de Redes Neurais Artificiais.


Algumas pesquisas na literatura sobre otimização em Machine Learning mostraram que aumentar a taxa de aprendizado pode compensar tamanhos maiores de lotes. Com isso em mente, aumentamos a taxa de aprendizado do nosso modelo para ver se podemos recuperar a precisão nos dados de teste (que havia sido reduzida quando aumentando o tamanho do lote). Os gráficos abaixo mostram as conclusões:


 


![graf1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/02/graf1.png)


![graf2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/02/graf2.png)


 


Curvas em laranja: tamanho do lote 64, taxa de aprendizagem 0.01 (referência)  

Curvas em lilás: tamanho do lote 1024, taxa de aprendizado de 0,01 (referência)  

Curvas em azul: tamanho do lote 1024, taxa de aprendizagem 0,1


As curvas em laranja e lilás são para referência e são as mesmas do conjunto de gráficos do capítulo anterior. Como a curva lilás, a curva azul treina com um tamanho de lote grande de 1024. No entanto, a curva azul tem uma taxa de aprendizado aumentada em 10 vezes. **Curiosamente, podemos recuperar a precisão nos dados de teste a partir de um tamanho de lote maior, aumentando a taxa de aprendizado**. Usando um tamanho de lote de 64 (laranja) atinge uma precisão de teste de 98%, enquanto o uso de um tamanho de lote de 1024 atinge apenas cerca de 96%. Mas aumentando a taxa de aprendizado, usando um tamanho de lote de 1024 também alcança uma precisão de teste de 98%. Assim como com nossa conclusão anterior, tenha cautela ao analisar esses resultados. Sabe-se que o simples aumento da taxa de aprendizado não compensa totalmente grandes tamanhos de lotes em conjuntos de dados mais complexos do que o MNIST.


### E qual o efeito ao reduzir o tamanho do lote durante o treinamento do modelo?


A próxima pergunta interessante a ser feita é se o treinamento com lotes grandes “inicia você em um caminho ruim do qual você não pode se recuperar”. Ou seja, se começarmos a treinar com tamanho de lote 1024, então mudamos para tamanho de lote 64, podemos ainda alcançar a maior precisão em teste de 98%? 


Investigamos três casos: treinar usando um tamanho de lote pequeno para uma única época, mudar para um tamanho de lote grande, treinar usando um tamanho de lote pequeno para muitas épocas e mudar para um tamanho maior de lote e treinar usando um tamanho grande de lote e então usar uma taxa de aprendizado mais alta com o mesmo tamanho de lote. Resultados abaixo:


 


![graf3](https://www.deeplearningbook.com.br/wp-content/uploads/2019/02/graf3.png)


![graf4](https://www.deeplearningbook.com.br/wp-content/uploads/2019/02/graf4.png)


 


* Curvas em laranja: treinar em tamanho de lote 64 por 30 épocas (referência).
* Curvas em amarelo neon: treinar em tamanho de lote 1024 por 60 épocas (referência).
* Curvas em verde: treinar em tamanho de lote 1024 para 1 época e depois mudar para tamanho de lote 64 por 30 épocas (total de 31 épocas).
* Curvas em amarelo escuro: treinar em tamanho de lote 1024 por 30 épocas e depois mudar para tamanho de lote 64 por 30 épocas (total de 60 épocas).
* Curvas em lilás: treinamento em tamanho de lote 1024 e aumento da taxa de aprendizado em 10x na época 31 (total de 60 épocas).


Como antes, as curvas em laranja são para um tamanho de lote pequeno. As curvas em amarelo neon servem como um controle para garantir que não estamos melhorando a precisão do teste porque estamos simplesmente treinando mais. Se você prestar muita atenção ao eixo x, as épocas são enumeradas de 0 a 30. Isso ocorre porque somente as últimas 30 épocas de treinamento são mostradas. Para experimentos com mais de 30 épocas de treinamento no total, as primeiras x – 30 épocas foram omitidas.


É difícil ver as outras 3 linhas porque elas estão sobrepostas, mas não importa, porque nos três casos recuperamos a precisão em teste de 98%! Em conclusão, começar com um tamanho grande de lote não “pega o modelo preso” em alguma vizinhança de ótimos locais ideais. O modelo pode alternar para um tamanho de lote menor ou uma taxa de aprendizado mais alta a qualquer momento para obter uma precisão de teste melhor.


Para compreender o comportamento matemático por trás de todo esse processo, precisamos trazer o gradiente para esta discussão. É o que faremos no próximo capítulo. Até lá.


Referências:


[Don’t Decay the Learning Rate, Increase the Batch Size](https://arxiv.org/pdf/1711.00489.pdf)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Effect of batch size on training dynamics](https://medium.com/mini-distill/effect-of-batch-size-on-training-dynamics-21c14f7a716e)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-39---relacao-entre-o-tamanho-do-lote-e-o-calculo-do-gradiente"></div>

# Capítulo 39 – Relação Entre o Tamanho do Lote e o Cálculo do Gradiente


Vamos continuar com a discussão dos dois [capítulos anteriores](https://www.deeplearningbook.com.br/relacao-entre-o-tamanho-do-lote-e-o-calculo-do-gradiente/) e investigar a Relação Entre o Tamanho do Lote e o Cálculo do Gradiente.


Como explicar porque o treinamento com lotes maiores leva a uma precisão menor nos testes? Uma hipótese pode ser que as amostras de treinamento no mesmo lote interfiram (competem) com o gradiente um do outro. Uma amostra deseja mover os pesos do modelo em uma direção, enquanto outra amostra deseja mover os pesos na direção oposta. Portanto, seus gradientes tendem a ser cancelados e você obtém um pequeno gradiente geral. Talvez, se as amostras forem divididas em dois lotes, a concorrência será reduzida, pois o modelo poderá encontrar pesos que satisfarão as duas amostras, se forem feitas em sequência. Em outras palavras, a otimização sequencial de amostras é mais fácil do que a otimização simultânea em espaços de parâmetros complexos e de alta dimensão.


A hipótese é representada graficamente abaixo. A seta lilás mostra um único degrau de gradiente descendente usando um tamanho de lote de 2. As setas azul e vermelha mostram duas etapas sucessivas de descida do gradiente usando um tamanho de lote 1. A seta preta é a soma vetorial das setas azul e vermelha e representa o progresso geral que o modelo faz em duas etapas de tamanho de lote 1. Ambos os experimentos começam com os mesmos pesos no espaço de pesos. Embora não seja explicitamente mostrado na imagem, a hipótese é que a linha lilás é muito mais curta que a linha preta, devido à concorrência dos gradientes. Em outras palavras, o gradiente de uma única etapa de tamanho de lote grande é menor que a soma de gradientes de várias etapas de tamanho de lote pequeno.


 


![grad](https://www.deeplearningbook.com.br/wp-content/uploads/2019/03/grad.png)


 


O experimento envolve a replicação da imagem mostrada acima. Nós treinamos o modelo para um determinado estado. Em seguida, o grupo de controle (seta lilás) é calculado encontrando o gradiente de etapa única com tamanho de lote 1024. O grupo experimental (seta preta) é calculado fazendo várias etapas de gradiente e encontrando a soma vetorial desses gradientes usando um tamanho de lote menor. O produto do número de etapas e do tamanho do lote é constante em 1024. Isso representa modelos diferentes que veem um número fixo de amostras. 


Por exemplo, para um tamanho de lote de 64, fazemos 1024/64 = 16 etapas, somando os 16 gradientes para encontrar o gradiente geral. Para tamanho de lote 1024, fazemos 1024/1024 = 1 passo. Observe que, para os tamanhos de lote menores, amostras diferentes são desenhadas para cada lote. A ideia é comparar os gradientes do modelo para diferentes tamanhos de lotes após os modelos terem visto o mesmo número de amostras. Como última advertência, para simplificar, apenas medimos o gradiente da última camada do nosso modelo MLP (Multilayer Perceptron), que possui 1024 ⋅ 10 = 10240 pesos.


Investigamos os seguintes tamanhos de lote: 1, 2, 3, 4, 5, 6, 7, 8, 16, 32, 64, 128, 256, 512, 1024.


Um teste significou:


1. Carregamento / redefinição dos pesos do modelo para um ponto treinado fixo (usamos os pesos do modelo após o treinamento para 2/30 epochs em tamanho de lote 1024).
2. Amostragem aleatória de 1024 amostras de dados do conjunto de treinamento.
3. Treinamento do modelo através de todas as 1024 amostras de dados uma vez, com diferentes tamanhos de lote.


Para cada tamanho de lote, repetimos o experimento mil vezes. Não coletamos mais dados porque armazenar os tensores de gradiente é realmente muito caro (mantivemos os tensores de cada tentativa para computar estatísticas de ordem mais alta mais tarde). O tamanho total do arquivo com tensores de gradiente foi de 600 MB.


Para cada um dos 1000 ensaios, computamos a norma euclidiana do tensor de gradiente somado (seta preta na nossa imagem). Então, calculamos a média e o desvio padrão dessas normas ao longo dos 1000 testes. Isso é feito para cada tamanho de lote.


Eu queria investigar dois regimes de peso diferentes: no início do treinamento, quando os pesos não convergiam e muito aprendizado ocorria e, mais tarde, durante o treinamento, quando os pesos quase convergiam e o aprendizado mínimo estava ocorrendo. Para o regime inicial, eu treinei o modelo MLP para 2 épocas com tamanho de lote 1024 e para o regime posterior, eu treinei o modelo por 30 épocas.


![graph](https://www.deeplearningbook.com.br/wp-content/uploads/2019/03/graph.png)


**Descoberta: tamanhos de lotes maiores produzem etapas de gradiente maiores do que tamanhos de lotes menores para o mesmo número de amostras vistas.**


O eixo x mostra o tamanho do lote. O eixo y mostra a norma euclidiana média de tensores de gradiente em 1000 tentativas. As barras de erro indicam a variação da norma euclidiana em 1000 tentativas. Os pontos azuis é o experimento realizado no regime inicial, onde o modelo foi treinado por 2 épocas. Os pontos verdes é o regime posterior em que o modelo foi treinado por 30 épocas. Como esperado, o gradiente é maior no início do treinamento (os pontos azuis são maiores que os pontos verdes). 


Ao contrário da nossa hipótese, a norma gradiente média aumenta com o tamanho do lote! Esperávamos que os gradientes fossem menores para um tamanho de lote maior devido à competição entre as amostras de dados. Em vez disso, o que encontramos é que tamanhos maiores de lotes fazem etapas de gradiente maiores do que tamanhos de lote menores para o mesmo número de amostras vistas. Observe que a norma euclidiana pode ser interpretada como a distância euclidiana entre o novo conjunto de pesos e o conjunto inicial de pesos. Portanto, o treinamento com lotes grandes tende a se afastar dos pesos iniciais depois de ver um número fixo de amostras do que o treinamento com tamanhos de lote menores. A relação entre o tamanho do lote e a norma de gradiente é √x. Em outras palavras, a relação entre o tamanho do lote e a norma do gradiente quadrado é linear.


Além disso, a variação é muito menor para tamanhos menores de lotes. No entanto, o que podemos nos interessar é a magnitude da variância em relação à magnitude da média. Portanto, para fazer uma comparação mais perspicaz, dimensiono a média e o desvio padrão de cada tamanho de lote para a média do tamanho do lote 1024. Em outras palavras,


![form](https://www.deeplearningbook.com.br/wp-content/uploads/2019/03/form.png)


onde as barras representam valores normalizados e i indica um determinado tamanho de lote.


Justificamos o dimensionamento da média e do desvio padrão da norma de gradiente porque isso é equivalente a aumentar a taxa de aprendizado para o experimento com tamanhos de lote menores. Essencialmente, queremos saber “pela mesma distância afastada dos pesos iniciais, qual é a variação nas normas de gradiente para diferentes tamanhos de lote”? Tenha em mente que estamos medindo a variação nas normas de gradiente e não a variação nos gradientes em si, que é uma métrica muito mais precisa.


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/03/form2.png)


**Descoberta: Para a mesma distância média da norma euclidiana dos pesos iniciais do modelo, tamanhos de lote maiores têm maior variância na distância.**


Nós vemos um resultado muito surpreendente acima. Para a mesma distância média da norma euclidiana dos pesos iniciais do modelo, tamanhos de lote maiores têm maior variância na distância. Isso é bastante! Em suma, dados dois modelos treinados com tamanhos de lotes diferentes, em qualquer gradiente em particular, se a taxa de aprendizado for ajustada de modo que ambos os modelos se movam em média na mesma distância, o modelo com o tamanho maior do lote variará mais em relação a sua movimentação. Isso é um pouco contra-intuitivo, pois é bem conhecido que tamanhos menores de lotes são “ruidosos” e, portanto, você pode esperar que a variação da norma de gradiente seja maior. 


Observe que, para cada teste, estamos usando 1024 amostras diferentes, em vez de usar as mesmas 1024 amostras em todos os testes. Observe também que a variação entre os testes pode ser causada por duas coisas: as diferentes amostras que são extraídas do conjunto de dados entre os diferentes testes e a semente aleatória para cada teste (que não foi controlada, mas deve realmente ser). Seguindo em frente, vou supor que a variação é causada pelo primeiro fator: amostras diferentes. Este é um resultado interessante e poderíamos seguir esta investigação por muitos capítulos. Mas por hora, você já recebeu informação suficiente para compreender a Relação Entre o Tamanho do Lote e o Cálculo do Gradiente. Esse tipo de experimento é muito importante em trabalhos de pesquisa e desenvolvimento de novos modelos!


Podemos assim concluir mais uma etapa deste livro e começar nossa última e mais emocionante jornada de aprendizagem, estudando as principais arquiteturas de Deep Learning. Eu não perderia se fosse você! Até o próximo capítulo!


Referências:


[Formação Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Don’t Decay the Learning Rate, Increase the Batch Size](https://arxiv.org/pdf/1711.00489.pdf)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Effect of batch size on training dynamics](https://medium.com/mini-distill/effect-of-batch-size-on-training-dynamics-21c14f7a716e)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-40---introducao-as-redes-neurais-convolucionais"></div>

# Capítulo 40 – Introdução às Redes Neurais Convolucionais


Nos primeiros capítulos deste livro ensinamos nossas redes neurais a fazer um bom trabalho reconhecendo imagens de dígitos manuscritos:


 


![digits](https://www.deeplearningbook.com.br/wp-content/uploads/2019/03/digits-300x62.png)


 


Fizemos isso usando redes nas quais camadas adjacentes são totalmente conectadas umas às outras. Ou seja, todos os neurônios da rede estão conectados a todos os neurônios em camadas adjacentes:


 


![rede](https://www.deeplearningbook.com.br/wp-content/uploads/2019/03/rede.png)


 


Em particular, para cada pixel na imagem de entrada, codificamos a intensidade do pixel como o valor de um neurônio correspondente na camada de entrada. Para as imagens de 28 × 28 pixels que estamos usando, isso significa que nossa rede tem 784 (= 28 × 28) neurônios de entrada. Em seguida, treinamos os pesos e vieses da rede para que a saída da rede identificasse corretamente a imagem de entrada: ‘0’, ‘1’, ‘2’, …, ‘8’ ou ‘9’.


Nossas redes anteriores funcionam muito bem: obtivemos uma precisão de classificação melhor que 98%, usando dados de treinamento e teste do conjunto de dados de dígitos manuscritos MNIST. Mas, após reflexão, é estranho usar redes com camadas totalmente conectadas para classificar imagens. A razão é que tal arquitetura de rede não leva em conta a estrutura espacial das imagens. 


Por exemplo, ela trata os pixels de entrada que estão distantes e próximos exatamente no mesmo nível. Tais conceitos de estrutura espacial devem ser inferidos dos dados de treinamento. Mas e se, em vez de começarmos com uma arquitetura de rede que é rasa, utilizássemos uma arquitetura que tenta tirar proveito da estrutura espacial? É onde entram as redes neurais convolucionais.


Essas redes usam uma arquitetura especial que é particularmente bem adaptada para classificar imagens. O uso dessa arquitetura torna as redes convolucionais rápidas de treinar. Isso, por sua vez, nos ajuda a treinar redes profundas de muitas camadas, que são muito boas na classificação de imagens. Hoje, redes neurais convolucionais ou alguma variante próxima são usadas na maioria das redes neurais para reconhecimento de imagem.


As origens das redes neurais convolucionais remontam aos anos 70. Mas o artigo seminal que estabeleceu o tema moderno das redes convolucionais foi um artigo de 1998, “[Gradient-based learning applied to document recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-98.pdf)“, de Yann LeCun, Léon Bottou, Yoshua Bengio e Patrick Haffner. Desde então, LeCun fez uma observação interessante sobre a terminologia para redes convolucionais: “A inspiração neural [biológica] em modelos como redes convolucionais é muito tênue. É por isso que eu os chamo de ‘redes convolucionais’ e não ‘redes neurais convolucionais’, e por isso os nós eu chamo de ‘unidades’ e não ‘neurônios’ “. 


Apesar desta observação, as redes convolucionais usam muitas das mesmas ideias que as redes neurais que estudamos até agora: ideias como retropropagação, gradiente descendente, regularização, funções de ativação não lineares e assim por diante. E assim, vamos seguir a prática comum e considerá-las um tipo de rede neural. Usarei os termos “rede neural convolucional” e “rede convolucional” alternadamente. Também usarei os termos “neurônio [artificial]” e “unidade” alternadamente.


### Definição


Uma Rede Neural Convolucional (ConvNet / Convolutional Neural Network / CNN) é um algoritmo de Aprendizado Profundo que pode captar uma imagem de entrada, atribuir importância (pesos e vieses que podem ser aprendidos) a vários aspectos / objetos da imagem e ser capaz de diferenciar um do outro. O pré-processamento exigido em uma ConvNet é muito menor em comparação com outros algoritmos de classificação. Enquanto nos métodos primitivos os filtros são feitos à mão, com treinamento suficiente, as ConvNets têm a capacidade de aprender esses filtros / características.


A arquitetura de uma ConvNet é análoga àquela do padrão de conectividade de neurônios no cérebro humano e foi inspirada na organização do Visual Cortex. Os neurônios individuais respondem a estímulos apenas em uma região restrita do campo visual conhecida como Campo Receptivo. Uma coleção desses campos se sobrepõe para cobrir toda a área visual. Veremos isso em detalhes mais a frente!


### Por que usar ConvNets e não rede feed-forward?


Uma imagem não é nada além de uma matriz de valores de pixels, certo? Então, por que não apenas achatar a imagem (por exemplo, converter uma matriz 3×3 em um vetor 9×1. Se a image é uma matriz, nenhum problema em converter em uma vetor) e alimentá-lo para um Perceptron Multi-Layer para fins de classificação? Na verdade não.


Em casos de imagens binárias extremamente básicas, o método pode mostrar uma pontuação de precisão média durante a previsão de classes, mas teria pouca ou nenhuma precisão quando se trata de imagens complexas com dependências de pixel por toda parte.


Uma ConvNet é capaz de capturar com sucesso as dependências espaciais e temporais em uma imagem através da aplicação de filtros relevantes. A arquitetura executa um melhor ajuste ao conjunto de dados da imagem devido à redução no número de parâmetros envolvidos e à capacidade de reutilização dos pesos. Em outras palavras, a rede pode ser treinada para entender melhor a sofisticação da imagem.


 


![rede2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/03/rede2.png)


 


Na figura acima, temos uma imagem RGB (Red – Green – Blue) que foi separada por seus três planos coloridos – Vermelho, Verde e Azul. Existem vários desses espaços de cores nos quais existem imagens – Escala de cinza, RGB, HSV, CMYK etc.


Você pode imaginar como a computação ficaria intensiva assim que as imagens atingissem dimensões, digamos, 8K (7680 × 4320). A função da ConvNet é reduzir as imagens para uma forma mais fácil de processar, sem perder recursos que são críticos para obter uma boa previsão. Isso é importante quando queremos projetar uma arquitetura que não seja apenas boa em recursos de aprendizado, mas que também seja escalável para conjuntos de dados massivos.


Essa é uma das arquiteturas de Deep Learning mais incríveis e com mais aplicações práticas e dedicaremos alguns capítulos a este arquitetura.


As redes neurais convolucionais usam três ideias básicas: campos receptivos locais, pesos compartilhados e pooling. Vamos dar uma olhada em cada uma dessas ideias? Então não perca os próximos capítulos!


Referências:


[Análise de Imagens com Inteligência Artificial](https://www.datascienceacademy.com.br/course/analise-de-imagens-com-inteligencia-artificial)


[Formação Análise Estatística](https://www.datascienceacademy.com.br/bundle/formacao-analise-estatistica)


[Don’t Decay the Learning Rate, Increase the Batch Size](https://arxiv.org/pdf/1711.00489.pdf)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[A Comprehensive Guide to Convolutional Neural Networks](https://towardsdatascience.com/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-41---campos-receptivos-locais-em-redes-neurais-convolucionais"></div>

# Capítulo 41 – Campos Receptivos Locais em Redes Neurais Convolucionais


Vamos estudar em detalhes a partir de agora as Redes Neurais Convolucionais, uma das principais arquiteturas de Deep Learning, amplamente usada em Visão Computacional. E começaremos compreendendo o que são os Campos Receptivos Locais. Mas antes, afinal, o que é Visão Computacional, amplamente usada em aplicações de [Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)?


O Que é Visão Computacional?
----------------------------


Imagine a seguinte situação: você está em uma sala com mais duas pessoas. Uma delas arremessa uma bola e você a pega com as mãos. Nada poderia ser mais simples, certo?


Errado. Na verdade, este é um dos processos mais complexos que já tentamos compreender, ou seja, como o cérebro processa a visão de modo que sabemos exatamente o que é uma bola e quando ela está vindo em nossa direção? E ensinar uma máquina que seja capaz de ver da mesma forma que nós seres humanos é uma tarefa realmente difícil, não só porque é difícil fazer computadores executarem um cálculo matemático que reproduza a visão humana, mas porque não estamos inteiramente certos de como o processo da visão realmente funciona.


Primeiro vamos descrever de forma sucinta e aproximada como ocorre o processo de visão no caso do arremesso da bola: a imagem da esfera passa através de seu olho e chega a sua retina, que faz alguma análise elementar e envia o resultado ao cérebro, onde o córtex visual analisa mais profundamente a imagem. Em seguida, ele envia para o resto do córtex, que compara a tudo o que já sabe, classifica os objetos e dimensões e, finalmente, decide sobre algo a fazer: levantar a mão e pegar a bola (tendo previsto o seu caminho). Isso ocorre em uma pequena fração de segundo, com quase nenhum esforço consciente e quase nunca falha. Assim, recriar a visão humana não é apenas um problema difícil, é um conjunto deles, cada um dos quais depende do outro. 


A [Visão Computacional](https://www.datascienceacademy.com.br/course/analise-de-imagens-com-inteligencia-artificial) é o processo de modelagem e replicação da visão humana usando software e hardware. A Visão Computacional é uma disciplina que estuda como reconstruir, interromper e compreender uma cena 3d a partir de suas imagens 2d em termos das propriedades da estrutura presente na cena.


Visão Computacional e reconhecimento de imagem são termos frequentemente usados como sinônimos, mas o primeiro abrange mais do que apenas analisar imagens. Isso porque, mesmo para os seres humanos, “ver” também envolve a percepção em muitas outras frentes, juntamente com uma série de análises. Cada ser humano usa cerca de dois terços do seu cérebro para o processamento visual, por isso não é nenhuma surpresa que os computadores precisariam usar mais do que apenas o reconhecimento de imagem para obter sua visão de forma correta.


O reconhecimento de imagens em si – a análise de pixel e padrão de imagens – é uma parte integrante do processo de Visão Computacional que envolve tudo, desde reconhecimento de objetos e caracteres até análise de texto e sentimento. O reconhecimento de imagem de hoje, ainda na maior parte, apenas identifica objetos básicos como “uma banana ou uma bicicleta em uma imagem.” Mesmo crianças podem fazer isso, mas o potencial da Visão Computacional é sobre-humano: ser capaz de ver claramente no escuro, através de paredes, em longas distâncias e processar todos esses dados rapidamente e em volume maciço. 


Já a Visão Computacional em seu sentido mais pleno está sendo usada na vida cotidiana e nos negócios para conduzir todos os tipos de tarefas, incluindo identificar doenças médicas em raios-x, identificar produtos e onde comprá-los, anúncios dentro de imagens editoriais, entre outros. 


A Visão Computacional pode ser usada para digitalizar plataformas de mídia social a fim de encontrar imagens relevantes que não podem ser descobertas por meio de pesquisas tradicionais. A tecnologia é complexa e, assim como todas as tarefas acima mencionadas, requer mais do que apenas reconhecimento de imagem, mas também análise semântica de grandes conjuntos de dados. E a Visão Computacional é a principal técnica por trás dos veículos autônomos, que devem mudar completamente o mundo como o conhecemos.


Ninguém nunca disse que isso seria fácil. Exceto, talvez, Marvin Minsky, pioneiro da Inteligência Artificial, que, em 1966, instruía um estudante de pós-graduação a “conectar uma câmera a um computador e fazer com que descrevesse o que vê”. Mas a verdade é que 50 anos depois, ainda estamos trabalhando nisso, porém agora há uma diferença (ou duas talvez): temos Big Data e Processamento Paralelo em GPU’s. E acredite. Isso está realmente fazendo a diferença.


As Redes Neurais Convolucionais formam uma das arquiteturas de Deep Learning mais amplamente usada em tarefas de Visão Computacional e reconhecimento de imagens e a partir de agora vamos compreender porque.


Campos Receptivos Locais
------------------------


Nas camadas totalmente conectadas mostradas no capítulo [anterior](https://www.deeplearningbook.com.br/introducao-as-redes-neurais-convolucionais/), as entradas foram representadas como uma linha vertical de neurônios. Ou seja, convertemos uma imagem 28 x 28 (que é uma matriz) em um vetor de apenas uma dimensão (falaremos sobre isso mais adiante). Mas para compreender o que é um campo receptivo local, vamos considerar a imagem de seu formato padrão de 28x 28 (tamanho das imagens no dataset MNIST). Em uma imagem, cada pixel é um valor numérico que representa a intensidade de cor de acordo com a escala de cor utilizada, como RGB (Red – Green – Blue), por exemplo, ou apenas intensidade em escala de cinza para imagens em preto e branco.


![rede1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/04/rede1.png)


Como de costume, vamos conectar os pixels de entrada a uma camada de neurônios ocultos. Mas não vamos conectar todos os pixels de entrada a cada neurônio oculto. Em vez disso, apenas fazemos conexões em regiões pequenas e localizadas da imagem de entrada.


Para ser mais preciso, cada neurônio na primeira camada oculta será conectado a uma pequena região dos neurônios de entrada, digamos, por exemplo, uma região de 5 × 5, correspondendo a 25 pixels de entrada. Assim, para um neurônio oculto em particular, podemos ter conexões que se parecem com isso:


![rede2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/04/rede2.png)


Essa região na imagem de entrada é chamada de **campo receptivo local** para o neurônio oculto. É uma pequena janela nos pixels de entrada. Cada conexão aprende um peso e o neurônio oculto também aprende um viés (bias) geral. Você pode pensar nesse neurônio oculto particular como aprendendo a analisar seu campo receptivo local específico.


Em seguida, deslizamos o campo receptivo local por toda a imagem de entrada. Para cada campo receptivo local, existe um neurônio oculto diferente na primeira camada oculta. Para ilustrar isso concretamente, vamos começar com um campo receptivo local no canto superior esquerdo:


![rede3](https://www.deeplearningbook.com.br/wp-content/uploads/2019/04/rede3.png)


Então, deslizamos o campo receptivo local por um pixel para a direita (ou seja, por um neurônio), para conectar a um segundo neurônio oculto:


![rede4](https://www.deeplearningbook.com.br/wp-content/uploads/2019/04/rede4.png)


E assim por diante, construindo a primeira camada oculta. Observe que, se tivermos uma imagem de entrada 28 × 28 e campos receptivos locais 5 × 5, haverá 24 × 24 neurônios na camada oculta. Isso ocorre porque só podemos mover o campo receptivo local 23 neurônios para o lado (ou 23 neurônios para baixo), antes de colidir com o lado direito (ou inferior) da imagem de entrada.


Mostramos o campo receptivo local sendo movido por um pixel por vez. Na verdade, às vezes, um comprimento de passada diferente é usado. Por exemplo, podemos mover o campo receptivo local 2 pixels para a direita (ou para baixo), caso em que diríamos que um comprimento de passada de 2 é usado. Esse é um dos hyperparâmetros de uma rede neural convolucional, chamado stride length. No exemplo acima usado um stride length de 1, mas vale a pena saber que as pessoas às vezes experimentam comprimentos de passada diferentes.


Como foi feito nos capítulos anteriores, se estivermos interessados em testar comprimentos de passada diferentes, podemos usar os dados de validação para escolher o comprimento da passada que oferece o melhor desempenho. A mesma abordagem também pode ser usada para escolher o tamanho do campo receptivo local – não há, é claro, nada de especial sobre o uso de um campo receptivo local 5 × 5. Em geral, campos receptivos locais maiores tendem a ser úteis quando as imagens de entrada são significativamente maiores que as imagens MNIST de 28 × 28 pixels.


Eu já disse que cada neurônio oculto tem um viés e pesos 5 × 5 conectados ao seu campo receptivo local. O que eu ainda não mencionei é que vamos usar os mesmos pesos e vieses para cada um dos 24 × 24 neurônios ocultos. Quer saber como faremos isso matematicamente? Então não perca o próximo capítulo!


Referências:


[Análise de Imagens com Inteligência Artificial](https://www.datascienceacademy.com.br/course/analise-de-imagens-com-inteligencia-artificial)


[Don’t Decay the Learning Rate, Increase the Batch Size](https://arxiv.org/pdf/1711.00489.pdf)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[A Comprehensive Guide to Convolutional Neural Networks](https://towardsdatascience.com/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-42---compartilhamento-de-pesos-em-redes-neurais-convolucionais"></div>

# Capítulo 42 – Compartilhamento de Pesos em Redes Neurais Convolucionais


Vamos continuar estudando Deep Learning e investigar como funciona o Compartilhamento de Pesos em Redes Neurais Convolucionais. 


Já dissemos que cada neurônio tem um viés e pesos 5 × 5 conectados ao seu [campo receptivo local](https://www.deeplearningbook.com.br/campos-receptivos-locais-em-redes-neurais-convolucionais/). O que eu não mencionamos é que vamos usar os mesmos pesos e vieses para cada um dos 24 × 24 neurônios ocultos. Em outras palavras, para o neurônio oculto, a saída é:


 


![form](https://www.deeplearningbook.com.br/wp-content/uploads/2019/04/form-300x106.png)


 


Isso significa que todos os neurônios da primeira camada oculta detectam exatamente o mesmo recurso, apenas em locais diferentes na imagem de entrada. Para entender porque isso faz sentido, suponha que os pesos e os vieses sejam tais que o neurônio oculto possa escolher, digamos, uma borda vertical em um campo receptivo local específico. Essa habilidade também é útil em outros lugares da imagem. Por isso, é útil aplicar o mesmo detector de recursos em toda a imagem. Para colocar esse conceito em termos um pouco mais abstratos, as redes convolucionais são bem adaptadas à invariância da transalação das imagens: girar uma foto de um gato 90 graus, ainda faz dela a imagem de um gato, embora os pixels agora estejam organizados de forma diferente.


Por esse motivo, às vezes chamamos o mapa da camada de entrada para a camada oculta de um mapa de recursos. Chamamos os pesos que definem o mapa de recursos de pesos compartilhados. E nós chamamos o viés usado no mapa de recursos desta maneira de viés compartilhado. Os pesos e vieses compartilhados costumam definir um kernel ou filtro. Na literatura, as pessoas às vezes usam esses termos de maneiras ligeiramente diferentes e mais a frente veremos alguns exemplos concretos.


A estrutura de rede que descrevemos até agora pode detectar apenas um único tipo de recurso localizado. Para fazer reconhecimento de imagem, precisaremos de mais de um mapa de recursos. E assim, uma camada convolucional completa consiste em vários mapas de recursos, diferentes:


 


![](https://www.deeplearningbook.com.br/wp-content/uploads/2019/04/image.png)


 


No exemplo mostrado acima, existem 3 mapas de recursos. Cada mapa de recursos é definido por um conjunto de pesos compartilhados de 5 × 5 e um único viés compartilhado. O resultado é que a rede pode detectar três tipos diferentes de recursos, sendo cada recurso detectável em toda a imagem.


No exemplo temos apenas 3 mapas de recursos, para manter o diagrama acima simples. No entanto, na prática, as redes convolucionais podem usar mais (e talvez muito mais) mapas de recursos. Uma das primeiras redes convolucionais, a [LeNet-5](http://yann.lecun.com/exdb/lenet/), usou 6 mapas de recursos, cada um associado a um campo receptivo local 5 × 5, para reconhecer dígitos MNIST. Portanto, o exemplo ilustrado acima está bem próximo do LeNet-5. Nos exemplos que desenvolveremos mais adiante neste livro, usaremos camadas convolucionais com 20 e 40 mapas de recursos. Vamos dar uma olhada rápida em alguns dos recursos que são aprendidos:


 


![features](https://www.deeplearningbook.com.br/wp-content/uploads/2019/04/features-300x225.png)


 


As 20 imagens correspondem a 20 diferentes mapas de recursos (ou filtros ou kernels). Cada mapa é representado como uma imagem 5 × 5, correspondendo aos pesos 5 × 5 no campo receptivo local. Blocos mais brancos significam um peso menor (normalmente, mais negativo), portanto, o mapa de recursos responde menos aos pixels de entrada correspondentes. Blocos mais escuros significam um peso maior, portanto, o mapa de recursos responde mais aos pixels de entrada correspondentes. Muito grosso modo, as imagens acima mostram o tipo de características que a camada convolucional responde.


Então, o que podemos concluir desses mapas de recursos? Está claro que há estrutura espacial aqui além do que esperamos ao acaso: muitos dos recursos têm claras sub-regiões de luz e escuridão. Isso mostra que nossa rede realmente está aprendendo coisas relacionadas à estrutura espacial. No entanto, além disso, é difícil ver o que esses detectores de recursos estão aprendendo. De fato, agora há muito trabalho para entender melhor os recursos aprendidos pelas redes convolucionais. Se você estiver interessado em acompanhar esse trabalho, sugiro começar com o artigo [Visualizando e Compreendendo Redes Convolucionais](https://arxiv.org/abs/1311.2901) de Matthew Zeiler e Rob Fergus.


Uma grande vantagem do compartilhamento de pesos e vieses é que ele reduz bastante o número de parâmetros envolvidos em uma rede convolucional. Para cada mapa de recursos, precisamos de 5 × 5 = 25 pesos compartilhados, além de um único viés compartilhado. Portanto, cada mapa de recursos requer 26 parâmetros. Se temos 20 mapas de recursos, um total de 20 × 26 = 520 parâmetros define a camada convolucional. Em comparação, suponhamos que tivéssemos uma primeira camada totalmente conectada, com 784 = 28 × 28 neurônios de entrada e relativamente modestos 30 neurônios ocultos, como usamos em muitos dos exemplos anteriores no livro. Isso é um total de 784 × 30 pesos, além de um extra de 30 vieses, para um total de 23.550 parâmetros. Em outras palavras, a camada totalmente conectada teria mais de 40 vezes mais parâmetros que a camada convolucional.


É claro que não podemos fazer uma comparação direta entre o número de parâmetros, já que os dois modelos são diferentes em termos essenciais. Mas, intuitivamente, parece provável que o uso de invariância de tradução pela camada convolucional reduza o número de parâmetros necessários para obter o mesmo desempenho que o modelo totalmente conectado. Isso, por sua vez, resultará em um treinamento mais rápido para o modelo convolucional e, em última análise, nos ajudará a construir redes profundas usando camadas convolucionais.


A propósito, o nome convolucional vem do fato de que a operação na equação mostrada no início deste capítulo é às vezes conhecida como uma convolução. Um pouco mais precisamente, as pessoas às vezes escrevem essa equação como a1 = σ (b + w ∗ a0), onde a1 denota o conjunto de ativações de saída de um mapa de recursos, a0 é o conjunto de ativações de entrada e ∗ é chamado de operação de convolução. 


No próximo capítulo estudaremos as camadas de Pooling, outro “segredo” por trás das Redes Neurais Convolucionais e então estaremos prontos para colocar tudo isso junto. 


Referências:


[Análise de Imagens com Inteligência Artificial](https://www.datascienceacademy.com.br/course/analise-de-imagens-com-inteligencia-artificial)


[Don’t Decay the Learning Rate, Increase the Batch Size](https://arxiv.org/pdf/1711.00489.pdf)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[A Comprehensive Guide to Convolutional Neural Networks](https://towardsdatascience.com/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Machine Learning](https://www.amazon.com.br/Machine-Learning-Tom-M-Mitchell/dp/0070428077/ref=sr_1_fkmr0_1?ie=UTF8&qid=1482129989&sr=8-1-fkmr0&keywords=Machine+Learning+%28McGraw-Hill+International+Editions+Computer+Science+Series%29)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-43---camadas-de-pooling-em-redes-neurais-convolucionais"></div>

# Capítulo 43 – Camadas de Pooling em Redes Neurais Convolucionais


Além das camadas convolucionais que acabamos de descrever nos capítulos anteriores, as redes neurais convolucionais também contêm camadas de agrupamento (ou Pooling). Camadas de Pooling são geralmente usadas imediatamente após camadas convolucionais e o que fazem é simplificar as informações na saída da camada convolucional. 


Vejamos o que são e como funcionam as Camadas de Pooling em Redes Neurais Convolucionais e na sequência vamos colocar todas as camadas juntas para compreender como funciona todo o processo nesta importante arquitetura de Deep Learning.


A Camada de Pooling
-------------------


Uma camada de pooling recebe cada saída do mapa de características da camada convolucional e prepara um mapa de características condensadas. Por exemplo, cada unidade na camada de pooling pode resumir uma região de (digamos) 2 × 2 neurônios na camada anterior. Como um exemplo concreto, um procedimento comum para o pooling é conhecido como pool máximo (ou Max-Pooling). No Max-Pooling, uma unidade de pooling simplesmente gera a ativação máxima na região de entrada 2 × 2, conforme ilustrado no diagrama a seguir:


 


![pooling](https://www.deeplearningbook.com.br/wp-content/uploads/2019/04/pooling.png)


 


Note que, como temos 24 × 24 neurônios emitidos da camada convolucional, após o agrupamento, temos 12 × 12 neurônios.


Como mencionado acima, a camada convolucional geralmente envolve mais do que um único mapa de características. Aplicamos o Max-Pooling para cada mapa de recursos separadamente. Portanto, se houvesse três mapas de recursos, as camadas combinadas, convolutional e Max-Pooling, se pareceriam com:


 


![pooling2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/04/pooling2.png)


 


Podemos pensar em Max-Pooling como uma forma de a rede perguntar se um determinado recurso é encontrado em qualquer lugar de uma região da imagem. Em seguida, elimina a informação posicional exata. A intuição é que, uma vez que um recurso tenha sido encontrado, sua localização exata não é tão importante quanto sua localização aproximada em relação a outros recursos. Um grande benefício é que há muito menos recursos agrupados e, portanto, isso ajuda a reduzir o número de parâmetros necessários nas camadas posteriores. Genial, não?


O Max-Pooling não é a única técnica usada para o pooling. Outra abordagem comum é conhecida como Pooling L2. Aqui, em vez de tomar a ativação máxima de uma região 2 × 2 de neurônios, tomamos a raiz quadrada da soma dos quadrados das ativações na região 2 × 2. Embora os detalhes sejam diferentes, a intuição é semelhante ao agrupamento máximo: o Pooling L2 é uma maneira de condensar informações da camada convolucional. Na prática, ambas as técnicas têm sido amplamente utilizadas. E às vezes as pessoas usam outros tipos de operação de Pooling. 


Se você estiver realmente tentando otimizar o desempenho, poderá usar dados de validação para comparar várias abordagens diferentes ao Pooling e escolher a abordagem que funciona melhor. 


Juntando Tudo
-------------


Podemos agora juntar todas essas ideias para formar uma rede neural convolucional completa. É semelhante à arquitetura que estávamos estudando nos capítulos anteriores, mas tem a adição de uma camada de 10 neurônios de saída, correspondentes aos 10 valores possíveis para dígitos MNIST (‘0’, ‘1’, ‘2’, etc):


 


![pooling3](https://www.deeplearningbook.com.br/wp-content/uploads/2019/04/pooling3.png)


 


A rede começa com 28 × 28 neurônios de entrada (cada image de cada dígito do dataset MNIST tem 28 x 28 pixels), que são usados ​​para codificar as intensidades de pixel para uma imagem no dataset MNIST. Este é então seguido por uma camada convolucional usando um campo receptivo local de 5 x 5 e três mapas de características. O resultado é uma camada de 3 × 24 × 24 neurônios ocultos. A próxima etapa é uma camada de Max-Pooling, aplicada a regiões 2 × 2, em cada um dos três mapas de recursos. O resultado é uma camada de 3 × 12 × 12 neurônios ocultos.


A camada final de conexões na rede é uma camada totalmente conectada. Ou seja, essa camada conecta todos os neurônios da camada de max-pooling a cada um dos 10 neurônios de saída. Essa arquitetura totalmente conectada é a mesma que usamos nos capítulos anteriores. Note, no entanto, que no diagrama acima, usei uma única seta, por simplicidade, em vez de mostrar todas as conexões. Claro, você pode facilmente imaginar as conexões.


Ou seja, temos uma rede composta de muitas unidades simples, cujos comportamentos são determinados por seus pesos e vieses. E o objetivo geral ainda é o mesmo: usar dados de treinamento para treinar os pesos e vieses da rede para que a rede faça um bom trabalho classificando os dígitos de entrada.


Em particular, assim como no início do livro, nós vamos treinar nossa rede usando descida estocástica do gradiente e retropropagação. Isso ocorre principalmente da mesma maneira que nos capítulos anteriores. No entanto, precisamos fazer algumas modificações no procedimento de retropropagação. A razão é que nossa derivação anterior da retropropagação foi para redes com camadas totalmente conectadas. Felizmente, é simples modificar a derivação para camadas convolucional e max-pooling. 


Quer ver tudo isso funcionando em linguagem Python? Então não perca o próximo capítulo!


Referências:


[Análise de Imagens com Inteligência Artificial](https://www.datascienceacademy.com.br/course/analise-de-imagens-com-inteligencia-artificial)


[Don’t Decay the Learning Rate, Increase the Batch Size](https://arxiv.org/pdf/1711.00489.pdf)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[A Comprehensive Guide to Convolutional Neural Networks](https://towardsdatascience.com/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-44---reconhecimento-de-imagens-com-redes-neurais-convolucionais-em-python---parte-1"></div>

# Capítulo 44 – Reconhecimento de Imagens com Redes Neurais Convolucionais em Python – Parte 1


Nossa tarefa é simples: vamos fornecer a um modelo de Deep Learning uma imagem e o modelo terá que classificar se a imagem é de um cachorro ou gato! Parece fácil, não? Na verdade, não! Para que isso funcione precisamos construir e treinar um modelo de Deep Learning, o que envolve conhecimentos de Matemática, Estatística, Programação, Visão Computacional, Pré-Processamento de imagens, entre outras áreas. 


Mas nós vamos fazer isso juntos. 


Nos próximos capítulos vamos construir e treinar um modelo de Deep Learning para Reconhecimento de Imagens com Redes Neurais Convolucionais em Python. Será uma excelente oportunidade de praticar tudo que estudamos no livro até aqui e preparar você para os capítulos mais avançados deste livro, quando estudaremos outras arquiteturas de Deep Learning. 


Vamos começar?


Plano de Trabalho
-----------------


Para começar, precisamos definir claramente o problema a ser resolvido e como vamos resolvê-lo.


**Problema**: Dada uma imagem, é um cachorro ou um gato? 


A primeira coisa que precisamos é de muitas imagens de cachorros e gatos, para poder treinar um algoritmo de Deep Learning. Usaremos, portanto, uma abordagem de aprendizagem supervisionada, onde apresentaremos ao algoritmo diversas imagens, devidamente marcadas como sendo imagens de cães e gatos e então treinaremos o algoritmo. Ao final do treinamento, teremos um modelo que poderá receber novas imagens (desta vez não marcadas previamente) e então o modelo deverá ser capaz de classificar como sendo imagem de cão ou gato.


Para essa tarefa, usaremos uma arquitetura de Rede Neural Convolucional, a mesma que estudamos nos capítulos anteriores. Essa arquitetura usa métodos de convolução para poder prever características específicas de uma imagem de acordo com o que aprende em um conjunto de treinamento. Por exemplo, podemos dizer que é possível perceber a diferença ao procurar bigodes em um gato ou focinho comprido em um cachorro. Mas uma Rede Neural Convolucional procura muitos outros recursos baseados no que temos em um conjunto de treinamento.


Solução: Usar uma Rede Neural Convolucional para aprender recursos de imagens e assim prever se uma imagem contém um cachorro ou um gato.


Definição dos Dados
-------------------


Data Science, Deep Learning, Machine Learning, Inteligência Artificial. Nada disso faz sentido sem dados, muitos dados (por isso [Big Data](https://www.datascienceacademy.com.br/course?courseid=big-data-fundamentos) é cada vez mais importante nos dias de hoje). E para esta tarefa, teremos os seguintes dados:


Conjunto de dados de treino: Teremos 12.500 imagens de cães e 12.500 imagens de gatos para o conjunto de treinamento.


Conjunto de dados de validação: Teremos 12.500 imagens de cães e gatos.


Conjunto de dados de teste: Teremos 1.000 imagens de cães e gatos.


Essa á uma questão onde os iniciantes tem muitas dúvidas. Por que precisamos de dados de treino, validação e teste? Usamos os dados de treino para treinar o algoritmo e então criar o modelo preditivo. Usamos os dados de validação, para avaliar o modelo durante o treinamento. Usamos os dados de teste para validar a performance do modelo já treinado, ou seja, apresentamos ao modelo dados que ele não viu durante o treinamento, a fim de garantir que ele é capaz de fazer previsões.


Estrutura de Trabalho
---------------------


Vamos realizar as seguintes atividades na construção do modelo de Reconhecimento de Imagens com Redes Neurais Convolucionais em Python:


### 1- Visualização de Dados


Começaremos nosso trabalho com tarefas de visualização de dados e análise exploratória. Precisamos compreender os dados antes de qualquer outra coisa, como as dimensões das imagens, escala de cores, detalhes de sombras e se as imagens possuem mais detalhes não relacionados diretamente a um cachorro ou gato, como nesta imagem abaixo! Afinal, o modelo terá que aprender que um cachorro vestido de Hello Kitty ainda é um cachorro!


 


![dog](https://www.deeplearningbook.com.br/wp-content/uploads/2019/05/dog.jpeg)


 


### 2- Construindo a Rede Neural Convolucional


Nosso próximo passo será construir a arquitetura de rede. Definiremos quantas camadas serão usadas, camadas de convolução e pooling, funções de ativação, métrica de avaliação, descida do gradiente com backpropagation e outros detalhes. Discutiremos porque estamos fazendo nossas escolhas.


### 3- Treinamento


Com a arquitetura definida, podemos então treinar a nossa rede, o que consiste em apresentar os dados ao algoritmo para que o aprendizado ocorra. Definiremos os hiperparâmetros e por quanto tempo treinaremos a rede. Vamos aproveitar e discutir sobre técnicas para evitar o overfitting (quando o modelo se ajusta demais aos dados de treino).


### 4- Fazer Previsões


Por fim, usaremos o modelo treinado para fazer as classificações. Entregaremos ao modelo novas imagens e ele terá que classificar se a imagem é de um cachorro ou gato! Na prática, o modelo nunca faz a classificação com 100% de certeza. O que ele faz é uma previsão (para ser ainda mais preciso, uma inferência) e nosso trabalho é garantir que essa previsão tenha o mais alto nível de acurácia possível.


Ferramentas
-----------


Para este trabalho usaremos, claro, linguagem Python com Keras e TensorFlow. Vamos explicar a você quais são as opções de frameworks e cada linha de código será explicada em detalhes. Vamos considerar que você já conhece linguagem Python e sabe executar um Jupyter Notebook. Se não sabe, então acesse pelo menos o Capítulo 1 do nosso curso gratuito [Python Fundamentos Para Análise de Dados](https://www.datascienceacademy.com.br/cursosgratuitos).


Está pronto? Então nos encontramos no próximo capítulo!


Referências:


[Don’t Decay the Learning Rate, Increase the Batch Size](https://arxiv.org/pdf/1711.00489.pdf)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[A Comprehensive Guide to Convolutional Neural Networks](https://towardsdatascience.com/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-45---reconhecimento-de-imagens-com-redes-neurais-convolucionais-em-python---parte-2"></div>

# Capítulo 45 – Reconhecimento de Imagens com Redes Neurais Convolucionais em Python – Parte 2


Vamos iniciar nosso trabalho de Reconhecimento de Imagens com Redes Neurais Convolucionais em Python cuidando da nossa matéria-prima: dados. Precisamos fazer o download das imagens e organizá-las para então iniciar o trabalho.


Usaremos como fonte de dados, o famoso dataset [Dogs and Cats](https://www.kaggle.com/c/dogs-vs-cats/data) oferecido pelo Kaggle, o portal sobre Competições de Data Science.


Você pode fazer o download das imagens neste endereço: [Dogs vs. Cats](https://www.kaggle.com/c/dogs-vs-cats/data). Mas nós já fizemos o download e disponibilizamos para você junto com o Jupyter Notebook no repositório deste livro [aqui](https://drive.google.com/file/d/1esmcuW-aluCZTwS-Yjh1x-uijX8DHK62/view). Como este dataset é bastante famoso, alternativamente, você pode fazer o download oferecido pela Microsoft Research neste endereço [Kaggle Cats and Dogs Dataset](https://www.microsoft.com/en-us/download/details.aspx?id=54765).


Feito o download das imagens (você vai precisar de aproximadamente 1 GB de espaço em disco para as imagens), precisamos organizar os arquivos em uma estrutura de diretórios da seguinte forma:


 


![diretorios](https://www.deeplearningbook.com.br/wp-content/uploads/2019/05/diretorios.png)


 


Crie um diretório (por exemplo Cap45, mas pode ser o nome que você quiser). Dentro dele crie mais 3 pastas: dataset\_treino, dataset\_validation e dataset\_teste. Não use espaços no nome e muito menos acentos nas palavras, pois isso causa diversos problemas em programação.


Dentro da pasta dataset\_treino, crie mais duas pastas, cats (que vai receber as 12.500 imagens de gatos) e dogs (que vai receber as 12.500 imagens de cachorros). 


Nas pastas dataset\_validation e dataset\_teste não é necessário criar sub pastas e dentro delas colocaremos as 12.500 imagens de validação e 1.000 imagens de teste, respectivamente. As imagens de validação serão usadas para avaliar o modelo durante o treinamento e as imagens de teste serão usadas para avaliar o modelo depois do treinamento.


Podemos agora visualizar algumas imagens usando o Jupyter Notebook, que você encontra no repositório deste livro [aqui](https://drive.google.com/file/d/1esmcuW-aluCZTwS-Yjh1x-uijX8DHK62/view). Caso não tenha familiaridade com o Jupyter Notebook, acesse o Capítulo 1 do curso gratuito [Python Fundamentos Para Análise de Dados](https://www.datascienceacademy.com.br/cursosgratuitos).


Se você criou a estrutura de diretórios de forma correta, então as seguintes células mostrarão algumas das imagens:


![image1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/05/image1-1024x851.png)


 


![image2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/05/image2-951x1024.png)


 


Se as imagens foram mostradas de forma correta, então os dados estão prontos para serem explorados. É o que faremos no próximo capítulo! Até lá.


Referências:


[Análise de Imagens com Inteligência Artificial](https://www.datascienceacademy.com.br/course/analise-de-imagens-com-inteligencia-artificial)


<div id="capitulo-46---reconhecimento-de-imagens-com-redes-neurais-convolucionais-em-python---parte-3"></div>

# Capítulo 46 – Reconhecimento de Imagens com Redes Neurais Convolucionais em Python – Parte 3


Uma das principais dúvidas de quem está iniciando em [Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-machine-learning) e se depara com as Redes Neurais Convolucionais, é sobre como ocorre o aprendizado dos parâmetros (aquilo que o algoritmo realmente aprende durante o treinamento). O que exatamente está sendo feito quando apresentamos uma imagem a um algoritmo de Rede Neural Convolucional?


![dogs_cats](https://www.deeplearningbook.com.br/wp-content/uploads/2019/06/dogs_cats.gif)


Sabemos que em cada camada de convolução, a rede tenta entender os padrões básicos. Por exemplo: Na primeira camada de convolução, a rede tenta aprender padrões e bordas das imagens. Na segunda camada, ela tenta entender a forma / cor e outras coisas. Uma camada final chamada camada de recurso / camada totalmente conectada tenta classificar a imagem.


Antes de prepararmos o script com nossa rede convolucional, vamos compreender como definimos a arquitetura da rede e em quais camadas os parâmetros são aprendidos.


**Camada de Entrada (Input Layer)**: O que a camada de entrada faz é ler a imagem. Portanto, não há parâmetros a serem aprendidos aqui.


**Camada Convolucional (Convolutional Layer)**: considere uma camada convolucional que usa os mapas de recursos “l” como entrada e tem os mapas de recursos “k” como saída. O tamanho do filtro é “n \* m”.


![conv_layer](https://www.deeplearningbook.com.br/wp-content/uploads/2019/06/conv_layer-300x264.png)


Aqui, a entrada tem l = 32 mapas de recursos como entradas, k = 64 mapas de recursos como saídas e o tamanho do filtro é n = 3 e m = 3. É importante entender que não temos apenas um filtro 3 \* 3, mas, na verdade, temos um filtro 3 \* 3 \* 32, já que nossa entrada tem 32 dimensões. E como uma saída da primeira camada convolucional, aprendemos 64 diferentes filtros 3 \* 3 \* 32 cujo peso total é “n \* m \* k \* l”. Depois, há um termo chamado bias para cada mapa de recursos. Portanto, o número total de parâmetros é “(n \* m \* l + 1) \* k”.


**Camada de Pooling (Pooling Layer)**: Não há parâmetros a aprender na camada de pooling. Essa camada é usada apenas para reduzir o tamanho da dimensão da imagem.


Obs: Podemos ter várias combinações de camada convolucional / camada de pooling em nossa arquitetura, sendo esta decisão do [Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) ou [Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia).


**Camada Totalmente Conectada (Fully Connected Layer)**: Nesta camada, todas as unidades de entrada possuem um peso separável para cada unidade de saída. Para entradas “n” e saídas “m”, o número de pesos é “n \* m”. Além disso, essa camada possui o bias para cada nó de saída, portanto, os parâmetros aprendidos são “(n + 1) \* m”.


**Camada de Saída (Output Layer)**: Esta camada é totalmente conectada, portanto, os parâmetros aprendidos também são “(n + 1) m”, quando “n” é o número de entradas e “m” é o número de saídas.


A principal dificuldade ao definir a arquitetura de um CNN é a primeira camada totalmente conectada. Não sabemos a dimensionalidade da camada totalmente conectada. Para calcular isso, temos que começar com o tamanho da imagem de entrada e calcular o tamanho de cada camada convolucional.


No caso simples, o tamanho da camada totalmente conectada é calculado como “input\_size – (filter\_size – 1)”. Por exemplo, se o tamanho da imagem de entrada for (50,50) e o filtro for (3,3), então (50- (3-1)) = 48. Mas o tamanho da imagem de entrada de uma rede convolucional não deve ser menor que a entrada, então precisamos definir o padding.


Para calcular o padding usamos: input\_size + 2 \* padding\_size – (filter\_size-1). Para o caso acima, (50 + (2 \* 1) – (3–1) = 52 – 2 = 50) que fornece o mesmo tamanho de entrada. Perfeito, pois assim não perdemos nenhum detalhe da imagem. Se quisermos explicitamente diminuir a imagem durante a convolução, podemos definir um passo (stride).


Finalmente, para calcular o número de parâmetros que a rede vai aprender usamos: (n \* m \* k + 1) \* f. Veremos tudo isso em código Python no próximo capítulo!


Caso queira mais detalhes sobre como definir a arquitetura da rede, consulte o famoso e excelente paper da AlexNet: [ImageNet Classification with Deep Convolutional Neural Networks](https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf).


Referências:


[Formação Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-machine-learning)


[ImageNet Classification with Deep Convolutional Neural Networks](https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf)


[Don’t Decay the Learning Rate, Increase the Batch Size](https://arxiv.org/pdf/1711.00489.pdf)


[How to calculate the number of parameters in the CNN?](https://medium.com/@iamvarman/how-to-calculate-the-number-of-parameters-in-the-cnn-5bd55364d7ca)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[A Comprehensive Guide to Convolutional Neural Networks](https://towardsdatascience.com/a-comprehensive-guide-to-convolutional-neural-networks-the-eli5-way-3bd2b1164a53)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-47---reconhecimento-de-imagens-com-redes-neurais-convolucionais-em-python---parte-4"></div>

# Capítulo 47 – Reconhecimento de Imagens com Redes Neurais Convolucionais em Python – Parte 4


Vejamos como implementar nosso modelo de Rede Neural Convolucional que vai aprender a diferença nas imagens de cães e gatos e quando apresentarmos novas imagens ao modelo, ele será capaz de prever se a imagem é de um cão ou gato de forma automática.


O Jupyter Notebook completo está disponível com os demais arquivos do curso [aqui](https://drive.google.com/file/d/1esmcuW-aluCZTwS-Yjh1x-uijX8DHK62/view). Abaixo você visualiza o Jupyter (use a barra de rolagem).



 .errordiv { padding:10px; margin:10px; border: 1px solid #555555;color: #000000;background-color: #f8f8f8; width:500px; }#advanced\_iframe {visibility:visible;opacity:1;vertical-align:top;}.ai-info-bottom-iframe { position: fixed; z-index: 10000; bottom:0; left: 0; margin: 0px; text-align: center; width: 100%; background-color: #ff9999; padding-left: 5px;padding-bottom: 5px; border-top: 1px solid #aaa } a.ai-bold {font-weight: bold;}#ai-layer-div-advanced\_iframe p {height:100%;margin:0;padding:0}var ai\_iframe\_width\_advanced\_iframe = 0;var ai\_iframe\_height\_advanced\_iframe = 0;var aiIsIe8=false;var aiOnloadScrollTop="true";var aiShowDebug=false;
 if (typeof aiReadyCallbacks === 'undefined') {
 var aiReadyCallbacks = []; 
 } else if (!(aiReadyCallbacks instanceof Array)) {
 var aiReadyCallbacks = [];
 } function aiShowIframeId(id\_iframe) { jQuery("#"+id\_iframe).css("visibility", "visible"); } function aiResizeIframeHeight(height) { aiResizeIframeHeight(height,advanced\_iframe); } function aiResizeIframeHeightId(height,width,id) {aiResizeIframeHeightById(id,height);}var ifrm\_advanced\_iframe = document.getElementById("advanced\_iframe");var hiddenTabsDoneadvanced\_iframe = false;
function resizeCallbackadvanced\_iframe() {}




---


Com isso concluímos esta introdução a uma das mais famosas arquiteturas de Deep Learning, as Redes neurais Convolucionais. A partir do próximo capítulo estudaremos outras arquiteturas. Até lá.


Lembrando que a DSA oferece um programa completo para quem deseja aprender Deep Learning e Inteligência Artificial na prática e de forma profissional, a [Formação Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia). Faça como milhares de alunos no Brasil e no mundo e comece sua capacitação agora mesmo. O curso é 100% online e 100% em português. Seja um profissional em alta demanda!


Continuaremos no próximo capítulo.
<div id="capitulo-48---redes-neurais-recorrentes"></div>

# Capítulo 48 – Redes Neurais Recorrentes


A partir deste capítulo estudaremos diversas outras arquiteturas de Deep Learning, que estão sendo usadas em aplicações de Inteligência Artificial de última geração. Continue conosco nessa incrível jornada.


Os humanos não começam a pensar do zero a cada segundo. Ao ler este texto, você entende cada palavra com base em sua compreensão das palavras anteriores. Você não joga tudo fora e começa a pensar de novo. Seus pensamentos têm persistência.


As redes neurais artificiais tradicionais não podem fazer isso, o que traz algumas limitações para esses tipos de modelos. Por exemplo, imagine que você queira classificar o tipo de evento que está acontecendo em todos os pontos de um filme. Não está claro como uma rede neural tradicional poderia usar seu raciocínio sobre eventos anteriores no filme para informar os posteriores.


Redes Neurais Recorrentes resolvem esse problema. São redes com loops, permitindo que as informações persistam.


As redes recorrentes são um tipo de rede neural artificial projetada para reconhecer padrões em sequências de dados, como texto, genomas, caligrafia, palavra falada ou dados de séries numéricas que emanam de sensores, bolsas de valores e agências governamentais. Esses algoritmos consideram tempo e sequência, eles têm uma dimensão temporal.


A pesquisa mostra que eles são um dos tipos mais poderosos e úteis de rede neural, juntamente com o mecanismo de atenção e as redes de memória. As RNNs são aplicáveis até mesmo a imagens, que podem ser decompostas em uma série de amostras e tratadas como uma sequência.


Como as redes recorrentes possuem um certo tipo de memória, e a memória também faz parte da condição humana, faremos analogias com a memória do cérebro, para uma melhor compreensão. Continue a leitura. 


Revisão de Redes Feedforward
----------------------------


Para entender as redes recorrentes, primeiro vamos revisar o básico das redes feedforward, que estudamos em capítulos anteriores aqui mesmo no Deep Learning Book. 


Ambas as redes recebem o nome da forma como canalizam informações através de uma série de operações matemáticas realizadas nos nós da rede. As redes feedforward alimentam informações diretamente (nunca tocando em um determinado nó duas vezes), enquanto as redes recorrentes percorrem através de um loop.


No caso de redes feedforward, exemplos de entrada são alimentados na rede e transformados em uma saída; com a aprendizagem supervisionada, a saída seria por exemplo um rótulo, um nome aplicado à entrada. Ou seja, elas mapeiam dados brutos para categorias, reconhecendo padrões que podem sinalizar, por exemplo, que uma imagem de entrada deve ser rotulada como “gato” ou “cachorro”. A imagem abaixo mostra um exemplo de rede feedforward.


 


![Rede Feed Forward](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/feedf.png)


 


Uma rede feedforward pode então ser treinada em imagens rotuladas, por exemplo, até minimizar o erro ao classificar suas categorias. Com o conjunto treinado de parâmetros (ou pesos, conhecidos coletivamente como um modelo), a rede procura categorizar os dados que nunca viu. Uma rede feedforward treinada pode ser exposta a qualquer coleção aleatória de fotografias, e a primeira fotografia a que está exposta não alterará necessariamente como classifica a segunda. Ver a fotografia de um gato não levará a rede a perceber um cachorro em seguida.


Ou seja, uma rede feedforward não tem noção de ordem no tempo, e a única entrada que considera é o exemplo atual a que foi exposta. As redes feedforward são amnésicas em relação ao seu passado recente; elas lembram nostalgicamente apenas os momentos formativos do treinamento.


Redes Neurais Recorrentes
-------------------------


As redes recorrentes, por outro lado, tomam como entrada não apenas o exemplo de entrada atual que veem, mas também o que perceberam anteriormente no tempo. Aqui está um diagrama com a representação de uma rede neural recorrente e uma rede feedforward.


![Nets](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/rnn.png)


A decisão de uma rede recorrente alcançada na etapa de tempo t-1 afeta a decisão que alcançará um momento mais tarde na etapa de tempo t. Assim, as redes recorrentes têm duas fontes de entrada, o presente e o passado recente, que se combinam para determinar como respondem a novos dados, da mesma forma que fazemos na vida. Nas redes neurais recorrentes isso é feito, claro, com a ajuda da nossa querida Matemática. E por isso o curso [Matemática Para Data Science](https://www.datascienceacademy.com.br/course/matematica-para-data-science) é um dos cursos de maior sucesso na Data Science Academy.


As redes recorrentes são diferenciadas das redes feedforward pelo loop de feedback conectado às suas decisões anteriores, ingerindo suas próprias saídas momento após momento como entrada. Costuma-se dizer que as redes recorrentes têm memória. A adição de memória às redes neurais tem uma finalidade: há informações na própria sequência e as redes recorrentes a utilizam para executar tarefas que as redes de feedforward não conseguem.


Essa informação sequencial é preservada no estado oculto da rede recorrente, que consegue passar por muitas etapas de tempo à medida que ela avança em cascata para afetar o processamento de cada novo exemplo. Essas correlações entre eventos são separadas por muitos momentos, e essas correlações são chamadas de “**dependências de longo prazo**”, porque um evento no tempo depende e é uma função de um ou mais eventos que vieram antes. Uma maneira objetiva de pensar sobre as RNNs é a seguinte: elas são uma forma de compartilhar pesos ao longo do tempo.


Assim como a memória humana circula invisivelmente dentro de um corpo, afetando nosso comportamento sem revelar sua forma completa, a informação circula nos estados ocultos de redes recorrentes. A língua portuguesa está cheia de palavras que descrevem os ciclos de feedback da memória. Quando dizemos que uma pessoa é assombrada por seus atos, por exemplo, estamos simplesmente falando sobre as consequências que as produções passadas causam no tempo presente. Os franceses chamam isso de “Le passé qui ne passe pas” ou “O passado que não passa”.


Descreveremos o processo de levar a memória adiante matematicamente da seguinte forma:


![](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/recurrent_equation.png)


O estado oculto na etapa de tempo t é h\_t. É uma função da entrada na mesma etapa de tempo x\_t, modificada por uma matriz de peso W (como a que usamos para redes feedforward) adicionada ao estado oculto do passo de tempo anterior h\_t-1 multiplicado por seu próprio estado oculto – para a matriz de estado oculto U, também conhecida como matriz de transição e semelhante a uma cadeia de Markov. As matrizes de peso são filtros que determinam quanta importância deve ser dada tanto à entrada atual quanto ao estado oculto do passado. O erro que eles geram retornará por meio de retropropagação (backpropagation) e será usado para ajustar seus pesos até que o erro não diminua mais.


A soma da entrada de peso e do estado oculto é comprimida pela função φ – ou uma função sigmoide logística ou tanh, dependendo – que é uma ferramenta padrão para condensar valores muito grandes ou muito pequenos em um espaço logístico, bem como tornar os gradientes viáveis para retropropagação.


Como esse loop de feedback ocorre a cada etapa da série, cada estado oculto contém traços não apenas do estado oculto anterior, mas também de todos aqueles que precederam h\_t-1 pelo tempo que a memória pode persistir.


Dada uma série de letras, uma rede recorrente usará o primeiro caractere para ajudar a determinar sua percepção do segundo caractere, de tal forma que um q inicial possa levá-lo a inferir que a próxima letra será u.


Mas para que as redes neurais recorrentes possam aprender de forma efetiva, precisamos de uma versão levemente modificada do Backpropagation, o BPTT (Backpropagation Through Time). Mas isso é assunto para o próximo capítulo! Estudaremos ainda duas importantes variações das RNNs, as Long Short-Term Memory Units (LSTMs) e as Gated Recurrent Units (GRUs).


Enquanto isso, caso queira começar a se divertir com as RNNs, acompanhe esse tutorial oficial do TensorFlow: [Recurrent Neural Networks](https://www.tensorflow.org/guide/keras/rnn). Para aulas práticas em português com linguagem Python, acesse [aqui](https://www.datascienceacademy.com.br/cursosgratuitos).


Referências:


[Formação Análise Estatística](https://www.datascienceacademy.com.br/bundle/formacao-analise-estatistica)


[Recurrent Neural Networks Cheatsheet](https://stanford.edu/~shervine/teaching/cs-230/cheatsheet-recurrent-neural-networks)


[A Beginner’s Guide to LSTMs and Recurrent Neural Networks](https://skymind.ai/wiki/lstm)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-49---a-matematica-do-backpropagation-through-time-(bptt)"></div>

# Capítulo 49 – A Matemática do Backpropagation Through Time (BPTT)


Estudamos no capítulo [anterior](https://www.deeplearningbook.com.br/redes-neurais-recorrentes/) as Redes Neurais Recorrentes. Mas para que elas funcionem, o algoritmo de treinamento precisa de um pequeno ajuste, uma vez que esse tipo de rede possui o que podemos chamar de “memória” durante seu treinamento. E o que faz isso acontecer é A Matemática do Backpropagation Through Time (BPTT), assunto deste capítulo do Deep Learning Book.


### Um Pouco Mais Sobre as RNNs


A ideia por trás dos RNNs é fazer uso de informações sequenciais. Em uma rede neural tradicional, assumimos que todas as entradas (e saídas) são independentes umas das outras. Mas para muitas tarefas isso é uma ideia muito ruim. Se você quiser prever a próxima palavra em uma frase, é melhor saber quais palavras vieram antes dela. As RNNs são chamadas de recorrentes porque executam a mesma tarefa para todos os elementos de uma sequência, com a saída sendo dependente dos cálculos anteriores. Outra maneira de pensar sobre RNNs é que elas têm uma “memória” que captura informações sobre o que foi calculado até agora. Em teoria, RNNs podem fazer uso de informações em sequências arbitrariamente longas, mas, na prática, limitam-se a olhar para trás apenas alguns passos (mais sobre isso adiante). Aqui está o que uma RNN típica parece:


![rnn](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/rnn.jpg)


O diagrama acima mostra uma RNN sendo “desenrolada” ou “desdobrada” (termo unfolded em inglês) em uma rede completa. Ao desenrolar, simplesmente queremos dizer que escrevemos a rede para a sequência completa. Por exemplo, se a sequência que nos interessa é uma sentença de 5 palavras, a rede seria desdobrada em uma rede neural de 5 camadas, uma camada para cada palavra. As fórmulas que governam o cálculo que acontece em uma RNN são as seguintes:


1. xt é a entrada no passo de tempo t. Por exemplo, x1 poderia ser um vetor one-hot correspondente à segunda palavra de uma sentença.


2. st é o estado oculto no passo de tempo t. É a “memória” da rede. O termo st é calculado com base no estado oculto anterior e a entrada na etapa atual através da fórmula: st = f(Uxt + Wst-1). A função geralmente é uma não-linearidade, como tanh ou ReLU. Já s -1, que é necessário para calcular o primeiro estado oculto, é tipicamente inicializado com zero.


3. ot é a saída na etapa t. Por exemplo, se quiséssemos prever a próxima palavra em uma frase, seria um vetor de probabilidades em todo o nosso vocabulário. ot = softmax(Vst).


Há algumas coisas a serem observadas aqui:


Você pode pensar no estado oculto st como a memória da rede. st captura informações sobre o que aconteceu em todas as etapas de tempo anteriores. A saída na etapa ot é calculada exclusivamente com base na memória no tempo t. É um pouco mais complicado na prática, porque normalmente não é possível capturar informações de muitas etapas de tempo anteriores.


Ao contrário de uma rede neural profunda tradicional, que usa parâmetros diferentes em cada camada, uma RNN compartilha os mesmos parâmetros (U, V, W acima) em todas as etapas. Isso reflete o fato de que estamos executando a mesma tarefa em cada etapa, apenas com entradas diferentes. Isso reduz muito o número total de parâmetros que precisamos aprender.


O diagrama acima tem saídas em cada etapa de tempo, mas dependendo da tarefa, isso pode não ser necessário. Por exemplo, ao prever o sentimento de uma frase, podemos nos preocupar apenas com a saída final, não com o sentimento após cada palavra. Da mesma forma, podemos não precisar de entradas em cada etapa de tempo. A principal característica de uma RNN é seu estado oculto, que captura algumas informações sobre uma sequência.


### E o Backpropagation?


Lembre-se, o objetivo das redes neurais recorrentes é classificar com precisão uma entrada sequencial (por exemplo, dada uma frase, prever o sentimento ou mesmo a próxima palavra). Contamos com a retropropagação (backpropagation) do erro e o gradiente descendente para fazê-lo.


A retropropagação em redes feedforward retrocede do erro final através das saídas, pesos e entradas de cada camada oculta, atribuindo a esses pesos a responsabilidade por uma parte do erro calculando suas derivadas parciais – ∂E / ∂w, ou a relação entre suas taxas de mudança. Essas derivações são então usadas por nossa regra de aprendizado, gradiente descendente, para ajustar os pesos para cima ou para baixo, qualquer que seja a direção que diminua o erro. Já estudamos isso nos capítulos anteriores aqui do Deep Learning Book.


As redes recorrentes dependem de uma extensão da retropropagação, chamada Backpropagation Through Time, ou BPTT. O tempo, neste caso, é simplesmente expresso por uma série ordenada e bem definida de cálculos, ligando um passo de tempo ao seguinte, o que significa que toda a retropropagação precisa funcionar.


Redes neurais, sejam elas recorrentes ou não, são simplesmente funções compostas aninhadas como f(g(h(x))). A adição de um elemento de tempo apenas estende a série de funções para as quais calculamos derivadas com a regra da cadeia (chain rule). Matemática pura!


### A Matemática do Backpropagation Through Time (BPTT)


Por falar em Matemática, vamos compreender o BPTT através de fórmulas e alguns gráficos. Para as devidas referências, sempre consulte as notas ao final do capítulo.


Considere que estamos criando uma rede neural recorrente que seja capaz de prever a próxima palavra em um texto, o que pode ser útil em aplicações de IA para criar petições e assim ajudar advogados a automatizar o trabalho. Algo que já é feito pelo [ROSS](https://rossintelligence.com/), o Robô Advogado.


Vamos começar com a equação básica de uma Rede Neural Recorrente:


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/form1.png)


Também definimos nossa perda, ou erro, como a perda de entropia cruzada, dada por:


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/form2.png)


Aqui, yt é a palavra correta no momento do passo t, e y^t é nossa previsão. Normalmente, tratamos a sequência completa (sentença) como um exemplo de treinamento, portanto, o erro total é apenas a soma dos erros em cada etapa de tempo (palavra).


![rnn-bptt1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/rnn-bptt1.png)


Lembre-se de que nosso objetivo é calcular os gradientes do erro em relação aos nossos parâmetros U, V e W e, em seguida, aprender bons parâmetros usando o Gradiente Descendente Estocástico. Assim como resumimos os erros, também somamos os gradientes em cada etapa de tempo para um exemplo de treinamento:


 


![form3](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/form3.png)


 


Para calcular esses gradientes, usamos a regra de diferenciação da cadeia. Esse é o algoritmo de retropropagação quando aplicado para trás a partir do erro. Usaremos o E\_3 como exemplo, apenas para trabalhar com números concretos.


 


![form4](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/form4.png)


 


Acima, z3 = Vs3 e a última linha é o produto externo de dois vetores. Não se preocupe se você não seguir os passos acima, nós pulamos vários passos e você pode tentar calcular essas derivadas você mesmo (bom exercício!). O ponto que estou tentando transmitir é que


 


![latex](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/latex.png)


 


depende apenas dos valores no momento atual, yˆ3, y3, s3. Se você tem estes valores, calculando o gradiente para V é uma multiplicação de matriz simples. Mas a história é diferente para W (e para U):


 


![latex (1)](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/latex-1.png)


 


Para entender porque, escrevemos a regra da cadeia, como acima:


 


![form5](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/form5.png)


 


Agora, note que s3 = tanh(Uxt + Ws2) depende de s2, que depende de W e s1, e assim por diante. Então, se pegarmos a derivada em relação a W, não podemos simplesmente tratar s2 como uma constante! Precisamos aplicar a regra da cadeia novamente e o que realmente temos é o seguinte:


 


![form6](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/form6.png)


 


Somamos as contribuições de cada passo de tempo para o gradiente. Em outras palavras, como W é usado em todas as etapas até a saída que nos interessa, precisamos retroceder gradientes na rede de t = 3 até t = 0:


![rnn-bptt-with-gradients](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/rnn-bptt-with-gradients.png)


Observe que isso é exatamente o mesmo que o algoritmo de retropropagação padrão que usamos nas Redes Neurais Profundas da Feedforward. A principal diferença é que resumimos os gradientes para W em cada etapa de tempo. Em um rede neural tradicional, não compartilhamos parâmetros entre camadas, portanto, não precisamos somar nada. Mas, na minha opinião, o BPTT é apenas um nome sofisticado para retropropagação padrão em uma RNN “desenrolada”. Assim como com Backpropagation, você pode definir um vetor delta que você repassa, por exemplo:


 


![form7](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/form7.png)


 


Aqui um exemplo de como seria a implementação do BPTT em Python:


[![bptt](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/bptt-1-1024x791.png)](https://github.com/dsacademybr)


 


Isso também deve lhe dar uma ideia do motivo pelo qual as RNNs são difíceis de treinar: as sequências (frases) podem ser bastante longas, talvez 20 palavras ou mais, e, portanto, você precisa retroceder através de várias camadas. Na prática, muitas pessoas truncam a retropropagação em poucos passos. Mas isso é assunto para o próximo capítulo! Até lá.


Referências:


[Matemática Para Data Science](https://www.datascienceacademy.com.br/course/matematica-para-data-science)


[Recurrent Neural Networks Cheatsheet](https://stanford.edu/~shervine/teaching/cs-230/cheatsheet-recurrent-neural-networks)


[A Beginner’s Guide to LSTMs and Recurrent Neural Networks](https://skymind.ai/wiki/lstm)


[Recurrent Neural Networks Tutorial, Part 1 – Introduction to RNNs](http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/)


[Recurrent Neural Networks Tutorial, Part 3 – Backpropagation Through Time and Vanishing Gradients](http://www.wildml.com/2015/10/recurrent-neural-networks-tutorial-part-3-backpropagation-through-time-and-vanishing-gradients/)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)





<div id="capitulo-50---a-matematica-da-dissipacao-do-gradiente-e-aplicacoes-das-rnns"></div>

# Capítulo 50 – A Matemática da Dissipação do Gradiente e Aplicações das RNNs


No [Capítulo 34](https://www.deeplearningbook.com.br/o-problema-da-dissipacao-do-gradiente/) nós discutimos sobre o problema da dissipação do gradiente e a dificuldade em treinar as redes neurais artificiais. Com as RNNs esse problema é ainda mais acentuado e por isso vamos agora estudar A Matemática da Dissipação do Gradiente e Aplicações das RNNs e compreender matematicamente porque o problema acontece.


Mencionamos anteriormente que as RNNs têm dificuldades em aprender dependências de longo alcance – interações entre palavras que estão separadas por vários passos, por exemplo. Isso é problemático porque o significado de uma frase em português é geralmente determinado por palavras que não são muito próximas: “O homem que usava uma peruca entrou no bar”. A frase é realmente sobre um homem entrando em um bar, não sobre a peruca. Mas é improvável que uma RNN simples seja capaz de capturar essas informações. Para entender porque, vamos dar uma olhada mais de perto no gradiente que calculamos no [capítulo anterior](https://www.deeplearningbook.com.br/a-matematica-do-backpropagation-through-time-bptt/):


 


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/form1-1.png)


 


Observe que:


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/form2-1.png)


 


é uma regra de cadeia em si! Por exemplo:


 


![form3](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/form3-1.png)


 


Observe também que, como estamos tomando a derivada de uma função vetorial em relação a um vetor, o resultado é uma matriz (chamada de [matriz jacobiana](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)) cujos elementos são todos derivadas *pointwise*. Podemos reescrever o gradiente acima da seguinte forma:


 


![form4](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/form4-1.png)


 


Acontece (esse [paper](http://proceedings.mlr.press/v28/pascanu13.pdf) explica isso em detalhes) que a norma (na álgebra linear, análise funcional e áreas relacionadas da matemática, uma norma é uma função que atribui um comprimento ou tamanho estritamente positivo a cada vetor em um espaço vetorial – exceto para o vetor zero, ao qual é atribuído um comprimento de zero), que você pode pensar como um valor absoluto, da matriz jacobiana acima tem um limite superior de 1. Isso porque a nossa função de ativação tanh (ou sigmóide) mapeia todos os valores em um intervalo entre -1 e 1, e a derivada é limitada por 1 (1/4 no caso de sigmoide) também:


 


![tanh](https://www.deeplearningbook.com.br/wp-content/uploads/2019/07/tanh.png)


 


Você pode ver que as funções tanh e sigmoid têm derivadas de 0 em ambas as extremidades, onde se aproximam de uma linha plana. Quando isso acontece, dizemos que os neurônios correspondentes estão saturados. Eles têm um gradiente nulo e conduzem outros gradientes nas camadas anteriores para 0. Assim, com valores pequenos nas multiplicações de matriz e múltiplas matrizes (t-k em particular) os valores de gradiente estão diminuindo exponencialmente rápido, desaparecendo completamente após alguns passos de tempo. 


Contribuições gradientes de etapas “longínquas” se tornam zero e o estado nessas etapas não contribui para o que a rede está aprendendo: a rede acaba não aprendendo dependências de longo alcance. Dissipações do gradiente não são exclusivos das RNNs e também acontecem em Redes Neurais Profundas Feedforward. Mas as RNNs tendem a ser muito profundas (tão profundas quanto a duração da sentença, em um problema de Processamento de Linguagem Natural por exemplo), o que torna o problema muito mais comum.


É fácil imaginar que, dependendo de nossas funções de ativação e parâmetros de rede, poderíamos obter explosão em vez de dissipação de gradientes, se os valores da matriz Jacobiana forem grandes. Na verdade, isso é chamado de problema de explosão do gradiente. A razão pela qual as dissipações do gradiente receberam mais atenção do que as explosões é dupla. Por um lado, explosão de gradientes são óbvias. Seus gradientes se tornarão NaN (não um número) e seu programa falhará. 


Em segundo lugar, recortar os gradientes em um limiar pré-definido é uma solução muito simples e eficaz para evitar a explosão dos gradientes. As dissipações dos gradientes são mais problemáticas porque não são óbvias quando ocorrem ou é mais complicado lidar com elas.


Felizmente, existem algumas maneiras de combater o problema da dissipação do gradiente. A inicialização adequada da matriz W pode reduzir o efeito do problema. Ou seja, aplicamos regularização. Uma solução mais interessante é usar as funções de ativação ReLU em vez de tanh ou sigmóide. A derivada ReLU é uma constante de 0 ou 1, por isso não é tão provável que sofra de dissipação do gradiente. 


Uma solução ainda mais popular é usar as arquiteturas Long Short-Term Memory (LSTM) ou Gated Recurrent Unit (GRU). As LSTMs foram propostas pela primeira vez em 1997 e são os modelos talvez mais amplamente usados em Processamento de Linguagem Natural atualmente. As GRUs, propostas pela primeira vez em 2014, são versões simplificadas das LSTMs. Ambas as arquiteturas RNN foram explicitamente projetadas para lidar com dissipação do gradiente e aprender eficientemente dependências de longo alcance. Vamos cobrir as duas arquiteturas nos próximos capítulos.


**Mas o que podemos fazer com as RNNs?**
----------------------------------------


As RNNs mostraram grande sucesso em muitas tarefas de Processamento de Linguagem Natural. Neste ponto, devo mencionar que os tipos de RNN mais usados são as LSTMs, que são muito melhores na captura de dependências de longo prazo do que as RNNs em sua arquitetura padrão. Mas não se preocupe, as LSTMs são essencialmente a mesma coisa que as RNNs, mas apenas têm uma maneira diferente de computar o estado oculto. Cobriremos as LSTMs com mais detalhes no próximo capítulo. Aqui estão alguns exemplos de aplicações de RNNs em Processamento de Linguagem Natural (o que não é uma lista definitiva).


#### **Modelagem de Linguagem e Geração de Texto**


Dada uma sequência de palavras, queremos prever a probabilidade de cada palavra dada às palavras anteriores. Os Modelos de Linguagem nos permitem medir a probabilidade de uma sentença, que é uma entrada importante para a Tradução Automática (já que as sentenças de alta probabilidade estão normalmente corretas). Um efeito colateral de poder prever a próxima palavra é que obtemos um modelo generativo, que nos permite gerar um novo texto por amostragem a partir das probabilidades de saída. E dependendo de quais são nossos dados de treinamento, podemos gerar todos os tipos de coisas. 


Em Modelagem de Linguagem, nossa entrada é tipicamente uma sequência de palavras (codificadas como vetores únicos), e nossa saída é a sequência de palavras previstas. Ao treinar a rede, definimos ot = x{t + 1}, pois queremos que a saída na etapa t seja a próxima palavra real.


#### **Machine Translation**


A tradução automática é semelhante à modelagem de linguagem, pois nossa entrada é uma sequência de palavras em nosso idioma de origem (por exemplo português). Queremos produzir uma sequência de palavras em nosso idioma de destino (por exemplo, inglês). A principal diferença é que nossa saída só é iniciada depois de termos visto a entrada completa, porque a primeira palavra de nossas sentenças traduzidas pode exigir informações capturadas da sequência de entrada completa.


#### **Reconhecimento de Fala**


Dada uma sequência de entrada de sinais acústicos de uma onda sonora, podemos prever uma sequência de segmentos fonéticos juntamente com suas probabilidades.


#### **Gerar Descrições de Imagens**


Juntamente com as redes neurais convolucionais, as RNNs foram usados como parte de um modelo para gerar descrições de imagens não rotuladas. É incrível como isso parece funcionar. O modelo combinado alinha as palavras geradas com os recursos encontrados nas imagens.


Continuamos no próximo capítulo.


Referências:


[Matemática Para Data Science](https://www.datascienceacademy.com.br/course/matematica-para-data-science)


[A Recursive Recurrent Neural Network for Statistical Machine Translation](https://www.aclweb.org/anthology/P14-1140)


[Sequence to Sequence Learning with Neural Networks](http://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf)


[Recurrent Neural Networks Cheatsheet](https://stanford.edu/~shervine/teaching/cs-230/cheatsheet-recurrent-neural-networks)


[On the difficulty of training recurrent neural networks](http://proceedings.mlr.press/v28/pascanu13.pdf)


[A Beginner’s Guide to LSTMs and Recurrent Neural Networks](https://skymind.ai/wiki/lstm)


[Recurrent Neural Networks Tutorial, Part 1 – Introduction to RNNs](http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/)


[Recurrent Neural Networks Tutorial, Part 3 – Backpropagation Through Time and Vanishing Gradients](http://www.wildml.com/2015/10/recurrent-neural-networks-tutorial-part-3-backpropagation-through-time-and-vanishing-gradients/)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)



<div id="capitulo-51---arquitetura-de-redes-neurais-long-short-term-memory-(lstm)"></div>

# Capítulo 51 – Arquitetura de Redes Neurais Long Short Term Memory (LSTM)


Estudamos as redes neurais recorrentes e suas limitações nos capítulos anteriores. Para superar alguns dos problemas das RNNs, podemos usar algumas de suas variações. Uma delas é chamada LSTM ou Long Short Term Memory, um tipo de rede neural recorrente, que é usada em diversos cenários de Processamento de Linguagem Natural. Neste capítulo estudaremos a Arquitetura de Redes Neurais Long Short Term Memory.


Precisamos de Memória
---------------------


Os humanos não começam a pensar do zero a cada segundo. Ao ler este capítulo, você entende cada palavra com base em sua compreensão das palavras anteriores. Você não joga tudo fora e começa a pensar de novo a cada palavra que você lê. Seus pensamentos têm persistência.


As redes neurais tradicionais não podem fazer isso, o que dificulta sua aplicação para resolver diversos problemas. Por exemplo, imagine que você queira classificar o tipo de evento que está acontecendo em todos os pontos de um filme. Não está claro como uma rede neural tradicional poderia usar o aprendizado sobre eventos anteriores no filme para informar os posteriores.


Redes neurais recorrentes resolvem esse problema. São redes com loops, permitindo que as informações persistam.


Esses laços fazem com que as redes neurais recorrentes pareçam misteriosas. No entanto, se você pensar um pouco mais, perceberá que não são tão diferentes de uma rede neural *normal*. Uma rede neural recorrente pode ser imaginada como múltiplas cópias da mesma rede, cada uma passando uma mensagem a um sucessor. Considere o que acontece se desenrolarmos o loop:


 


![RNN-unrolled](https://www.deeplearningbook.com.br/wp-content/uploads/2019/08/RNN-unrolled-1024x269.png)


 


Essa natureza de cadeia revela que redes neurais recorrentes estão intimamente relacionadas a sequências e listas, uma arquitetura natural da rede neural a ser usada para esses dados.


Nos últimos anos, tem havido um incrível sucesso ao aplicar as RNNs a uma variedade de problemas: reconhecimento de fala, modelagem de idiomas, tradução, legendas de imagens… A lista continua. Deixarei a discussão sobre os incríveis feitos que podemos alcançar com as RNNs com o excelente post de Andrej Karpathy, [The Unreasonable Effectiveness of Recurrent Neural Networks](http://karpathy.github.io/2015/05/21/rnn-effectiveness/). 


Entretanto, boa parte do sucesso das RNNs se deve a uma de suas variações, as LSTMs, um tipo muito especial de rede neural recorrente que funciona, para muitas tarefas, muito melhor do que a versão padrão. Quase todos os resultados empolgantes baseados em redes neurais recorrentes são alcançados com LSTMs. Vamos então compreender o que torna as LSTMs tão especiais.


Arquitetura da LSTM
-------------------


A LSTM é uma arquitetura de rede neural recorrente (RNN) que “*lembra”* valores em intervalos arbitrários. A LSTM é bem adequada para classificar, processar e prever séries temporais com intervalos de tempo de duração desconhecida. A insensibilidade relativa ao comprimento do gap dá uma vantagem à LSTM em relação a RNNs tradicionais (também chamadas “vanilla”), Modelos Ocultos de Markov (MOM) e outros métodos de aprendizado de sequências.


A estrutura de uma RNN é muito semelhante ao Modelo Oculto de Markov. No entanto, a principal diferença é como os parâmetros são calculados e construídos. Uma das vantagens da LSTM é a insensibilidade ao comprimento do gap. RNN e MOM dependem do estado oculto antes da emissão / sequência. Se quisermos prever a sequência após 1.000 intervalos em vez de 10, o modelo esqueceu o ponto de partida até então. Mas um modelo LSTM é capaz de “lembrar” por conta de sua estrutura de células, o diferencial da arquitetura LSTM.


A LSTM possui uma estrutura em cadeia que contém quatro redes neurais e diferentes blocos de memória chamados células.


 


![lstmcell](https://www.deeplearningbook.com.br/wp-content/uploads/2019/08/lstmcell.png)


 


A informação é retida pelas células e as manipulações de memória são feitas pelos portões (gates). Existem três portões:


**Forget Gate**: As informações que não são mais úteis no estado da célula são removidas com o forget gate. Duas entradas: x\_t (entrada no momento específico) e h\_t-1 (saída de célula anterior) são alimentadas ao gate e multiplicadas por matrizes de peso, seguidas pela adição do bias. O resultante é passado por uma função de ativação que fornece uma saída binária. Se para um determinado estado de célula a saída for 0, a informação é esquecida e para a saída 1, a informação é retida para uso futuro.


**Input Gate**: A adição de informações úteis ao estado da célula é feita pelo input gate. Primeiro, a informação é regulada usando a função sigmoide que filtra os valores a serem lembrados de forma similar ao forget gate usando as entradas h\_t-1 e x\_t. Então, um vetor é criado usando a função tanh que dá saída de -1 a +1, que contém todos os valores possíveis de h\_t-1 e x\_t. Os valores do vetor e os valores regulados são multiplicados para obter as informações úteis


**Output Gate**: A tarefa de extrair informações úteis do estado da célula atual para ser apresentadas como uma saída é feita pelo output gate. Primeiro, um vetor é gerado aplicando a função tanh na célula. Então, a informação é regulada usando a função sigmóide que filtra os valores a serem lembrados usando as entradas h\_t-1 e x\_t. Os valores do vetor e os valores regulados são multiplicados para serem enviados como uma saída e entrada para a próxima célula.


A célula RNN recebe duas entradas, a saída do último estado oculto e a observação no tempo = t. Além do estado oculto, não há informações sobre o passado para se lembrar. A memória de longo prazo é geralmente chamada de estado da célula. As setas em loop indicam a natureza recursiva da célula. Isso permite que as informações dos intervalos anteriores sejam armazenadas na célula LSTM. O estado da célula é modificado pelo forget gate colocado abaixo do estado da célula e também ajustado pela porta de modulação de entrada. Da equação, o estado da célula anterior esquece, multiplica-se com a porta do esquecimento e adiciona novas informações através da saída das portas de entrada.


Algumas das famosas aplicações das LSTMs incluem:


* Modelagem de Linguagem
* Tradução de Idiomas
* Legendas em Imagens
* Geração de Texto
* Chatbots


Continuamos no próximo capítulo!


Referências:


[Formação Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[A Recursive Recurrent Neural Network for Statistical Machine Translation](https://www.aclweb.org/anthology/P14-1140)


[Sequence to Sequence Learning with Neural Networks](http://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf)


[Recurrent Neural Networks Cheatsheet](https://stanford.edu/~shervine/teaching/cs-230/cheatsheet-recurrent-neural-networks)


[On the difficulty of training recurrent neural networks](http://proceedings.mlr.press/v28/pascanu13.pdf)


[A Beginner’s Guide to LSTMs and Recurrent Neural Networks](https://skymind.ai/wiki/lstm)


[Long Short-Term Memory (LSTM): Concept](https://medium.com/@kangeugine/long-short-term-memory-lstm-concept-cb3283934359)


[Recurrent Neural Networks Tutorial, Part 1 – Introduction to RNNs](http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/)


[Recurrent Neural Networks Tutorial, Part 3 – Backpropagation Through Time and Vanishing Gradients](http://www.wildml.com/2015/10/recurrent-neural-networks-tutorial-part-3-backpropagation-through-time-and-vanishing-gradients/)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-52---arquitetura-de-redes-neurais-gated-recurrent-unit-(gru)"></div>

# Capítulo 52 – Arquitetura de Redes Neurais Gated Recurrent Unit (GRU)


Neste capítulo estudaremos um tipo realmente fascinante de rede neural. Introduzido por [Cho, et al.](https://arxiv.org/pdf/1406.1078v3.pdf) em 2014, a GRU (Gated Recurrent Unit) visa resolver o problema da dissipação do gradiente que é comum em uma rede neural recorrente padrão. A GRU também pode ser considerada uma variação da [LSTM](https://www.deeplearningbook.com.br/arquitetura-de-redes-neurais-long-short-term-memory/) porque ambas são projetadas de maneira semelhante e, em alguns casos, produzem resultados igualmente excelentes. Para acompanhar este capítulo você precisa ter concluído os capítulos anteriores.


O Problema, Memória de Curto Prazo
----------------------------------


Redes neurais recorrentes sofrem de memória de curto prazo. Se uma sequência for longa o suficiente, elas terão dificuldade em transportar informações das etapas anteriores para as posteriores. Portanto, se você estiver tentando processar um parágrafo de texto para fazer previsões, as RNNs poderão deixar de fora informações importantes desde o início.


Durante a etapa de backpropagation, as redes neurais recorrentes sofrem com o problema da dissipação do gradiente. Gradientes são valores usados para atualizar os pesos das redes neurais. O problema da dissipação do gradiente é quando o gradiente diminui à medida que se propaga novamente ao longo do tempo. Se um valor de gradiente se torna extremamente pequeno, não contribui muito com o aprendizado.


Assim, nas redes neurais recorrentes, as camadas que recebem uma pequena atualização gradiente param de aprender. Portanto, como essas camadas não aprendem, as RNNs podem esquecer o que foi visto em sequências mais longas, tendo assim uma memória de curto prazo. 


LSTM e GRU Como Solução
-----------------------


LSTM e GRU foram criadas como a solução para a memória de curto prazo. Elas têm mecanismos internos chamados portões que podem regular o fluxo de informações.


 


![rnns](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/rnns-1024x651.png)


 


Esses portões podem aprender quais dados em uma sequência são importantes para manter ou jogar fora. Ao fazer isso, eles podem transmitir informações relevantes ao longo de uma longa cadeia de sequências para fazer previsões. Quase todos os resultados de última geração baseados em redes neurais recorrentes são alcançados com essas duas redes. LSTM e GRU podem ser usadas em reconhecimento de voz, síntese de fala e geração de texto. Você pode até usá-las para gerar legendas em vídeos. Essas são aplicações de ponta em [Inteligência Artificial.](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


### Como as GRUs Funcionam?


A GRU é a nova geração de redes neurais recorrentes e é bastante semelhante a uma LSTM. As GRUs se livraram do estado da célula e usaram o estado oculto para transferir informações. Essa arquitetura possui apenas dois portões, um portão de redefinição (reset gate) e um portão de atualização (update date). As GRUs são uma versão melhorada da rede neural recorrente padrão. Mas o que as torna tão especiais e eficazes?


![gru4](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/gru4-1024x835.png)


Para resolver o problema da dissipação do gradiente de uma RNN padrão, a GRU usa dois portões, reset e update gate. Basicamente, eles são dois vetores que decidem quais informações devem ser passadas para a saída. O que há de especial neles é que eles podem ser treinados para manter informações de muito tempo atrás, sem dissipá-las com o tempo ou remover informações irrelevantes para a previsão.


A estrutura da GRU permite capturar adaptativamente dependências de grandes sequências de dados sem descartar informações de partes anteriores da sequência. Isso é alcançado através de suas unidades de portões, semelhantes às das LSTMs. Esses portões são responsáveis por regular as informações a serem mantidas ou descartadas a cada etapa do tempo.


 


![gru5](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/gru5.jpg)


 


A capacidade da GRU de manter dependências ou memória de longo prazo decorre dos cálculos na célula da GRU para produzir o estado oculto. Enquanto as LSTMs têm dois estados diferentes passados entre as células – o estado da célula e o estado oculto, que carregam a memória de longo e curto prazo, respectivamente – as GRUs têm apenas um estado oculto transferido entre as etapas do tempo. Esse estado oculto é capaz de manter as dependências de longo e curto prazo ao mesmo tempo, devido aos mecanismos de restrição e cálculos pelos quais o estado oculto e os dados de entrada passam.


 


![gruxlstm](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/gruxlstm.jpg)


 


Assim como os portões das LSTMs, os portões na GRU são treinados para filtrar seletivamente qualquer informação irrelevante, mantendo o que é útil. Esses portões são essencialmente vetores contendo valores entre 0 e 1 que serão multiplicados com os dados de entrada e / ou estado oculto. Um valor 0 nos vetores indica que os dados correspondentes no estado de entrada ou oculto não são importantes e, portanto, retornarão como zero. Por outro lado, um valor 1 no vetor significa que os dados correspondentes são importantes e serão usados.


No próximo capítulo veremos os detalhes matemáticos por trás da GRU, uma das arquiteturas mais interessantes de Deep Learning e que tem obtido resultados formidáveis especialmente em Processamento de Linguagem Natural.


Aqui você encontra uma animação que ajuda a compreender o funcionamento das arquiteturas de Deep Learning do tipo recorrente: [Animated RNN, LSTM and GRU](https://towardsdatascience.com/animated-rnn-lstm-and-gru-ef124d06cf45)


Até o próximo capítulo!


Referências:


[Formação Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[Understanding GRU Networks](https://towardsdatascience.com/understanding-gru-networks-2ef37df6c9be)


[Illustrated Guide to LSTM’s and GRU’s: A step by step explanation](https://towardsdatascience.com/illustrated-guide-to-lstms-and-gru-s-a-step-by-step-explanation-44e9eb85bf21)


[Gated Recurrent Unit (GRU)](https://blog.floydhub.com/gru-with-pytorch/)


[A Recursive Recurrent Neural Network for Statistical Machine Translation](https://www.aclweb.org/anthology/P14-1140)


[Sequence to Sequence Learning with Neural Networks](http://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf)


[Recurrent Neural Networks Cheatsheet](https://stanford.edu/~shervine/teaching/cs-230/cheatsheet-recurrent-neural-networks)


[On the difficulty of training recurrent neural networks](http://proceedings.mlr.press/v28/pascanu13.pdf)


[A Beginner’s Guide to LSTMs and Recurrent Neural Networks](https://skymind.ai/wiki/lstm)


[Long Short-Term Memory (LSTM): Concept](https://medium.com/@kangeugine/long-short-term-memory-lstm-concept-cb3283934359)


[Recurrent Neural Networks Tutorial, Part 1 – Introduction to RNNs](http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/)


[Recurrent Neural Networks Tutorial, Part 3 – Backpropagation Through Time and Vanishing Gradients](http://www.wildml.com/2015/10/recurrent-neural-networks-tutorial-part-3-backpropagation-through-time-and-vanishing-gradients/)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-53---matematica-na-gru,-dissipacao-e-clipping-do-gradiente"></div>

# Capítulo 53 – Matemática na GRU, Dissipação e Clipping do Gradiente


A capacidade da rede GRU de manter dependências ou memória de longo prazo decorre dos cálculos na célula na GRU para produzir o estado oculto. As LSTMs têm dois estados diferentes passados entre as células – o estado da célula e o estado oculto, que carregam a memória de longo e curto prazo, respectivamente – as GRUs têm apenas um estado oculto transferido entre as etapas do tempo. Esse estado oculto é capaz de manter as dependências de longo e curto prazo ao mesmo tempo, devido aos mecanismos de restrição (portões) e cálculos pelos quais o estado oculto e os dados de entrada passam.


 


![gruxlstm](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/gruxlstm.jpg)


 


A célula GRU contém apenas dois portões: o portão de atualização e o portão de redefinição. Assim como os portões das LSTMs, os portões na GRU são treinados para filtrar seletivamente qualquer informação irrelevante, mantendo o que é útil. Esses portões são essencialmente vetores contendo valores entre 0 e 1 que serão multiplicados com os dados de entrada e/ou estado oculto. Um valor 0 nos vetores indica que os dados correspondentes no estado de entrada ou oculto não são importantes e, portanto, retornarão como zero. Por outro lado, um valor 1 no vetor significa que os dados correspondentes são importantes e serão usados.


Usaremos os termos gate e vetor de forma intercambiável para o restante deste capítulo, pois eles se referem à mesma coisa.


A estrutura de uma unidade GRU é mostrada abaixo.


 


 


![gru1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/gru1.jpg)


 


 


Embora a estrutura possa parecer bastante complicada devido ao grande número de conexões, o mecanismo por trás dela pode ser dividido em três etapas principais.


Reset Gate
----------


Na primeira etapa, criamos o portão de redefinição (reset gate). Essa porta é derivada e calculada usando o estado oculto da etapa anterior e os dados de entrada na etapa atual.


Matematicamente, isso é conseguido multiplicando o estado oculto anterior e a entrada atual com seus respectivos pesos e somando-os antes de passar a soma através de uma função sigmóide. A função sigmoide transformará os valores entre 0 e 1, permitindo que o portão filtre entre as informações menos importantes e mais importantes nas etapas subsequentes. A fórmula matemática é representada abaixo:


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/form1.png)


Quando toda a rede é treinada através de backpropagation, os pesos na equação serão atualizados de forma que o vetor aprenda a reter apenas os recursos úteis.


O estado oculto anterior será primeiro multiplicado por um peso treinável e passará por uma multiplicação por elementos (produto Hadamard) com o vetor de redefinição. Esta operação decidirá quais informações serão mantidas nas etapas anteriores, juntamente com as novas entradas. Ao mesmo tempo, a entrada atual também será multiplicada por um peso treinável antes de ser somada com o produto do vetor de redefinição e do estado oculto anterior acima. Por fim, uma função tanh de ativação não linear será aplicada ao resultado final para obter r na equação abaixo.


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/form2.png)


Update Gate
-----------


Em seguida, temos o portão de atualização (update gate). Assim como o reset gate, o update gate é calculado usando o estado oculto anterior e os dados de entrada atuais.


Os vetores Update e Reset gate são criados usando a mesma fórmula, mas os pesos multiplicados pela entrada e pelo estado oculto são exclusivos para cada portão, o que significa que os vetores finais para cada portão são diferentes. Isso permite que os portões sirvam a seus propósitos específicos.


![form3](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/form3.png)


O vetor Update será submetido a multiplicação por elementos com o estado oculto anterior para obter u em nossa equação abaixo, que será usada para calcular nossa saída final posteriormente.


![](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/form4.png)


O vetor Update também será usado em outra operação posteriormente ao obter nossa saída final. O objetivo do update gate aqui é ajudar o modelo a determinar quanto das informações passadas armazenadas no estado oculto anterior precisam ser retidas para o futuro.


Combinando as Saídas
--------------------


Na última etapa, reutilizaremos o portal Update e obteremos o estado oculto atualizado.


Desta vez, pegaremos a versão inversa em elementos do mesmo vetor Update (1 – Update gate) e faremos uma multiplicação em elementos com a nossa saída do reset gate, r. O objetivo desta operação é o gate Update determinar qual parte das novas informações deve ser armazenada no estado oculto.


Por fim, o resultado das operações acima será resumido com a nossa saída do portão Update na etapa anterior, u. Isso nos dará nosso novo e atualizado estado oculto.


![form5](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/form5.png)


Podemos usar esse novo estado oculto como nossa saída para esse intervalo de tempo, passando-o por uma camada de ativação linear.


Solução do Problema de Dissipação/Explosão do Gradiente
-------------------------------------------------------


Vimos os portões em ação. Sabemos como eles transformam nossos dados. Agora, vamos revisar seu papel geral no gerenciamento da memória da rede e falar sobre como eles resolvem o problema de dissipação/explosão do gradiente.


Como vimos nos mecanismos acima, o Reset Gate é responsável por decidir quais partes do estado oculto anterior devem ser combinadas com a entrada atual para propor um novo estado oculto.


E o Update Gate é responsável por determinar quanto do estado oculto anterior deve ser retido e qual parte do novo estado oculto proposto (derivado do Reset Gate) deve ser adicionado ao estado oculto final. Quando o Update Gate é multiplicado pela primeira vez com o estado oculto anterior, a rede escolhe quais partes do estado oculto anterior ele manterá em sua memória enquanto descarta o restante. Posteriormente, ele corrige as partes ausentes das informações quando usa o inverso do gate Update para filtrar o novo estado oculto proposto a partir do Reset Gate.


Isso permite que a rede retenha dependências de longo prazo. O Update Gate pode optar por manter a maioria das memórias anteriores no estado oculto se os valores do vetor Update estiverem próximos de 1 sem recalcular ou alterar todo o estado oculto.


O problema de dissipação/explosão do gradiente ocorre durante a propagação de retorno (backpropagation) ao treinar a RNN, especialmente se a RNN estiver processando longas sequências ou tiver várias camadas. O erro do gradiente calculado durante o treinamento é usado para atualizar o peso da rede na direção certa e na magnitude certa. No entanto, esse gradiente é calculado com a regra da cadeia ([chain rule](https://www.deeplearningbook.com.br/a-matematica-do-problema-de-dissipacao-do-gradiente-em-deep-learning/)), começando no final da rede. Portanto, durante o backpropagation, os gradientes sofrerão continuamente multiplicações de matrizes e encolherão ou explodirão exponencialmente por sequências longas. Ter um gradiente muito pequeno significa que o modelo não atualiza seus pesos de maneira eficaz, enquanto gradientes extremamente grandes fazem com que o modelo seja instável.


Os portões nas LSTM e GRUs ajudam a resolver esse problema devido ao componente aditivo dos portões de atualização. Enquanto as RNNs tradicionais sempre substituem todo o conteúdo do estado oculto a cada etapa, as LSTMs e GRUs mantêm a maior parte do estado oculto existente enquanto adicionam novo conteúdo sobre ele. Isso permite que os erros dos gradientes sejam propagados de volta sem desaparecer ou explodir muito rapidamente devido às operações de adição.


Clipping (Recorte) do Gradiente
-------------------------------


Embora LSTMs e GRUs sejam as correções mais usadas para o problema acima, outra solução para o problema de explosão de gradientes é o clipping do gradiente. 


O clipping do gradiente é mais comum em redes neurais recorrentes. Quando os gradientes estão sendo propagados no tempo, eles podem desaparecer porque são continuamente multiplicados por números menores que um. Isso é chamado de problema de dissipação do gradiente, podendo ser resolvido por LSTMs e GRUs e, se você estiver usando uma rede profunda feed-forward, isso é resolvido por conexões residuais. Por outro lado, você também pode ter  explosão dos gradientes. É quando eles se tornam exponencialmente grandes por serem multiplicados por números maiores que 1. O clipping do gradiente *cortará* os gradientes entre dois números para impedir que eles fiquem muito grandes.


O clipping define um valor limite definido nos gradientes, o que significa que, mesmo se um gradiente aumentar além do valor predefinido durante o treinamento, seu valor ainda será limitado ao limite definido. Dessa forma, a direção do gradiente permanece inalterada e apenas a magnitude do gradiente é alterada.


Até o próximo capítulo!


Referências:


[Formação Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[Understanding GRU Networks](https://towardsdatascience.com/understanding-gru-networks-2ef37df6c9be)


[Illustrated Guide to LSTM’s and GRU’s: A step by step explanation](https://towardsdatascience.com/illustrated-guide-to-lstms-and-gru-s-a-step-by-step-explanation-44e9eb85bf21)


[Gated Recurrent Unit (GRU)](https://blog.floydhub.com/gru-with-pytorch/)


[A Recursive Recurrent Neural Network for Statistical Machine Translation](https://www.aclweb.org/anthology/P14-1140)


[Sequence to Sequence Learning with Neural Networks](http://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf)


[Recurrent Neural Networks Cheatsheet](https://stanford.edu/~shervine/teaching/cs-230/cheatsheet-recurrent-neural-networks)


[On the difficulty of training recurrent neural networks](http://proceedings.mlr.press/v28/pascanu13.pdf)


[A Beginner’s Guide to LSTMs and Recurrent Neural Networks](https://skymind.ai/wiki/lstm)


[Long Short-Term Memory (LSTM): Concept](https://medium.com/@kangeugine/long-short-term-memory-lstm-concept-cb3283934359)


[Recurrent Neural Networks Tutorial, Part 1 – Introduction to RNNs](http://www.wildml.com/2015/09/recurrent-neural-networks-tutorial-part-1-introduction-to-rnns/)


[Recurrent Neural Networks Tutorial, Part 3 – Backpropagation Through Time and Vanishing Gradients](http://www.wildml.com/2015/10/recurrent-neural-networks-tutorial-part-3-backpropagation-through-time-and-vanishing-gradients/)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-54---introducao-as-redes-adversarias-generativas-(gans---generative-adversarial-networks)"></div>

# Capítulo 54 – Introdução às Redes Adversárias Generativas (GANs – Generative Adversarial Networks)


 


**Você pode não achar que os programadores são artistas, mas a programação é uma profissão extremamente criativa. É criatividade baseada em lógica. – John Romero**


Redes Adversárias Generativas (GANs) são arquiteturas de redes neurais profundas compostas por duas redes colocadas uma contra a outra (daí o nome “adversárias”). Esta é uma das arquiteturas mais recentes e mais fascinantes em Deep Learning e que estudaremos a partir de agora!


As GANs foram introduzidos em um [artigo](https://arxiv.org/abs/1406.2661) de Ian Goodfellow e outros pesquisadores da Universidade de Montreal, incluindo Yoshua Bengio, em 2014. Referindo-se às GANs, o diretor de pesquisa de IA do Facebook, Yann LeCun, chamou o treinamento adversário de “a ideia mais interessante nos últimos 10 anos em Machine Learning”.


O potencial das GANs é enorme porque elas podem aprender a imitar qualquer distribuição de dados. Ou seja, as GANs podem ser ensinadas a criar mundos estranhamente semelhantes aos nossos em qualquer domínio: imagens, música, fala, prosa. Elas são artistas robóticos, em certo sentido, e sua produção é impressionante – até comovente.


Em uma virada surreal, a [Christie’s](https://twitter.com/ChristiesInc) (famosa rede inglesa de leilões) vendeu um retrato de US $ 432.000 gerado por uma GAN, com base no código-fonte aberto escrito por Robbie Barrat, de Stanford. Como a maioria dos artistas de verdade, ele não viu nada do dinheiro, que foi para a empresa francesa Obvious.


![GANs](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/gans.png)


Dois dos nus gerados por GANs. Imagens de [Robbie Barrat](https://www.theverge.com/2018/10/23/18013190/ai-art-portrait-auction-christies-belamy-obvious-robbie-barrat-gans)


Em 2019, o DeepMind mostrou que os Autoencoders Variacionais (VAEs) poderiam superar as GANs na geração de faces. Estudaremos os Autoencoders mais a frente aqui no livro.


### Algoritmos Generativos vs. Discriminativos


Antes de entrar nos detalhes, vamos dar uma rápida visão geral do que são feitas as GANs. As Redes Adversárias Generativas pertencem ao conjunto de modelos generativos. Isso significa que eles são capazes de produzir / gerar (veremos como) novo conteúdo. Naturalmente, essa capacidade de gerar novo conteúdo faz com que as GANs pareçam um pouco “mágicas”, pelo menos à primeira vista. Nos capítulos seguintes superaremos a aparente mágica das GANs para mergulhar na matemática e modelagem por trás desses modelos. Não apenas discutiremos as noções fundamentais de que as Redes Adversárias Generativas se baseiam, mas estudaremos os conceitos principais dessa arquitetura passo a passo.


Para entender as GANs, você deve saber como os algoritmos generativos funcionam e, para isso, contrastá-los com algoritmos discriminativos é instrutivo. Algoritmos discriminativos tentam classificar os dados de entrada; isto é, dados os recursos de uma instância de dados, eles prevêem um rótulo ou categoria à qual esses dados pertencem. Praticamente tudo que estudamos no [livro](https://www.deeplearningbook.com.br/deep-learning-a-tempestade-perfeita/) até aqui se refere a algoritmos discriminativos.


Por exemplo, dadas todas as palavras em um email (a instância de dados), um algoritmo discriminativo poderia prever se a mensagem é spam ou não é spam. O spam é um dos rótulos e o conjunto de palavras coletadas no email são os recursos que constituem os dados de entrada. Quando esse problema é expresso matematicamente, o rótulo é chamado y e os recursos são chamados x. A formulação p (y | x) é usada para significar “a probabilidade de y dado x”, que neste caso seria traduzido para “a probabilidade de um email ser spam, dadas as palavras que ele contém”.


Algoritmos discriminativos mapeiam recursos para rótulos e estão preocupados apenas com essa correlação. Uma maneira de pensar sobre algoritmos generativos é que eles fazem o oposto. Em vez de prever um rótulo com determinados recursos, eles tentam prever os recursos com um determinado rótulo.


A pergunta que um algoritmo generativo tenta responder é: Supondo que este email seja spam, qual a probabilidade desses recursos? Enquanto os modelos discriminativos se preocupam com a relação entre y e x, os modelos generativos se preocupam com “como você obtém x”. Eles permitem capturar p (x | y), a probabilidade de x dado y ou a probabilidade de recursos com um rótulo ou categoria. Dito isto, algoritmos generativos também podem ser usados ​​como classificadores. Acontece que eles podem fazer mais do que categorizar dados de entrada. O que mais eles podem fazer? Ainda estamos descobrindo, pois a evolução está acontecendo agora nesse momento com pesquisas em todo mundo e [Cientistas de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) e [Engenheiros de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia) trabalhando em diferentes aplicações.


Outra maneira de pensar sobre isso é distinguir discriminativo de generativo assim:


* Modelos discriminativos aprendem a fronteira entre classes.
* Modelos generativos modelam a distribuição de classes individuais.


### Como as GANs Funcionam


Vejamos uma visão geral das GANs e nos próximos capítulos entraremos nos detalhes matemáticos e estatísticos da arquitetura.


Uma rede neural, chamada de gerador, gera novas instâncias de dados, enquanto a outra, o discriminador, avalia sua autenticidade; ou seja, o discriminador decide se cada instância de dados que ele analisa pertence ou não ao conjunto de dados de treinamento real (a imagem abaixo demonstra isso).


![gan_schema](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/gan_schema.png)


Digamos que estamos tentando fazer algo mais banal do que imitar a Mona Lisa. Geraremos números escritos à mão, como os encontrados no conjunto de dados MNIST, retirado do mundo real. O objetivo do discriminador, quando mostrada uma instância do verdadeiro conjunto de dados MNIST, é reconhecer aqueles que são autênticos.


Enquanto isso, o gerador está criando novas imagens sintéticas que são transmitidas ao discriminador. O gerador gera as imagens fake na esperança de que elas também sejam consideradas autênticas, mesmo sendo falsas. O objetivo do gerador é gerar dígitos manuscritos cada vez melhores. O objetivo do discriminador é identificar imagens falsas do gerador. Ou seja, são duas redes adversárias, uma discriminativa (padrão que já estudamos até aqui no livro) e uma generativa que, em termos gerais, faz o oposto das redes discriminativas.


Aqui estão as etapas de uma GAN:


* O gerador considera números aleatórios e retorna uma imagem.
* Essa imagem gerada é inserida no discriminador ao lado de um fluxo de imagens tiradas do conjunto de dados real e verdadeiro.
* O discriminador obtém imagens reais e falsas e retorna probabilidades, um número entre 0 e 1, com 1 representando uma previsão de imagem autêntica e 0 representando previsão de imagens falsas (geradas pela rede generativa).


Então você tem um loop de feedback duplo assim:


![GANs](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/GANs-1.png)


Image credit: [Thalles Silva](https://sthalles.github.io/intro-to-gans/)


Para o MNIST, a rede discriminadora é uma rede convolucional padrão que pode categorizar as imagens alimentadas, um classificador binomial que rotula as imagens como reais ou falsas. O gerador é uma rede convolucional inversa, em certo sentido: enquanto um classificador convolucional padrão recebe uma imagem e reduz a amostragem para produzir uma probabilidade, o gerador pega um vetor de ruído aleatório e faz o upsample para uma imagem. O primeiro joga fora os dados por meio de técnicas de downsampling, como o maxpool, e o segundo gera novos dados.


Ambas as redes estão tentando otimizar uma função objetivo (função de perda) diferente e oposta. À medida que o discriminador muda seu comportamento, o gerador também muda e vice-versa. Suas perdas empurram um contra o outro. Uma ideia simples e genial! Durante o treinamento, a rede generativa vai aprendendo a criar uma imagem fake que fica cada vez mais próxima de uma imagem real. Alguns pesquisadores tem feito o mesmo com a voz, gerando falas que são falsas, mas se parecem muito com falas verdadeiras. Esse é o perigo das Deep Fakes, quando a tecnologia é usada para o mal, infelizmente. Aqui tem um exemplo de Deep Fake gerada com GAN para fala do ex-presidente dos EUA, Barack Obama: [Fake Obama created using AI video tool – BBC News](https://www.youtube.com/watch?v=AmUC4m6w1wo). 


![gan](https://www.deeplearningbook.com.br/wp-content/uploads/2019/09/gan.png)


Quer aprender mais sobre as GANs? Então acompanhe os próximos capítulos!


Referências:


[Cyber Security Data Science](https://www.datascienceacademy.com.br/course/cyber-security-data-science)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[A Beginner’s Guide to Generative Adversarial Networks (GANs)](https://wiki.pathmind.com/generative-adversarial-network-gan)


[A Leap into the Future: Generative Adversarial Networks](https://medium.com/datadriveninvestor/a-leap-into-the-future-generative-adversarial-networks-96a780ed8ee6)


[Understanding Generative Adversarial Networks (GANs)](https://towardsdatascience.com/understanding-generative-adversarial-networks-gans-cd6e4651a29)


[How A.I. Is Creating Building Blocks to Reshape Music and Art](https://www.nytimes.com/2017/08/14/arts/design/google-how-ai-creates-new-music-and-new-artists-project-magenta.html)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


<div id="capitulo-55---geracao-de-variaveis-aleatorias---uma-das-bases-dos-modelos-generativos-em-gans-(generative-adversarial-networks)"></div>

# Capítulo 55 – Geração de Variáveis Aleatórias – Uma das Bases dos Modelos Generativos em GANs (Generative Adversarial Networks)


Neste capítulo discutiremos o processo de geração de variáveis aleatórias a partir de uma determinada distribuição, tema importante para compreender o funcionamento dos modelos generativos das GANs e nos próximos capítulos veremos os detalhes de funcionamento dos modelos generativos e os detalhes matemáticos das GANs. Estamos considerando que você leu o capítulo [anterior](https://www.deeplearningbook.com.br/introducao-as-redes-adversarias-generativas-gans-generative-adversarial-networks/).


### Variáveis ​​aleatórias uniformes podem ser geradas pseudo-aleatoriamente


Vamos começar discutindo o processo de geração de variáveis ​​aleatórias. Veremos alguns métodos existentes e, mais especificamente, o método de transformação inversa que permite gerar variáveis ​​aleatórias complexas a partir de variáveis ​​aleatórias uniformes simples. Embora tudo isso possa parecer um pouco distante do nosso assunto, GANs, veremos no próximo capítulo o vínculo profundo que existe com os modelos generativos. Se o conceito de Estatística for algo que você esteja vendo pela primeira vez, a DSA oferece cursos completos de Estatística e Matemática na [Formação Análise Estatística.](https://www.datascienceacademy.com.br/bundle/formacao-analise-estatistica)


Uma variável aleatória é uma variável quantitativa, cujo resultado (valor) depende de fatores aleatórios. Um exemplo de uma variável aleatória é o resultado do lançamento de um dado que pode resultar em qualquer número entre 1 e 6. Embora possamos conhecer os seus possíveis resultados, o resultado em si depende de fatores de sorte (álea). Uma variável aleatória pode ser uma medição de um parâmetro que pode gerar valores diferentes. O conceito de variável aleatória é essencial em Estatística e em outros métodos quantitativos para a representação de fenômenos incertos. Este conceito é estudado em detalhes no curso [Análise Estatística Para Data Science com Linguagem R](https://www.datascienceacademy.com.br/course/analise-estatistica-para-data-science-com-linguagem-r).


As variáveis aleatórias podem ser classificadas em variáveis aleatórias discretas, contínuas e mistas.


Os computadores são fundamentalmente determinísticos. Portanto, é teoricamente impossível gerar números realmente aleatórios (a pergunta “o que realmente é aleatoriedade?” é algo difícil de responder). No entanto, é possível definir algoritmos que geram sequências de números cujas propriedades estão muito próximas das propriedades das sequências teóricas de números aleatórios. Em particular, um computador é capaz, usando um gerador de números pseudo-aleatórios, de gerar uma sequência de números que segue aproximadamente uma distribuição aleatória uniforme entre 0 e 1. O caso uniforme é muito simples, no qual variáveis ​​aleatórias mais complexas podem ser construídas.


### Variáveis ​​aleatórias expressas como resultado de uma operação ou processo


Existem diferentes técnicas que visam gerar variáveis ​​aleatórias mais complexas. Entre elas, podemos encontrar, por exemplo, método de transformação inversa, amostragem por rejeição, algoritmo Metropolis-Hastings entre outros. Todos esses métodos se baseiam em diferentes truques matemáticos que consistem principalmente em representar a variável aleatória que queremos gerar como resultado de uma operação (sobre variáveis ​​aleatórias mais simples) ou de um processo.


A [amostragem por rejeição](https://en.wikipedia.org/wiki/Rejection_sampling) expressa a variável aleatória como resultado de um processo que consiste em amostrar não da distribuição complexa, mas de uma distribuição simples bem conhecida e para aceitar ou rejeitar o valor amostrado, dependendo de alguma condição. Repetindo esse processo até que o valor amostrado seja aceito, podemos mostrar que, com a condição correta de aceitação, o valor que será efetivamente amostrado seguirá a distribuição correta.


No algoritmo [Metropolis-Hastings](https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm), a ideia é encontrar uma Cadeia de Markov (MC – Markov Chain) de modo que a distribuição estacionária dessa MC corresponda à distribuição da qual gostaríamos de amostrar nossa variável aleatória. Uma vez encontrada essa MC, podemos simular uma trajetória longa o suficiente sobre ela para considerar que atingimos um estado estacionário e, em seguida, o último valor que obtemos dessa maneira pode ser considerado como extraído da distribuição de interesse.


Não iremos mais adiante nos detalhes da amostragem por rejeição e do Metropolis-Hastings, porque esses métodos não são os que nos levarão à noção por trás das GANs. No entanto, vamos nos concentrar um pouco mais no método de transformação inversa.


### O método de transformação inversa


A ideia do método de transformação inversa é simplesmente representar nossa “complexa” variável aleatória como resultado de uma função aplicada a um variável aleatória uniforme, que nós sabemos como gerar.


Consideramos abaixo um exemplo unidimensional. Seja X uma variável aleatória complexa da qual queremos amostrar e U seja uma variável aleatória uniforme sobre [0,1] que sabemos como amostrar. Lembramos que uma variável aleatória é totalmente definida por sua Função de Distribuição Cumulativa (CDF). O CDF de uma variável aleatória é uma função do domínio de definição da variável aleatória até o intervalo [0,1] e definido, em uma dimensão, de modo que:


 


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/form1.png)


 


No caso particular de nossa variável aleatória uniforme U, temos:


 


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/form2.png)


 


Por uma questão de simplicidade, vamos supor aqui que a função CDF\_X é inversível e seu inverso é indicado por:


 


![form3](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/form3.png)


 


(o método pode ser facilmente estendido ao caso não inversível usando o inverso generalizado da função, mas não é realmente o ponto principal em que queremos focar aqui). Então, se definirmos:


 


![form4](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/form4.png)


 


temos:


 


![form5](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/form5.png)


 


Como podemos ver, Y e X têm o mesmo CDF e depois definem a mesma variável aleatória. Assim, definindo Y como acima (em função de uma variável aleatória uniforme), conseguimos definir uma variável aleatória com a distribuição alvo.


Para resumir, o método de transformação inversa é uma maneira de gerar uma variável aleatória que segue uma determinada distribuição, fazendo uma variável aleatória uniforme passar por uma “função de transformação” bem projetada (CDF inverso). Essa noção de “método de transformação inversa” pode, de fato, ser estendida à noção de “método de transformação” que consiste, de maneira mais geral, em gerar variáveis ​​aleatórias em função de algumas variáveis ​​aleatórias mais simples (não necessariamente uniformes e, em seguida, a função de transformação é não mais o CDF inverso). Conceitualmente, o objetivo da “função de transformação” é deformar / remodelar a distribuição de probabilidade inicial: a função de transformação começa de onde a distribuição inicial é muito alta em comparação com a distribuição de destino e a coloca onde é muito baixa. Foi exatamente isso que pensou o criador do modelo GAN e muitos consideram o conceito como uma espécie de “hack” na teoria estatística, o que gerou o modelo GAN.


Observe a ilustração do método de transformação inversa abaixo. Em azul: a distribuição uniforme em [0,1]. Em laranja: a distribuição gaussiana (normal) padrão. Em cinza: o mapeamento da distribuição uniforme para a gaussiana (CDF inverso).


 


![dist](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/dist-1024x367.jpeg)


 


Compreendeu o conceito? Isso é o que está por trás dos modelos generativos nas GANs, que veremos no próximo capítulo!


Referências:


[Análise Estatística Para Data Science com Linguagem Python](https://www.datascienceacademy.com.br/course/analise-estatistica-para-data-science-com-linguagem-python)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[A Beginner’s Guide to Generative Adversarial Networks (GANs)](https://skymind.ai/wiki/generative-adversarial-network-gan)


[A Leap into the Future: Generative Adversarial Networks](https://medium.com/datadriveninvestor/a-leap-into-the-future-generative-adversarial-networks-96a780ed8ee6)


[Understanding Generative Adversarial Networks (GANs)](https://towardsdatascience.com/understanding-generative-adversarial-networks-gans-cd6e4651a29)


[How A.I. Is Creating Building Blocks to Reshape Music and Art](https://www.nytimes.com/2017/08/14/arts/design/google-how-ai-creates-new-music-and-new-artists-project-magenta.html)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


 





<div id="capitulo-56---modelos-generativos---o-diferencial-das-gans-(generative-adversarial-networks)"></div>

# Capítulo 56 – Modelos Generativos – O Diferencial das GANs (Generative Adversarial Networks)


Neste capítulo discutiremos o funcionamento dos modelos generativos, o principal diferencial nas GANs (Generative Adversarial Networks). Estamos considerando que você leu o capítulo [anterior](https://www.deeplearningbook.com.br/geracao-de-variaveis-aleatorias-uma-das-bases-dos-modelos-generativos-em-gans-generative-adversarial-networks/).


Suponha que estamos interessados ​​em gerar imagens quadradas em preto e branco de cães com um tamanho de n por n pixels. Podemos remodelar cada dado como um vetor dimensional N = n x n (empilhando colunas umas sobre as outras), de modo que uma imagem de cachorro possa ser representada por um vetor (quem sabe conseguimos criar um modelo capaz de diferenciar um Muffin de um Chihuahua).


 


![dogs](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/dogs.jpeg)


 


No entanto, isso não significa que todos os vetores representem um cão que foi moldado de volta a um quadrado! Portanto, podemos dizer que os vetores dimensionais N que efetivamente geram algo que se parece com um cachorro são distribuídos de acordo com uma distribuição de probabilidade muito específica em todo o espaço vetorial dimensional N (alguns pontos desse espaço provavelmente representam cães, enquanto é improvável para alguns outros). No mesmo espírito, existe, nesse espaço vetorial dimensional N, distribuições de probabilidade para imagens de gatos, pássaros e assim por diante.


Então, o problema de gerar uma nova imagem do cão é equivalente ao problema de gerar um novo vetor após a “distribuição de probabilidade do cão” no espaço vetorial dimensional N. De fato, estamos enfrentando um problema de gerar uma variável aleatória com relação a uma distribuição de probabilidade específica (lembra do que discutimos no capítulo [anterior](https://www.deeplearningbook.com.br/geracao-de-variaveis-aleatorias-uma-das-bases-dos-modelos-generativos-em-gans-generative-adversarial-networks/)?).


Neste ponto, podemos mencionar duas coisas importantes. Primeiro, a “distribuição de probabilidade canina” que mencionamos é uma distribuição muito complexa em um espaço muito grande. Segundo, mesmo se pudermos assumir a existência de tal distribuição subjacente (na verdade existem imagens que se parecem com cachorro e outras que não), obviamente não sabemos como expressar explicitamente essa distribuição. Os dois pontos anteriores dificultam bastante o processo de geração de variáveis ​​aleatórias a partir dessa distribuição. Vamos tentar resolver esses dois problemas a seguir.


Nosso primeiro problema ao tentar gerar nossa nova imagem de cachorro é que a “distribuição de probabilidade do cachorro” no espaço vetorial dimensional N é muito complexa e não sabemos como gerar diretamente variáveis ​​aleatórias complexas. No entanto, como sabemos muito bem como gerar N variáveis ​​aleatórias uniformes não correlacionadas, poderíamos fazer uso do método de transformação. Para fazer isso, precisamos expressar nossa variável aleatória N dimensional como resultado de uma função muito complexa aplicada a uma variável aleatória N dimensional simples!


Aqui, podemos enfatizar o fato de que encontrar a função de transformação não é tão simples quanto tomar a inversa de forma fechada da Função de Distribuição Cumulativa (que obviamente não sabemos) como fizemos ao descrever o método de transformação inversa no capítulo [anterior](https://www.deeplearningbook.com.br/geracao-de-variaveis-aleatorias-uma-das-bases-dos-modelos-generativos-em-gans-generative-adversarial-networks/). A função de transformação não pode ser expressa explicitamente e, então, precisamos aprender com os dados (essa é uma das razões pelas quais treinamos um modelo de Machine Learning e esse conceito é estudado em detalhes [aqui](https://www.datascienceacademy.com.br/course?courseid=machine-learning-engineer)).


Em seguida, a ideia é modelar a função de transformação por uma rede neural que tome como entrada uma variável aleatória uniforme N dimensional simples e que retorne como saída outra variável aleatória N dimensional que deve seguir, após o treinamento, a “distribuição de probabilidade canina” correta . Depois que a arquitetura da rede foi projetada, ainda precisamos treiná-la. Nas próximas duas seções, discutiremos duas maneiras de treinar essas redes generativas, incluindo a ideia de treinamento antagônico por trás das GANs!


 


![model1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/model1-1024x488.png)


 


### Redes de Correspondência Generativa (Generative Matching Networks)


Obs: a denominação de “redes de correspondência generativa” não é padrão. No entanto, podemos encontrar na literatura, por exemplo, “Redes de correspondência de momentos generativos” ou também “Redes de correspondência de recursos generativos”. Só queremos aqui usar uma denominação um pouco mais geral para o que descrevemos abaixo.


### Treinando Modelos Generativos


Até agora, mostramos que nosso problema de gerar uma nova imagem de cachorro pode ser reformulado em um problema de gerar um vetor aleatório no espaço vetorial dimensional N que segue a “distribuição de probabilidade canina” e sugerimos o uso de um método de transformação , com uma rede neural para modelar a função de transformação.


Agora, ainda precisamos treinar (otimizar) a rede para expressar a função de transformação correta. Para isso, podemos sugerir dois métodos diferentes de treinamento: um direto e um indireto. O método de treinamento direto consiste em comparar as distribuições de probabilidade verdadeira e gerada e *retropropagar* a diferença (o erro) através da rede. Essa é a ideia que governa as redes de correspondência generativa (GMNs – Generative Matching Networks)).


 Para o método de treinamento indireto, não comparamos diretamente as distribuições verdadeiras e geradas. Em vez disso, treinamos a rede generativa, fazendo com que essas duas distribuições passem por um ajuste escolhido de forma que o processo de otimização da rede generativa em relação à tarefa ajustada imponha que a distribuição gerada esteja próxima da verdadeira distribuição. Essa última ideia é a que está por trás das Redes Adversárias Generativas (GANs) que apresentaremos na próxima seção. Mas, por enquanto, vamos começar com o método direto e as GMNs.


**Comparando duas distribuições de probabilidade com base em amostras**


Como mencionado, a ideia das GMNs é treinar a rede generativa comparando diretamente a distribuição gerada com a verdadeira. No entanto, não sabemos como expressar explicitamente a verdadeira “distribuição de probabilidade de cães” e também podemos dizer que a distribuição gerada é complexa demais para ser expressa explicitamente. Portanto, comparações baseadas em expressões explícitas não são possíveis. Logo, se tivermos uma maneira de comparar distribuições de probabilidade com base em amostras, podemos usá-la para treinar a rede. De fato, temos uma amostra de dados verdadeiros e podemos, a cada iteração do processo de treinamento, produzir uma amostra de dados gerados.


Embora, em teoria, qualquer distância (ou medida de similaridade) capaz de comparar efetivamente duas distribuições baseadas em amostras possa ser usada, podemos mencionar, em particular, a abordagem da Discrepância Média Máxima (MMD). O MMD define uma distância entre duas distribuições de probabilidade que podem ser calculadas (estimadas) com base em amostras dessas distribuições. Embora não esteja totalmente fora do escopo deste capítulo, decidimos não gastar muito mais tempo descrevendo o MMD. No entanto, caso você queira mais detalhes sobre isso, recomendamos esses 3 papers abaixo:


[Learning features to compare distributions](http://www.gatsby.ucl.ac.uk/~gretton/papers/testing_workshop.pdf)


[A Kernel Method for the Two-Sample-Problem](http://www.gatsby.ucl.ac.uk/~gretton/papers/GreBorRasSchSmo07.pdf)


[A Kernel Two-Sample Test](http://www.jmlr.org/papers/volume13/gretton12a/gretton12a.pdf)


**Retropropagação do erro de correspondência de distribuição**


Assim, uma vez que definimos uma maneira de comparar duas distribuições com base em amostras, podemos definir o processo de treinamento da rede generativa em GMNs. Dada uma variável aleatória com distribuição de probabilidade uniforme como entrada, queremos que a distribuição de probabilidade da saída gerada seja a “distribuição de probabilidade do cão”. A ideia das GMNs é otimizar a rede repetindo as seguintes etapas:


* Gerar algumas entradas uniformes.
* Fazer essas entradas passarem pela rede e coletar as saídas geradas.
* Comparar a verdadeira “distribuição de probabilidade de cães” e a gerada com base nas amostras disponíveis (por exemplo, calculando a distância MMD entre a amostra de imagens reais de cães e a amostra de imagens geradas).
* Usar retropropagação para fazer uma etapa de descida de gradiente para diminuir a distância (por exemplo, MMD) entre distribuições verdadeiras e geradas.


Conforme descrito acima, ao seguir estas etapas, aplicamos uma descida do gradiente na rede com uma função de perda que é a distância entre as distribuições verdadeiras e as distribuições geradas na iteração atual.


### O método de treinamento “indireto”


A abordagem “direta” apresentada acima compara diretamente a distribuição gerada com a verdadeira ao treinar a rede generativa. A brilhante ideia que governa as GANs consiste em substituir essa comparação direta por uma indireta que assume a forma de uma tarefa ajustada sobre essas duas distribuições. 


O treinamento da rede generativa é então realizado com relação a essa tarefa, de modo que força a distribuição gerada a se aproximar cada vez mais da distribuição verdadeira.


A tarefa ajustada das GANs é uma tarefa de discriminação entre amostras verdadeiras e geradas. Ou poderíamos dizer uma tarefa de “não discriminação”, pois queremos que a discriminação falhe o máximo possível. Portanto, em uma arquitetura GAN, temos um discriminador, que coleta amostras de dados verdadeiros e gerados e tenta classificá-los da melhor maneira possível, e um gerador treinado para enganar o discriminador o máximo possível. Vamos ver em um exemplo simples porque as abordagens diretas e indiretas que mencionamos devem, em teoria, levar ao mesmo gerador ideal.


**O caso ideal: gerador e discriminador perfeitos**


Para entender melhor por que treinar um gerador para enganar um discriminador levará ao mesmo resultado que treinar diretamente o gerador para corresponder à distribuição de destino, vamos dar um exemplo unidimensional simples. Esquecemos, por enquanto, como o gerador e o discriminador são representados e os consideramos como noções abstratas (que serão especificadas na próxima subseção). Além disso, ambos são supostos “perfeitos” (com capacidades infinitas) no sentido de que não são limitados por nenhum tipo de modelo (parametrizado).


Suponha que tenhamos uma distribuição verdadeira, por exemplo, um gaussiano unidimensional e que desejemos um gerador que faça amostras dessa distribuição de probabilidade. O que chamamos de método de treinamento “direto” consistiria em ajustar iterativamente o gerador (iterações de descida de gradiente) para corrigir a diferença / erro medido entre distribuições verdadeiras e geradas. Por fim, supondo que o processo de otimização seja perfeito, devemos terminar com a distribuição gerada que corresponda exatamente à verdadeira distribuição.


 


![norm](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/norm-1024x985.jpeg)


 


Para a abordagem “indireta”, devemos considerar também um discriminador. Presumimos por enquanto que esse discriminador é um tipo de oráculo que sabe exatamente quais são as distribuições verdadeira e gerada e que é capaz, com base nessas informações, de prever uma classe (“verdadeira” ou “gerada”) para qualquer ponto. Se as duas distribuições estiverem distantes, o discriminador será capaz de classificar facilmente e com um alto nível de confiança a maioria dos pontos que apresentamos. Se queremos enganar o discriminador, precisamos aproximar a distribuição gerada da verdadeira. O discriminador terá mais dificuldade em prever a classe quando as duas distribuições serão iguais em todos os pontos: nesse caso, para cada ponto, haverá chances iguais de ser “verdadeiro” ou “gerado” e, em seguida, o discriminador poderá ” fazer melhor do que ser verdadeiro em um caso em dois em média.


 


![norm2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/norm2-1024x957.jpeg)


 


Nesse ponto, parece legítimo se perguntar se esse método indireto é realmente uma boa ideia. De fato, parece ser mais complicado (temos que otimizar o gerador com base em uma tarefa ajustada, em vez de diretamente nas distribuições) e requer um discriminador que consideramos aqui como um determinado oráculo, mas que, na realidade, não é conhecido. Nem perfeito. Para o primeiro ponto, a dificuldade de comparar diretamente duas distribuições de probabilidade com base em amostras contrabalança a aparente maior complexidade do método indireto. Para o segundo ponto, é óbvio que o discriminador não é conhecido. No entanto, pode ser aprendido!


**A aproximação: redes neurais adversárias**


Vamos agora descrever a forma específica que assume o gerador e o discriminador na arquitetura das GANs. O gerador é uma rede neural que modela uma função de transformação. Ele assume como entrada uma variável aleatória simples e deve retornar, uma vez treinada, uma variável aleatória que segue a distribuição de destino. Como é muito complicado e desconhecido, decidimos modelar o discriminador com outra rede neural. Essa rede neural modela uma função discriminativa. Ele toma como entrada um ponto (no nosso exemplo de cachorro, um vetor dimensional N) e retorna como saída a probabilidade desse ponto ser “verdadeiro”.


Observe que o fato de impormos agora um modelo parametrizado para expressar tanto o gerador quanto o discriminador (em vez das versões idealizadas na subseção anterior) não tem, na prática, um grande impacto no argumento / intuição teórica acima: apenas trabalhamos em alguns espaços parametrizados em vez de espaços completos ideais e, portanto, os pontos ideais que devemos alcançar no caso ideal podem ser vistos como “arredondados” pela capacidade de precisão dos modelos parametrizados.


Uma vez definidas, as duas redes podem ser treinadas em conjunto (ao mesmo tempo) com objetivos opostos:


* O objetivo do gerador é enganar o discriminador; portanto, a rede neural generativa é treinada para maximizar o erro de classificação final (entre dados verdadeiros e gerados).
* O objetivo do discriminador é detectar dados falsos gerados, para que a rede neural discriminativa seja treinada para minimizar o erro de classificação final.


Portanto, a cada iteração do processo de treinamento, os pesos da rede generativa são atualizados para aumentar o erro de classificação (subida do gradiente de erro sobre os parâmetros do gerador), enquanto os pesos da rede discriminativa são atualizados para diminuir esse erro (descida do gradiente de erro sobre os parâmetros do discriminador).


Esses objetivos opostos e a noção implícita de treinamento antagônico das duas redes explicam o nome de “redes adversárias”: ambas as redes tentam se derrotar e, ao fazê-lo, estão cada vez melhor. A competição entre elas faz com que essas duas redes “progridam” com relação a seus respectivos objetivos. Do ponto de vista da teoria dos jogos, podemos pensar nessa configuração como um jogo minimax para dois jogadores, em que o estado de equilíbrio corresponde à situação em que o gerador produz dados a partir da distribuição exata e onde o discriminador prediz “verdadeiro” ou “gerado” com probabilidade 1/2 para qualquer ponto que receber.


Os modelos GAN estão entre os mais avançados em Deep Learning e a ideia por trás da sua concepção é simples e brilhante. 


Agora sim, estamos prontos para compreender a Matemática que faz tudo isso acontecer! 


Está gostando do Deep Learning Book? Então ajude a continuarmos esse trabalho e compartilhe o Deep Learning Book entre seus amigos e rede de contatos.


Até o próximo capítulo!


Referências:


[Formação Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[A Beginner’s Guide to Generative Adversarial Networks (GANs)](https://skymind.ai/wiki/generative-adversarial-network-gan)


[A Leap into the Future: Generative Adversarial Networks](https://medium.com/datadriveninvestor/a-leap-into-the-future-generative-adversarial-networks-96a780ed8ee6)


[Understanding Generative Adversarial Networks (GANs)](https://towardsdatascience.com/understanding-generative-adversarial-networks-gans-cd6e4651a29)


[How A.I. Is Creating Building Blocks to Reshape Music and Art](https://www.nytimes.com/2017/08/14/arts/design/google-how-ai-creates-new-music-and-new-artists-project-magenta.html)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-57---os-detalhes-matematicos-das-gans-(generative-adversarial-networks)"></div>

# Capítulo 57 – Os Detalhes Matemáticos das GANs (Generative Adversarial Networks)


Neste capítulo vamos concluir nosso estudo das GANs com os detalhes matemáticos, antes de avançar para outra arquitetura de Deep Learning que estudaremos na sequência. Estamos considerando que você leu os capítulos anteriores sobre GANs.


A modelagem de redes neurais requer essencialmente definir duas coisas: uma arquitetura e uma função de perda. Já descrevemos a [arquitetura de redes adversárias generativas](https://www.deeplearningbook.com.br/modelos-generativos-o-diferencial-das-gans-generative-adversarial-networks/). Consiste em duas redes:


1. Uma rede generativa G que recebe uma entrada aleatória z com densidade p\_z e retorna uma saída x\_g = G (z) que deve seguir (após o treinamento) a distribuição de probabilidade alvo.
2. Uma rede discriminativa D que recebe uma entrada x que pode ser uma entrada “verdadeira” (x\_t, cuja densidade é denotada p\_t) ou uma entrada “gerada” (x\_g, cuja densidade p\_g é a densidade induzida pela densidade p\_z através de G) e que retorna a probabilidade D (x) de x para ser um dado “verdadeiro”.


Vamos agora examinar mais de perto a função de perda “teórica” das GANs. Se enviarmos ao discriminador dados “verdadeiros” e “gerados” nas mesmas proporções, o erro absoluto esperado do discriminador poderá ser expresso como:


 


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/form1-1.png)


 


O objetivo do gerador é enganar o discriminador cujo objetivo é ser capaz de distinguir entre dados verdadeiros e dados gerados. Portanto, ao treinar o gerador, queremos maximizar esse erro enquanto tentamos minimizá-lo para o discriminador. Isso nos dá a fórmula abaixo:


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/form2.jpg)


Para qualquer gerador G (juntamente com a densidade de probabilidade induzida p\_g), o melhor discriminador possível é aquele que minimiza a integral abaixo:


 


![form3](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/form3-1-1024x79.png)


 


Para minimizar (em relação a D) essa integral, podemos minimizar a função dentro da integral para cada valor de x. Em seguida, definimos o melhor discriminador possível para um determinado gerador:


![form4](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/form4.jpg)


(de fato, um dos melhores porque x valores tais que p\_t (x) = p\_g (x) podem ser manipulados de outra maneira, mas isso não importa para o que segue). Em seguida, pesquisamos G que maximiza:


 


![form5](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/form5-1-1024x87.png)


 


Parece complexo? É menos do que parece e explicamos sobre os fundamentos matemáticos por trás dessas fórmulas no curso [Matemática Para Data Science](https://www.datascienceacademy.com.br/course/matematica-para-data-science). Novamente, para maximizar (em relação a G) essa integral, podemos maximizar a função dentro da integral para cada valor de x. Como a densidade p\_t é independente do gerador G, não podemos fazer melhor do que definir G de modo que:


![form7](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/form7.jpg)


Obviamente, como p\_g é uma densidade de probabilidade que deve se integrar a 1, necessariamente temos o melhor G:


 


![form8](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/form8.jpg)


 


Assim, mostramos que, em um caso ideal com gerador e discriminador de capacidade ilimitada, o ponto ideal do cenário adversário é tal que o gerador produz a mesma densidade que a densidade real e o discriminador não pode fazer melhor do que ser verdadeiro em um caso a cada dois, exatamente como a intuição nos disse. Por fim, observe também que G maximiza:


 


![form6](https://www.deeplearningbook.com.br/wp-content/uploads/2019/10/form6-1024x90.png)


 


Na fórmula acima vemos que G deseja maximizar a probabilidade esperada de o discriminador estar errado.


### Conclusão Sobre as GANs


As GANs são bem recentes e possuem uma ideia inovadora sobre como treinar uma arquitetura de rede neural. Muitos estudos e aplicações vem sendo feitos em todo mundo e já existem até algumas aplicações comerciais usando essa arquitetura de Deep Learning. Caso queira aprender a construir GANs na prática, acesse [aqui](https://www.datascienceacademy.com.br/course?courseid=deep-learning-ii).


Pontos mais importantes sobre as GANs:


* Computadores podem basicamente gerar variáveis ​​pseudo-aleatórias simples (por exemplo, eles podem gerar variáveis ​​que seguem muito de perto uma distribuição uniforme).
* Existem maneiras diferentes de gerar variáveis ​​aleatórias mais complexas, incluindo a noção de “método de transformação” que consiste em expressar uma variável aleatória em função de algumas variáveis ​​aleatórias mais simples.
* No aprendizado de máquina, os modelos generativos tentam gerar dados de uma determinada distribuição de probabilidade (complexa). Modelos generativos de aprendizado profundo são modelados como redes neurais (funções muito complexas) que recebem como entrada uma variável aleatória simples e retornam uma variável aleatória que segue a distribuição direcionada (como “método de transformação”).
* Essas redes generativas podem ser treinadas “diretamente” (comparando a distribuição dos dados gerados com a verdadeira distribuição): esta é a ideia das redes correspondentes generativas
* Essas redes generativas também podem ser treinadas “indiretamente” (tentando enganar outra rede treinada ao mesmo tempo para distinguir dados “gerados” de dados “verdadeiros”): essa é a ideia das redes adversas generativas.
* Mesmo que o “hype” que rodeia os GANs seja talvez um pouco exagerado, podemos dizer que a ideia de treinamento antagônico sugerida por Ian Goodfellow e seus co-autores é realmente ótima. Essa maneira de distorcer a função de perda, passando de uma comparação direta para uma indireta, é realmente algo que pode ser muito inspirador para futuros trabalhos na área de aprendizado profundo.


Referências:


[Análise Estatística Para Data Science com Linguagem Python](https://www.datascienceacademy.com.br/course/analise-estatistica-para-data-science-com-linguagem-python)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[A Beginner’s Guide to Generative Adversarial Networks (GANs)](https://skymind.ai/wiki/generative-adversarial-network-gan)


[A Leap into the Future: Generative Adversarial Networks](https://medium.com/datadriveninvestor/a-leap-into-the-future-generative-adversarial-networks-96a780ed8ee6)


[Understanding Generative Adversarial Networks (GANs)](https://towardsdatascience.com/understanding-generative-adversarial-networks-gans-cd6e4651a29)


[How A.I. Is Creating Building Blocks to Reshape Music and Art](https://www.nytimes.com/2017/08/14/arts/design/google-how-ai-creates-new-music-and-new-artists-project-magenta.html)


[Train longer, generalize better: closing the generalization gap in large batch training of neural networks](https://arxiv.org/pdf/1705.08741.pdf)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


<div id="capitulo-58---introducao-aos-autoencoders"></div>

# Capítulo 58 – Introdução aos Autoencoders


Até aqui neste livro descrevemos arquiteturas de redes neurais profundas (Deep Learning) usadas em aprendizagem supervisionada, na qual rotulamos exemplos de treinamento, fornecendo ao algoritmo dados de entrada (X) e de saída (Y). Agora, suponha que tenhamos apenas um conjunto de exemplos de treinamento não rotulados {x1, x2, x3,…}, onde x (i) ∈ℜn. Uma rede neural Autoencoder é um algoritmo de aprendizado não supervisionado que aplica backpropagation, definindo os valores de destino como iguais às entradas. Ou seja, usa y (i) = x (i). Estudaremos essa arquitetura de Deep Learning a partir de agora.


### O que são Autoencoders?


Os Autoencoders são uma técnica de aprendizado não supervisionado, na qual usamos as redes neurais para a tarefa de aprendizado de representação. Especificamente, projetaremos uma arquitetura de rede neural de modo a impor um *gargalo* na rede que força uma representação de conhecimento compactada da entrada original. Se os recursos de entrada fossem independentes um do outro, essa compressão e reconstrução subsequente seriam uma tarefa muito difícil. No entanto, se houver algum tipo de estrutura nos dados (ou seja, correlações entre os recursos de entrada), essa estrutura poderá ser aprendida e consequentemente aproveitada ao forçar a entrada através do *gargalo* da rede.


Autoencoders (AE) são redes neurais que visam copiar suas entradas para suas saídas. Eles trabalham compactando a entrada em uma representação de espaço latente e, em seguida, reconstruindo a saída dessa representação. Esse tipo de rede é composto de duas partes:


**Codificador (Encoder)**: é a parte da rede que compacta a entrada em uma representação de espaço latente (codificando a entrada). Pode ser representado por uma função de codificação h = f (x).


**Decodificador (Decoder)**: Esta parte tem como objetivo reconstruir a entrada da representação do espaço latente. Pode ser representado por uma função de decodificação r = g (h).


 


![mushroom_encoder](https://www.deeplearningbook.com.br/wp-content/uploads/2019/11/mushroom_encoder.png)


 


O Autoencoder tenta aprender uma função h W, b (x) ≈ x. Em outras palavras, ele está tentando aprender uma aproximação com a função de identidade, de modo a gerar x’ semelhante a x. A função de identidade parece uma função particularmente trivial para tentar aprender; mas colocando restrições na rede, como limitando o número de unidades ocultas, podemos descobrir uma estrutura interessante sobre os dados. Como um exemplo concreto, suponha que as entradas x sejam os valores de intensidade de pixel de uma imagem 10 × 10 (100 pixels), portanto n = 100 e haja s = 50 unidades ocultas na camada L2. Observe que também temos y∈ℜ100. Como existem apenas 50 unidades ocultas, a rede é forçada a aprender uma representação “compactada” da entrada. Ou seja, dado apenas o vetor de ativações de unidades ocultas, ele deve tentar ”reconstruir” a entrada de 100 pixels x. Se a entrada fosse completamente aleatória – digamos, cada xi provém de um ID Gaussiano independente dos outros recursos, essa tarefa de compactação seria muito difícil. Mas se houver estrutura nos dados, por exemplo, se alguns dos recursos de entrada estiverem correlacionados, esse algoritmo poderá descobrir algumas dessas correlações. De fato, esse Autoencoder simples geralmente acaba aprendendo uma representação de baixa dimensão muito semelhante aos PCAs ([Principal Component Analysis](https://www.datascienceacademy.com.br/course/matematica-para-data-science)).


Nosso argumento acima se baseava no número de unidades ocultas s sendo pequenas. Mas mesmo quando o número de unidades ocultas é grande (talvez até maior que o número de pixels de entrada), ainda podemos descobrir uma estrutura interessante, impondo outras restrições à rede. Em particular, se impusermos uma restrição de “esparsidade” nas unidades ocultas, o Autoencoder ainda descobrirá uma estrutura interessante nos dados, mesmo que o número de unidades ocultas seja grande.


 


![autoencoders](https://www.deeplearningbook.com.br/wp-content/uploads/2019/11/autoencoders-1024x252.png)


 


### Por que copiar a entrada para a saída?


Se o único objetivo dos Autoencoders fosse copiar a entrada para a saída, eles seriam inúteis. De fato, esperamos que, treinando o Autoencoder para copiar a entrada para a saída, a representação latente h tenha propriedades úteis.


Isso pode ser conseguido criando restrições na tarefa de cópia. Uma maneira de obter recursos úteis do Autoencoder é restringir h a ter dimensões menores que x; nesse caso, o Autoencoder é chamado de incompleto. Ao treinar uma representação incompleta, forçamos o Autoencoder a aprender os recursos mais importantes dos dados de treinamento. Se for dada muita capacidade ao Autoencoder, ele poderá aprender a executar a tarefa de cópia sem extrair nenhuma informação útil sobre a distribuição dos dados. Isso também pode ocorrer se a dimensão da representação latente for a mesma que a entrada e, no caso de excesso de conclusão, em que a dimensão da representação latente for maior que a entrada. 


Nesses casos, mesmo um codificador linear e um decodificador linear podem aprender a copiar a entrada na saída sem aprender nada útil sobre a distribuição de dados. Idealmente, alguém poderia treinar qualquer arquitetura de Autoencoder com sucesso, escolhendo a dimensão do código e a capacidade do codificador e decodificador com base na complexidade da distribuição a ser modelada.


### Para que são usados ​​os Autoencoders?


Atualmente, o denoising de dados (remoção de ruídos) e a redução de dimensionalidade para visualização de dados são considerados duas principais aplicações práticas interessantes de Autoencoders. Com restrições de dimensionalidade e esparsidade apropriadas, os Autoencoders podem aprender projeções de dados mais interessantes que o PCA ou outras técnicas básicas.


Os Autoencoders aprendem automaticamente a partir de exemplos de dados. Isso significa que é fácil treinar instâncias especializadas do algoritmo que terão bom desempenho em um tipo específico de entrada e que não requer nenhuma nova engenharia de recursos, apenas os dados de treinamento apropriados.


Outra aplicação dos Autoencoders é como tarefa preliminar ao reconhecimento de imagens com CNNs (Redes Neurais Convolucionais). Observando a imagem acima você percebe que a saída do Autoencoder é a imagem do número 4 muito mais suave. Ou seja, aplicamos os Autoencoders para remover ruído dos dados (denoising) e depois usamos a saída dos Autoencoders para treinar um modelo CNN.


Os Autoencoders são treinados para preservar o máximo de informações possível quando uma entrada é passada pelo codificador e depois pelo decodificador, mas também são treinados para fazer com que a nova representação tenha várias propriedades agradáveis. Diferentes tipos de Autoencoders visam atingir diferentes tipos de propriedades. 


Referências:


[Deep Learning Para Aplicações de IA com PyTorch e Lightning](https://www.datascienceacademy.com.br/course/deep-learning-para-aplicacoes-de-ia-com-pytorch-e-lightning)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[Autoencoders – Unsupervised Learning](http://ufldl.stanford.edu/tutorial/unsupervised/Autoencoders/)


[Deep inside: Autoencoders](https://towardsdatascience.com/deep-inside-autoencoders-7e41f319999f)


[Introduction to Autoencoders](https://www.jeremyjordan.me/autoencoders/)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-59---principais-tipos-de-redes-neurais-artificiais-autoencoders"></div>

# Capítulo 59 – Principais Tipos de Redes Neurais Artificiais Autoencoders


Neste capítulo vamos estudar os tipos principais de Autoencoders (estamos considerando que você leu o capítulo [anterior](https://www.deeplearningbook.com.br/introducao-aos-autoencoders/)):


Os Autoencoders codificam os valores de entrada x usando uma função f. Em seguida, decodificam os valores codificados f (x) usando uma função g para criar valores de saída idênticos aos valores de entrada. O objetivo do Autoencoder é minimizar o erro de reconstrução entre a entrada e a saída. Isso ajuda os Autoencoders a aprender os recursos importantes presentes nos dados. Quando uma representação permite uma boa reconstrução de sua entrada, ela retém grande parte das informações presentes na entrada.


E existem diferentes tipos de Autoencoders. Confira:


### 1. Autoencoder Padrão


Na sua forma mais simples, o Autoencoder é uma rede neural artificial de três camadas, isto é, uma rede neural com uma camada de entrada, uma oculta e uma camada de saída. A entrada e a saída são as mesmas e aprendemos a reconstruir a entrada, por exemplo, usando o otimizador adam e a função de perda de erro quadrático médio.


### 2. Autoencoder Multicamada


Se uma camada oculta não for suficiente, obviamente podemos estender o Autoencoder para mais camadas ocultas. Nossa implementação poderia usar 3 camadas ocultas em vez de apenas uma. Qualquer uma das camadas ocultas pode ser escolhida como representação de recurso, mas o ideal é tornar a rede simétrica e usar a camada mais intermediária.


### 3. Autoencoder Convolucional


Também podemos nos perguntar: os Autoencoders podem ser usados com convoluções em vez de camadas totalmente conectadas?


A resposta é sim e o princípio é o mesmo, mas usando imagens (vetores 3D) em vez de vetores 1D *achatados (flattened)*. A imagem de entrada é reduzida para fornecer uma representação latente de dimensões menores e forçar o Autoencoder a aprender uma versão compactada das imagens.


### 4. Autoencoder Regularizado


Existem outras maneiras pelas quais podemos restringir a reconstrução de um Autoencoder, além de impor uma camada oculta de menor dimensão que a entrada. Em vez de limitar a capacidade do modelo mantendo o codificador e o decodificador rasos e o tamanho do código pequeno, os Autoencoders regularizados usam uma função de perda que incentiva o modelo a ter outras propriedades além da capacidade de copiar sua entrada para sua saída. Na prática, geralmente encontramos dois tipos de Autoencoder Regularizado: o Autoencoder Esparso e o Autoencoder Denoising.


#### 4.1. Autoencoder Esparso


Os Autoencoders Esparsos geralmente são usados ​​para aprender recursos para outra tarefa, como classificação. Um Autoencoder que foi regularizado para ser esparso deve responder a recursos estatísticos exclusivos do conjunto de dados em que foi treinado, em vez de simplesmente atuar como uma função de identidade. Dessa forma, o treinamento para executar a tarefa de cópia com uma penalidade de escassez pode produzir um modelo que aprendeu recursos úteis como subproduto.


Outra maneira de restringir a reconstrução do Autoencoder é impor uma restrição à sua perda. Poderíamos, por exemplo, adicionar um termo de reguralização na função de perda. Isso fará com que nosso Autoencoder aprenda representação esparsa de dados. Em nossa camada oculta, podemos adicionar um regularizador de atividades L1, que aplicará uma penalidade na função de perda durante a fase de otimização. Como resultado, a representação será mais esparsa em comparação com o Autoencoder Padrão. Abaixo uma representação do Autoencoder Esparso:


#### 


#### 


![esparso](https://www.deeplearningbook.com.br/wp-content/uploads/2019/11/esparso.png)


#### 


#### 4.2. Autoencoder Denoising


Em vez de adicionar uma penalidade à função de perda, podemos obter um Autoencoder que aprende algo útil alterando o termo do erro de reconstrução da função de perda. Isso pode ser feito adicionando algum ruído à imagem de entrada e fazendo o Autoencoder aprender a removê-la. Dessa maneira, o Autoencoder extrairá os recursos mais importantes e aprenderá uma representação robusta dos dados. 


Denoising refere-se à adição intencional de ruído à entrada bruta antes de fornecê-la à rede. Pode-se obter denoising usando o mapeamento estocástico. Abaixo uma representação do Autoencoder Denoising:


#### 


#### 


![denoising](https://www.deeplearningbook.com.br/wp-content/uploads/2019/11/denoising.png)


### 


### 5. Contractive Autoencoders(CAE)


O objetivo do Autoencoder Contrativo (CAE) é ter uma representação aprendida robusta, menos sensível a pequenas variações nos dados. A robustez da representação para os dados é feita aplicando um termo de penalidade à função de perda. O termo da penalidade é a norma Frobenius da matriz jacobiana. A norma de Frobenius da matriz jacobiana para a camada oculta é calculada em relação à entrada. A norma de Frobenius da matriz jacobiana é a soma do quadrado de todos os elementos.


O Autoencoder Contrativo é outra técnica de regularização, como os Autoencoders Esparsos e os Autoencoders Denoising.


O CAE supera os resultados obtidos pela regularização do Autoencoder usando decaimento de peso ou denoising. O CAE é uma escolha melhor do que o Autoencoder Denoising para aprender a extração de recursos úteis. O termo de penalidade gera mapeamento que contrai fortemente os dados e, portanto, o nome Autoencoder Contrativo.


### 6. Deep Autoencoders


Deep Autoencoders consistem em duas redes de crenças profundas idênticas (Deep Belief Networks). Uma rede para codificação e outra para decodificação. Os Autoencoders tipicamente profundos têm de 4 a 5 camadas para codificação e as próximas 4 a 5 camadas para decodificação. Usamos camada não supervisionada por camada, pré-treinamento.


A Máquina Boltzmann Restrita (RBM) é o alicerce básico das Deep Belief Networks. Na figura abaixo, tiramos uma imagem com 784 pixels. Treinamos usando uma pilha de 4 RBMs, desenrolamos e ajustamos com Backpropagation. A camada de codificação final é compacta e rápida!


#### 


#### 


![deep](https://www.deeplearningbook.com.br/wp-content/uploads/2019/11/deep.png)


#### 


#### 


### 7. Variational Autoencoders (VAEs)


Nos últimos anos, modelos generativos baseados em aprendizado profundo ganharam cada vez mais interesse devido a (e implicando) algumas melhorias surpreendentes no campo. Contando com uma enorme quantidade de dados, arquiteturas de rede bem projetadas e técnicas de treinamento inteligentes, os modelos geradores profundos demonstraram uma capacidade incrível de produzir peças de conteúdo altamente realistas de vários tipos, como imagens, textos e sons. Entre esses modelos geradores profundos, duas famílias principais se destacam e merecem uma atenção especial: Redes Adversárias Generativas (GANs) e Autoencoders Variacionais (VAEs). As GANs já estudamos nos capítulos anteriores.


E a VAE é tão especial que merece um capítulo inteiro. Não perca o próximo capítulo.


Referências:


[Formação Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[Autoencoders – Unsupervised Learning](http://ufldl.stanford.edu/tutorial/unsupervised/Autoencoders/)


[Deep inside: Autoencoders](https://towardsdatascience.com/deep-inside-autoencoders-7e41f319999f)


[Deep Learning — Different Types of Autoencoders](https://medium.com/datadriveninvestor/deep-learning-different-types-of-autoencoders-41d4fa5f7570)


[Contractive Auto-Encoders – Explicit Invariance During Feature Extraction](http://www.icml-2011.org/papers/455_icmlpaper.pdf)


[Stacked Denoising Autoencoders: Learning Useful Representations in a Deep Network with a Local Denoising Criterion](http://www.jmlr.org/papers/volume11/vincent10a/vincent10a.pdf)


[Introduction to Autoencoders](https://www.jeremyjordan.me/autoencoders/)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-60---variational-autoencoders-(vaes)---definicao,-reducao-de-dimensionalidade,-espaco-latente-e-regularizacao"></div>

# Capítulo 60 – Variational Autoencoders (VAEs) – Definição, Redução de Dimensionalidade, Espaço Latente e Regularização


Nos últimos anos, modelos generativos baseados em aprendizado profundo ganharam cada vez mais interesse devido a (e implicando) algumas melhorias surpreendentes em Inteligência Artificial. Contando com uma enorme quantidade de dados, arquiteturas de rede bem projetadas e técnicas de treinamento inteligentes, os modelos generativos profundos demonstraram uma capacidade incrível de produzir peças de conteúdo altamente realistas de vários tipos, como imagens, textos e sons. Entre esses modelos, duas famílias principais se destacam e merecem uma atenção especial: Redes Adversárias Generativas (GANs) e Autoencoders Variacionais (VAEs). O primeiro já estudamos e agora estudaremos o segundo.


Em um [capítulo anterior](https://www.deeplearningbook.com.br/introducao-as-redes-adversarias-generativas-gans-generative-adversarial-networks/), discutimos em profundidade as Redes Adversárias Generativas (GANs) e mostramos, em particular, como o treinamento antagônico pode opor duas redes, um gerador e um discriminador, para pressionar ambas a melhorar iteração após iteração. Apresentamos agora, neste capítulo, outro tipo de modelo generativo profundo: Autoencoders Variacionais (VAEs – Variational Autoencoders). 


Em resumo, um VAE é um Autoencoder cuja distribuição de codificações é regularizada durante o treinamento, a fim de garantir que seu espaço latente tenha boas propriedades, o que nos permite gerar novos dados. Além disso, o termo “variacional” vem da estreita relação que existe entre a regularização e o método de inferência variacional em Estatística. 


Mas o conceito por trás dos VAEs também pode levantar muitas questões. Qual é o espaço latente e por que regularizá-lo? Como gerar novos dados a partir dos VAEs? Qual é a ligação entre VAEs e inferência variacional? Para descrever os VAEs da melhor maneira possível, tentaremos responder a todas essas perguntas (e muitas outras!) e fornecer a você o máximo de informação e conhecimento possível (variando de intuições básicas a detalhes matemáticos mais avançados). Assim, o objetivo deste capítulo não é apenas discutir as noções fundamentais dos Variational Autoencoders (VAEs), mas também construir passo a passo e começar desde o início o raciocínio que leva a essas noções (como sempre fazemos em nossos cursos na [Data Science Academy](https://www.datascienceacademy.com.br/todoscursosdsa)). E vamos começar com o conceito de redução de dimensionalidade.


O Que é Redução de Dimensionalidade?
------------------------------------


No aprendizado de máquina, a redução de dimensionalidade é o processo de redução do número de recursos (atributos) que descrevem alguns dados. Essa redução é feita por seleção (apenas alguns recursos existentes são conservados) ou por extração (um número reduzido de novos recursos é criado com base nos recursos antigos) e pode ser útil em muitas situações que exigem dados de baixa dimensionalidade (visualização de dados, armazenamento, computação pesada, etc…). Embora existam muitos métodos diferentes de redução de dimensionalidade, podemos definir uma estrutura global que seja compatível com a maioria desses métodos.


Primeiro, vamos codificar o processo que produz a representação de “novos recursos” a partir da representação de “recursos antigos” (por seleção ou por extração) e decodificar o processo inverso. A redução de dimensionalidade pode então ser interpretada como compactação de dados, onde o codificador compacta os dados (do espaço inicial para o espaço codificado, também chamado de espaço latente) enquanto o decodificador os descompacta. Obviamente, dependendo da distribuição inicial dos dados, da dimensão do espaço latente e da definição do codificador, essa compactação pode ser perdida, o que significa que uma parte da informação é perdida durante o processo de codificação e não pode ser recuperada durante a decodificação.


![reduc](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/reduc-1024x560.jpg)


O principal objetivo de um método de redução de dimensionalidade é encontrar o melhor par codificador / decodificador entre uma determinada família. Em outras palavras, para um determinado conjunto de codificadores e decodificadores possíveis, estamos procurando o par que mantém o máximo de informações ao codificar e, portanto, tem o mínimo de erro de reconstrução ao decodificar. Se denotarmos respectivamente E e D as famílias de codificadores e decodificadores que estamos considerando, o problema da redução de dimensionalidade pode ser escrito:


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form1-300x80.jpg)


Onde:


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form2.jpg)


define a medida do erro de reconstrução entre os dados de entrada x e os dados codificados e decodificados d (e (x)). 


Análise de Componentes Principais (PCA) e Autoencoders
------------------------------------------------------


Um dos primeiros métodos que vêm à mente quando se fala em redução de dimensionalidade é a análise de componentes principais (PCA). Para mostrar como ele se encaixa na estrutura que acabamos de descrever e criar o link para os Autoencoders, vamos dar uma visão geral de como o PCA funciona, deixando a maioria dos detalhes de lado (caso queira estudar o PCA em detalhes e na prática, há um capítulo inteiro dedicado a esta técnica em [Matemática Para Data Science](https://www.datascienceacademy.com.br/course/matematica-para-data-science)) .


A ideia do PCA é construir novos recursos independentes, que são combinações lineares dos novos recursos antigos e, de modo que as projeções dos dados no subespaço definido por esses novos recursos sejam o mais próximo possível dos dados iniciais (em termos de distância euclidiana). Em outras palavras, o PCA está procurando o melhor subespaço linear do espaço inicial (descrito por uma base ortogonal de novos recursos), de modo que o erro de aproximar os dados por suas projeções nesse subespaço seja o menor possível.


Traduzido em nossa estrutura global, procuramos um codificador na família E das matrizes n\_e por n\_d (transformação linear) cujas linhas são ortonormais (independência de recursos) e pelo decodificador associado entre a família D de matrizes n\_d por n\_e. Pode-se mostrar que os autovetores unitários correspondentes aos n\_e maiores autovalores (em norma) da matriz de características de covariância são ortogonais (ou podem ser escolhidos assim) e definem o melhor subespaço da dimensão n\_e para projetar dados com erro mínimo de aproximação. Assim, esses n\_e autovetores podem ser escolhidos como nossos novos recursos e, portanto, o problema de redução de dimensão pode ser expresso como um problema de autovalor / autovetor. Além disso, também pode ser mostrado que, nesse caso, a matriz decodificadora é a transposta da matriz codificadora (se esses conceitos de Matemática parecem estranhos a você recomendamos [Matemática Para Data Science](https://www.datascienceacademy.com.br/course/matematica-para-data-science)).


Os Autoencoders são em essência, redes neurais para redução de dimensionalidade. A ideia geral dos Autoencoders é bastante simples e consiste em definir um codificador e um decodificador como redes neurais e aprender o melhor esquema de codificação-decodificação usando um processo de otimização iterativo. Assim, a cada iteração, alimentamos a arquitetura do autoencoder (o codificador seguido pelo decodificador) com alguns dados, comparamos a saída decodificada com os dados iniciais e retropropagamos o erro na arquitetura para atualizar os pesos das redes.


Assim, intuitivamente, a arquitetura geral do autoencoder (codificador + decodificador) cria um gargalo de dados que garante que apenas a parte estruturada principal da informação possa passar e ser reconstruída. Observando nossa estrutura geral, a família E dos codificadores considerados é definida pela arquitetura da rede do codificador, a família D dos decodificadores considerados é definida pela arquitetura da rede do decodificador e a busca do codificador e decodificador que minimiza o erro de reconstrução é feita por descida do gradiente sobre os parâmetros dessas redes.


![autoencoder](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/autoencoder-1024x560.png)


Vamos primeiro supor que nossas arquiteturas de codificador e decodificador tenham apenas uma camada sem não linearidade (autoencoder linear). Esse codificador e decodificador são transformações lineares simples que podem ser expressas como matrizes. Em tal situação, podemos ver um vínculo claro com o PCA no sentido de que, assim como o PCA, estamos procurando o melhor subespaço linear para projetar dados com o mínimo de perda de informações possível ao fazê-lo. As matrizes de codificação e decodificação obtidas com o PCA definem naturalmente uma das soluções que gostaríamos de alcançar por descida do gradiente, mas devemos destacar que essa não é a única. De fato, várias bases podem ser escolhidas para descrever o mesmo subespaço ideal e, portanto, vários pares de codificador / decodificador podem fornecer o erro de reconstrução ideal. Além disso, para autoencoders lineares e, ao contrário do PCA, os novos recursos não precisam ser independentes (sem restrições de ortogonalidade nas redes neurais).


Agora, vamos supor que o codificador e o decodificador sejam profundos e não lineares. Nesse caso, quanto mais complexa a arquitetura, mais o autoencoder pode prosseguir para uma alta redução de dimensionalidade, mantendo baixa a perda de reconstrução. Intuitivamente, se nosso codificador e nosso decodificador tiver graus de liberdade suficientes, podemos reduzir qualquer dimensionalidade inicial para 1. De fato, um codificador com “poder infinito” poderia teoricamente pegar nossos N pontos de dados iniciais e codificá-los como 1, 2, 3, … até N (ou mais geralmente, como N inteiro no eixo real) e o decodificador associado pode fazer a transformação reversa, sem perda durante o processo.


Aqui, porém, devemos ter duas coisas em mente. Primeiro, uma importante redução de dimensionalidade sem perda de reconstrução costuma ter um preço: a falta de estruturas interpretáveis ​​e exploráveis ​​no espaço latente (falta de regularidade). Segundo, na maioria das vezes, o objetivo final da redução da dimensionalidade não é apenas reduzir o número de dimensões dos dados, mas reduzir esse número de dimensões, mantendo a maior parte das informações da estrutura de dados nas representações reduzidas. Por essas duas razões, a dimensão do espaço latente e a “profundidade” dos autoencoders (que definem o grau e a qualidade da compressão) devem ser cuidadosamente controladas e ajustadas, dependendo do objetivo final da redução da dimensionalidade.


Variational Autoencoders (VAEs)
-------------------------------


No [capítulo 58](https://www.deeplearningbook.com.br/introducao-aos-autoencoders/) introduzimos o conceito de Autoencoders, que são arquiteturas de codificador-decodificador que podem ser treinadas por descida do gradiente. Vamos agora fazer o link com o problema de geração de conteúdo, ver as limitações dos Autoencoders em sua forma atual para esse problema e introduzir os Autoencoders Variacionais.


#### Limitações de Autoencoders para Geração de Conteúdo


Nesse ponto, uma pergunta natural que vem à mente é “qual é o link entre os Autoencoders e a geração de conteúdo?”. De fato, uma vez que o Autoencoder foi treinado, temos um codificador e um decodificador, mas ainda não há uma maneira real de produzir qualquer novo conteúdo. À primeira vista, poderíamos ficar tentados a pensar que, se o espaço latente for regular o suficiente (bem “organizado” pelo codificador durante o processo de treinamento), poderíamos pegar um ponto aleatoriamente nesse espaço latente e decodificá-lo para obter um novo conteúdo. O decodificador agiria mais ou menos como o gerador de uma Rede Adversária Generativa .


![vae](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/vae-1024x533.png)


No entanto, a regularidade do espaço latente para Autoencoders é um ponto difícil que depende da distribuição dos dados no espaço inicial, da dimensão do espaço latente e da arquitetura do codificador. Portanto, é bastante difícil (se não impossível) garantir, a priori, que o codificador organize o espaço latente de maneira inteligente, compatível com o processo generativo que acabamos de descrever.


Para ilustrar esse ponto, vamos considerar o exemplo no qual descrevemos um codificador e um decodificador suficientemente poderosos para colocar N dados de treinamento inicial no eixo real (cada ponto de dados sendo codificado como um valor real) e decodificá-los sem nenhum perda de reconstrução. Nesse caso, o alto grau de liberdade do Autoencoder que possibilita a codificação e decodificação sem perda de informações (apesar da baixa dimensionalidade do espaço latente) leva a uma super adaptação severa, o que implica que alguns pontos do espaço latente fornecerão conteúdo sem sentido uma vez decodificado. Se esse exemplo unidimensional tiver sido voluntariamente escolhido para ser extremo, podemos notar que o problema da regularidade espacial latente dos Autoencoders é muito mais geral do que isso e merece uma atenção especial.


![vae2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/vae2-1024x341.png)


Ao pensar nisso por um minuto, essa falta de estrutura entre os dados codificados no espaço latente é bastante normal. De fato, o Autoencoder é treinado apenas para codificar e decodificar com o mínimo de perdas possível, independentemente da organização do espaço latente. Portanto, se não tomarmos cuidado com a definição da arquitetura, é natural que, durante o treinamento, a rede aproveite todas as possibilidades de sobreajuste para realizar sua tarefa da melhor forma possível … a menos que a regularizemos explicitamente!


Definição de Autoencoders Variacionais
--------------------------------------


Portanto, para poder usar o decodificador de nosso autoencoder para fins generativos, precisamos ter certeza de que o espaço latente é regular o suficiente. Uma solução possível para obter essa regularidade é introduzir regularização explícita durante o processo de treinamento. Assim, como mencionamos brevemente na introdução deste capítulo, um autoencoder variacional pode ser definido como um autoencoder cujo treinamento é regularizado para evitar sobreajuste e garantir que o espaço latente tenha boas propriedades que possibilitem processos generativos.


Assim como um autoencoder padrão, um autoencoder variacional é uma arquitetura composta por um codificador e um decodificador, treinada para minimizar o erro de reconstrução entre os dados decodificados e os dados iniciais. No entanto, para introduzir alguma regularização do espaço latente, procedemos a uma ligeira modificação do processo de codificação / decodificação: em vez de codificar uma entrada como um único ponto, a codificamos como uma distribuição no espaço latente. O modelo é treinado da seguinte maneira:


* Primeiro, a entrada é codificada como distribuição no espaço latente.
* Segundo, um ponto do espaço latente é amostrado a partir dessa distribuição.
* Terceiro, o ponto amostrado é decodificado e o erro de reconstrução pode ser calculado.
* Finalmente, o erro de reconstrução é retropropagado pela rede.


![vae3](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/vae3.png)


Na prática, as distribuições codificadas são escolhidas para serem normais, de modo que o codificador possa ser treinado para retornar a média e a matriz de covariância que descrevem esses gaussianos. A razão pela qual uma entrada é codificada como uma distribuição com alguma variância em vez de um único ponto é que torna possível expressar muito naturalmente a regularização do espaço latente: as distribuições retornadas pelo codificador são impostas para estarem próximas a uma distribuição normal padrão. Veremos na próxima subseção que garantimos dessa maneira uma regularização local e global do espaço latente (local por causa do controle de variância e global por causa do controle médio).


Assim, a função de perda que é minimizada ao treinar um VAE é composta de um “termo de reconstrução” (na camada final), que tende a tornar o esquema de codificação-decodificação o mais eficiente possível e um “termo de regularização” (no camada latente), que tende a regularizar a organização do espaço latente, tornando as distribuições retornadas pelo codificador próximas a uma distribuição normal padrão. Esse termo de regularização é expresso como a divergência de Kulback-Leibler entre a distribuição retornada e uma gaussiana padrão e será mais justificado na próxima seção. Podemos notar que a divergência de Kullback-Leibler entre duas distribuições gaussianas tem uma forma fechada que pode ser expressa diretamente em termos das médias e das matrizes de covariância das duas distribuições.


![vae4](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/vae4.png)


Intuições Sobre a Regularização
-------------------------------


A regularidade que se espera do espaço latente para possibilitar o processo generativo pode ser expressa por meio de duas propriedades principais: continuidade (dois pontos de fechamento no espaço latente não devem fornecer dois conteúdos completamente diferentes uma vez decodificados) e integridade (para uma distribuição escolhida , um ponto amostrado no espaço latente deve fornecer conteúdo “significativo” depois de decodificado).


O único fato de que os VAEs codificam entradas como distribuições, em vez de pontos simples, não é suficiente para garantir continuidade e integridade. Sem um termo de regularização bem definido, o modelo pode aprender, a fim de minimizar seu erro de reconstrução, “ignorar” o fato de que as distribuições são retornadas e se comportam quase como os autoencoders clássicos (levando ao super ajuste). Para fazer isso, o codificador pode retornar distribuições com pequenas variações (que tendem a ser distribuições pontuais) ou retornar distribuições com meios muito diferentes (que ficariam muito distantes um do outro no espaço latente). Nos dois casos, as distribuições são usadas da maneira errada (cancelando o benefício esperado) e a continuidade e / ou a integridade não são satisfeitas.


Portanto, para evitar esses efeitos, precisamos regularizar a matriz de covariância e a média das distribuições retornadas pelo codificador. Na prática, essa regularização é feita impondo distribuições para estar perto de uma distribuição normal padrão (centralizada e reduzida). Dessa forma, exigimos que as matrizes de covariância estejam próximas da identidade, impedindo distribuições pontuais e com a média próxima de 0, impedindo que as distribuições codificadas estejam muito distantes umas das outras.


Com esse termo de regularização, impedimos que o modelo codifique dados distantes no espaço latente e incentivamos o máximo possível as distribuições retornadas a “se sobrepor”, satisfazendo dessa maneira as condições de continuidade e integridade esperadas. Naturalmente, como em qualquer termo de regularização, isso tem o preço de um erro de reconstrução mais alto nos dados de treinamento. A troca entre o erro de reconstrução e a divergência de KL pode, no entanto, ser ajustada e veremos no próximo capítulo como a expressão emerge naturalmente de nossa derivação formal.


Para concluir, podemos observar que a continuidade e a integridade obtidas com a regularização tendem a criar um “gradiente” sobre as informações codificadas no espaço latente. Por exemplo, um ponto do espaço latente que estaria a meio caminho entre as médias de duas distribuições codificadas provenientes de diferentes dados de treinamento deve ser decodificado em algo que esteja em algum lugar entre os dados que deram a primeira distribuição e os dados que deram a segunda distribuição como pode ser amostrado pelo autoencoder em ambos os casos.


Essa é uma das arquiteturas mais avançadas de Deep Learning e para uma melhor compreensão, precisamos da nossa amiga, a Matemática. No próximo capítulo traremos um pouco da Matemática por trás dos VAEs. Até lá.


Referências:


[Formação Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Formação Análise Estatística](https://www.datascienceacademy.com.br/bundle/formacao-analise-estatistica)


[Formação Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[Autoencoders – Unsupervised Learning](http://ufldl.stanford.edu/tutorial/unsupervised/Autoencoders/)


[Understanding Variational Autoencoders (VAEs)](https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73)


[Deep inside: Autoencoders](https://towardsdatascience.com/deep-inside-autoencoders-7e41f319999f)


[Deep Learning — Different Types of Autoencoders](https://medium.com/datadriveninvestor/deep-learning-different-types-of-autoencoders-41d4fa5f7570)


[Contractive Auto-Encoders – Explicit Invariance During Feature Extraction](http://www.icml-2011.org/papers/455_icmlpaper.pdf)


[Stacked Denoising Autoencoders: Learning Useful Representations in a Deep Network with a Local Denoising Criterion](http://www.jmlr.org/papers/volume11/vincent10a/vincent10a.pdf)


[Introduction to Autoencoders](https://www.jeremyjordan.me/autoencoders/)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-61---a-matematica-dos-variational-autoencoders-(vaes)"></div>

# Capítulo 61 – A Matemática dos Variational Autoencoders (VAEs)


No capítulo [anterior](https://www.deeplearningbook.com.br/variational-autoencoders-vaes-definicao-reducao-de-dimensionalidade-espaco-latente-e-regularizacao/), fornecemos a seguinte visão geral intuitiva: Os VAEs são Autoencoders que codificam entradas como distribuições em vez de pontos e cuja “organização” do espaço latente é regularizada restringindo as distribuições retornadas pelo codificador a estarem próximas de um gaussiano padrão. Neste capítulo, forneceremos uma visão matemática dos VAEs que nos permitirá justificar o termo de regularização com mais rigor. Para isso, definiremos uma estrutura probabilística clara e usaremos, em particular, a técnica de inferência variacional. 


A base matemática e estatística por trás dos conceitos deste capítulo pode ser obtida na [Formação Análise Estatística](https://www.datascienceacademy.com.br/bundle/formacao-analise-estatistica). 


### Estrutura Probabilística e Premissas


Vamos começar definindo um modelo gráfico probabilístico para descrever nossos dados. Denotamos por x a variável que representa nossos dados e assumimos que x é gerado a partir de uma variável latente z (a representação codificada) que não é diretamente observada. Assim, para cada ponto de dados, é assumido o seguinte processo generativo de duas etapas:


* Primeiro, uma representação latente z é amostrada da distribuição anterior p(z).
* Segundo, os dados x são amostrados da distribuição de probabilidade condicional definido por p(x | z).


Com esse modelo probabilístico em mente, podemos redefinir nossas noções de codificador e decodificador. De fato, ao contrário de um Autoencoder simples que considera codificador e decodificador determinístico, consideraremos agora versões probabilísticas desses dois objetos. O “decodificador probabilístico” é definido naturalmente por p(x | z), que descreve a distribuição da variável decodificada dada a codificada, enquanto o “codificador probabilístico” é definido por p(z | x), que descreve a distribuição de a variável codificada, dada a decodificada.


Neste ponto, já podemos notar que a regularização do espaço latente que nos faltava em Autoencoders simples aparece naturalmente aqui na definição do processo de geração de dados: presume-se que representações codificadas z no espaço latente sigam a distribuição anterior p(z). Caso contrário, também podemos lembrar o conhecido teorema de Bayes, que faz a ligação entre o anterior p(z), a probabilidade p(x | z) e o posterior p(z | x):


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form1-1.jpg)


Vamos agora assumir que p(z) é uma distribuição gaussiana padrão e que p(x | z) é uma distribuição gaussiana cuja média é definida por uma função determinística f da variável de z e cuja matriz de covariância tem a forma de uma constante positiva c que multiplica a matriz de identidade I. Supõe-se que a função f pertence a uma família de funções denotadas F que é deixada não especificada no momento e que será escolhida posteriormente. Assim, temos:


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form2-1.jpg)


Vamos considerar, por enquanto, que f está bem definido e fixo. Em teoria, como conhecemos p(z) e p(x | z), podemos usar o Teorema de Bayes para calcular p(z | x): este é um problema clássico de inferência bayesiana. No entanto, esse tipo de computação geralmente é intratável (por causa da integral no denominador) e requer o uso de técnicas de aproximação, como inferência variacional.


Nota: Aqui podemos mencionar que p(z) e p(x | z) são ambas distribuições gaussianas, implicando que p(z | x) também deve seguir uma distribuição gaussiana. Em teoria, poderíamos “apenas” tentar expressar a média e a matriz de covariância de p(z | x) com relação às médias e às matrizes de covariância de p(z) e p(x | z). No entanto, na prática, esses valores dependem da função f que pode ser complexa e que não está definida por enquanto (mesmo que tenhamos assumido o contrário). Além disso, o uso de uma técnica de aproximação como inferência variacional torna a abordagem bastante geral e mais robusta a algumas mudanças na hipótese do modelo.


### Formulação de Inferência Variacional


Em Estatística, a inferência variacional é uma técnica para aproximar distribuições complexas. A ideia é definir uma família de distribuição parametrizada (por exemplo, a família de Gaussianos, cujos parâmetros são a média e a covariância) e procurar a melhor aproximação de nossa distribuição de destino entre essa família. O melhor elemento da família é aquele que minimiza uma determinada medição de erro de aproximação (na maioria das vezes a divergência de Kullback-Leibler entre aproximação e alvo) e é encontrada por descida do gradiente sobre os parâmetros que descrevem a família. Para mais detalhes, você encontra um artigo sobe isso na seção de referências ao final do capítulo.


Aqui vamos aproximar p(z | x) por uma distribuição gaussiana q\_x(z) cuja média e covariância são definidas por duas funções, g e h, do parâmetro x. Essas duas funções devem pertencer, respectivamente, às famílias de funções G e H que serão especificadas mais tarde, mas que devem ser parametrizadas. Assim, podemos denotar:


![form3](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form3.jpg)


Portanto, definimos dessa maneira uma família de candidatos à inferência variacional e precisamos agora encontrar a melhor aproximação entre essa família otimizando as funções g e h (de fato, seus parâmetros) para minimizar a divergência de Kullback-Leibler entre a aproximação e o alvo p(z | x). Em outras palavras, estamos procurando a aproximação ideal g\* e h\* de modo que:


 


![form4](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form4-1024x319.png)


 


Na penúltima equação, podemos observar a troca existente – ao aproximar-se do p(z | x) posterior – entre maximizar a probabilidade das “observações” (maximização da probabilidade logarítmica esperada para o primeiro termo) e permanecer próximo à distribuição anterior (minimização da divergência de KL entre q\_x(z) e p(z), para o segundo termo). Essa troca é natural para o problema de inferência bayesiana e expressa o equilíbrio que precisa ser encontrado entre a confiança que temos nos dados e a confiança que temos no passado.


Até agora, assumimos a função f conhecida e fixa e mostramos que, com tais premissas, podemos aproximar o p(z | x) posterior usando a técnica de inferência variacional. No entanto, na prática, essa função f, que define o decodificador, não é conhecida e também precisa ser escolhida. Para fazer isso, lembre-se de que nosso objetivo inicial é encontrar um esquema de codificação e decodificação com desempenho, cujo espaço latente seja regular o suficiente para ser usado para fins generativos. Se a regularidade é regida principalmente pela distribuição anterior assumida no espaço latente, o desempenho do esquema geral de codificação / decodificação depende muito da escolha da função f. 


De fato, como p(z | x) pode ser aproximado (por inferência variacional) de p(z) e p(x | z) e como p(z) é um gaussiano padrão simples, as duas únicas alavancas que temos à nossa disposição em nosso modelo para fazer otimizações são o parâmetro c (que define a variância da probabilidade) e a função f (que define a média da probabilidade).


Portanto, vamos considerar que, como discutimos anteriormente, podemos obter para qualquer função f em F (cada uma definindo um decodificador probabilístico diferente p(x | z)) a melhor aproximação de p(z | x), denotada q\*\_x(z) Apesar de sua natureza probabilística, estamos procurando um esquema de codificação-decodificação o mais eficiente possível e, em seguida, queremos escolher a função f que maximize a probabilidade logarítmica esperada de x dado z quando z é amostrado de q\*\_x(z) Em outras palavras, para uma dada entrada x, queremos maximizar a probabilidade de ter x̂ = x quando amostramos z da distribuição q\*\_x(z) e depois amostramos x̂ da distribuição p(x | z). Assim, procuramos o f\* ideal para que:


![form5](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form5.jpg)


onde q\*\_x (z) depende da função f e é obtido como descrito anteriormente. Reunindo todas as peças, estamos procurando as aproximações f\*,  g\* e h\* ideais para que:


 


![form6](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form6-1024x83.png)


 


Podemos identificar nesta função objetivo os elementos introduzidos na descrição intuitiva dos VAEs dados no capítulo anterior: o erro de reconstrução entre x e f(z) e o termo de regularização dado pela divergência KL entre q\_x(z) e p(z) ) (que é um gaussiano padrão). Também podemos notar a constante c que regula o equilíbrio entre os dois termos anteriores. Quanto maior c for, mais assumimos uma alta variação em torno de f(z) para o decodificador probabilístico em nosso modelo e, portanto, mais favorecemos o termo de regularização sobre o termo de reconstrução (e o oposto se c for baixo).


### Trazendo Redes Neurais Para o Modelo


Até o momento, definimos um modelo probabilístico que depende de três funções, f, g e h, e expressamos, usando inferência variacional, o problema de otimização a ser resolvido para obter f\*, g\* e h\* que ofereçam o melhor esquema de codificação-decodificação com este modelo. Como não podemos otimizar facilmente todo o espaço de funções, restringimos o domínio de otimização e decidimos expressar f, g e h como redes neurais. Assim, F, G e H correspondem, respectivamente, às famílias de funções definidas pelas arquiteturas de rede e a otimização é feita sobre os parâmetros dessas redes. 


Na prática, g e h não são definidos por duas redes completamente independentes, mas compartilham uma parte de sua arquitetura e seus pesos, de modo que temos:


 


![form7](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form7-1024x41.png)


 


Como isso define a matriz de covariância de q\_x(z), h(x) deve ser uma matriz quadrada. Entretanto, para simplificar o cálculo e reduzir o número de parâmetros, assumimos que nossa aproximação de p(z | x), q\_x(z), é uma distribuição gaussiana multidimensional com matriz de covariância diagonal (assunção de independência de variáveis). Com essa suposição, h(x) é simplesmente o vetor dos elementos diagonais da matriz de covariância e, então, tem o mesmo tamanho de g(x). No entanto, reduzimos dessa maneira a família de distribuições que consideramos para inferência variacional e, portanto, a aproximação de p(z | x) obtida pode ser menos precisa.


![form8](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form8-1024x474.png)


Ao contrário da parte do codificador que modela p(z | x) e para a qual consideramos um gaussiano com média e covariância que são funções de x(g e h), nosso modelo assume para p(x | z) um gaussiano com covariância. A função f da variável z que define a média desse gaussiano é modelada por uma rede neural e pode ser representada da seguinte forma:


![form9](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form9-1024x415.png)


A arquitetura geral é então obtida concatenando o codificador e as partes do decodificador. No entanto, ainda precisamos ter muito cuidado com a maneira como coletamos amostras da distribuição retornada pelo codificador durante o treinamento. O processo de amostragem deve ser expresso de forma a permitir que o erro seja retropropagado pela rede. Um truque simples, chamado truque de reparametrização, é usado para tornar possível a descida do gradiente, apesar da amostragem aleatória que ocorre na metade da arquitetura e consiste em usar o fato de que se z é uma variável aleatória após uma distribuição gaussiana com média g(x) e com covariância h(x), pode ser expresso como:


![form10](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form10.jpg)


![form11](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form11-1024x388.png)


Finalmente, a função objetivo da arquitetura de Autoencoder Variacional obtida dessa maneira é dada pela última equação da subseção anterior, na qual a expectativa teórica é substituída por uma aproximação de Monte-Carlo mais ou menos precisa que consiste, na maioria das vezes, em um sorteio único. Assim, considerando essa aproximação e denotando C = 1 / (2c), recuperamos a função de perda derivada intuitivamente na seção anterior, composta por um termo de reconstrução, um termo de regularização e uma constante para definir os pesos relativos desses dois termos.


![form12](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/form12-1024x617.png)


Autoencoders Variacionais (VAEs) são Autoencoders que resolvem o problema da irregularidade do espaço latente, fazendo com que o codificador retorne uma distribuição sobre o espaço latente em vez de um único ponto e adicionando à função de perda um termo de regularização sobre a distribuição retornada para garantir uma melhor organização do espaço latente assumindo um modelo probabilístico simples para descrever nossos dados, a função de perda bastante intuitiva dos VAEs, composta por um termo de reconstrução e um termo de regularização, pode ser cuidadosamente derivada, usando em particular a técnica estatística de inferência variacional (daí o nome Autoencoder “Variacional”).


Para concluir, podemos destacar que, durante os últimos anos, as GANs se beneficiaram de muito mais contribuições científicas do que os VAEs. Entre outras razões, o maior interesse demonstrado pela comunidade por GANs pode ser parcialmente explicado pelo maior grau de complexidade na base teórica dos VAEs (modelo probabilístico e inferência variacional) em comparação à simplicidade do conceito de treinamento adversário que rege os GANs. Com este capítulo, esperamos que tenhamos compartilhado intuições valiosas e fortes fundamentos teóricos para tornar os VAEs mais acessíveis aos recém-chegados. No entanto, agora que discutimos em profundidade os dois, resta uma pergunta … qual arquitetura você achou mais interessante, GANs ou VAEs?


No próximo capítulo começamos a estudar a Aprendizagem Por Reforço! Até lá.


Referências:


[Formação Análise Estatística](https://www.datascienceacademy.com.br/bundle/formacao-analise-estatistica)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[Autoencoders – Unsupervised Learning](http://ufldl.stanford.edu/tutorial/unsupervised/Autoencoders/)


[Bayesian inference problem, MCMC and variational inference](https://towardsdatascience.com/bayesian-inference-problem-mcmc-and-variational-inference-25a8aa9bce29)


[Understanding Variational Autoencoders (VAEs)](https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73)


[Deep inside: Autoencoders](https://towardsdatascience.com/deep-inside-autoencoders-7e41f319999f)


[Deep Learning — Different Types of Autoencoders](https://medium.com/datadriveninvestor/deep-learning-different-types-of-autoencoders-41d4fa5f7570)


[Contractive Auto-Encoders – Explicit Invariance During Feature Extraction](http://www.icml-2011.org/papers/455_icmlpaper.pdf)


[Stacked Denoising Autoencoders: Learning Useful Representations in a Deep Network with a Local Denoising Criterion](http://www.jmlr.org/papers/volume11/vincent10a/vincent10a.pdf)


[Introduction to Autoencoders](https://www.jeremyjordan.me/autoencoders/)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


<div id="capitulo-62---o-que-e-aprendizagem-por-reforco?"></div>

# Capítulo 62 – O Que é Aprendizagem Por Reforço?


Todas as arquiteturas de Deep Learning que estudamos até aqui neste livro podem ser classificadas em duas categorias de aprendizagem de máquina (você já sabe que Deep Learning é sub-categoria de Machine Learning, que por sua vez é uma sub-categoria de [Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-machine-learning)): 


* Aprendizagem Supervisionada – quando apresentamos ao algoritmo dados de entrada e as respectivas saídas.
* Aprendizagem Não Supervisionada – quando apresentamos somente os dados de entrada e o algoritmo descobre as saídas.


Mas existe uma terceira categoria de aprendizagem, chamada de Aprendizagem Por Reforço (ou Reinforcement Learning), muito usada em Games e Robótica e que vem obtendo resultados cada vez melhores. A Aprendizagem Por Reforço é a principal técnica por trás do AlphaGo e está muito bem retratada no documentário do mesmo nome: [AlphaGo](https://www.imdb.com/title/tt6700846/).


Serão diversos capítulos dedicados a esta técnica e à sua extensão, o Deep Reinforcement Learning. Vamos começar definindo o que é Aprendizagem Por Reforço.


### O Que é Aprendizagem Por Reforço?


A Aprendizagem Por Reforço é o treinamento de modelos de aprendizado de máquina para tomar uma sequência de decisões. O agente aprende a atingir uma meta em um ambiente incerto e potencialmente complexo. No aprendizado por reforço, o sistema de inteligência artificial enfrenta uma situação. O computador utiliza tentativa e erro para encontrar uma solução para o problema. Para que a máquina faça o que o programador deseja, a inteligência artificial recebe recompensas ou penalidades pelas ações que executa. Seu objetivo é maximizar a recompensa total.


Embora o [Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) ou o [Engenheiro de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia) defina a política de recompensa – isto é, as regras do jogo – ele não dá ao modelo nenhuma dica ou sugestão de como resolver o jogo. Cabe ao modelo descobrir como executar a tarefa para maximizar a recompensa, começando com testes totalmente aleatórios e terminando com táticas sofisticadas. Ao alavancar o poder da pesquisa e de muitas tentativas, o aprendizado por reforço é atualmente a maneira mais eficaz de sugerir a criatividade da máquina. Ao contrário dos seres humanos, a inteligência artificial pode reunir experiência de milhares de jogos paralelos se um algoritmo de aprendizado por reforço for executado em uma infraestrutura de computador suficientemente poderosa.


Exemplo: 


O problema é o seguinte: Temos um agente e uma recompensa, com muitos obstáculos no meio, como nesta imagem abaixo. O agente deve encontrar o melhor caminho possível para alcançar a recompensa e quando encontrar um obstáculo, deve ser penalizado (pois ele deve escolher o caminho sem obstáculos). Com a Aprendizagem Por Reforço, podemos treinar o agente para encontrar o melhor caminho.


![rl](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/rl-300x208.png)


### 


### Desafios do Aprendizado Por Reforço


O principal desafio do aprendizado por reforço está na preparação do ambiente de simulação, que depende muito da tarefa a ser executada. Quando o modelo é treinado em jogos de Xadrez, Go ou Atari, a preparação do ambiente de simulação é relativamente simples. Quando se trata de construir um modelo capaz de dirigir um carro autônomo, a construção de um simulador realista é crucial antes de deixar o carro andar na rua. O modelo precisa descobrir como frear ou evitar uma colisão em um ambiente seguro. Transferir o modelo do ambiente de treinamento para o mundo real é onde as coisas ficam complicadas.


Escalar e ajustar a rede neural que controla o agente é outro desafio. Não há como se comunicar com a rede a não ser através do sistema de recompensas e penalidades. Isso pode levar a um esquecimento catastrófico, em que a aquisição de novos conhecimentos faz com que alguns dos antigos sejam apagados da rede. Ou seja, precisamos guardar o aprendizado na “memória” do agente.  




Outro desafio é alcançar um ótimo local – ou seja, o agente executa a tarefa como está, mas não da maneira ideal ou necessária. Um “saltador” pulando como um canguru em vez de fazer o que se esperava dele com pequenos saltos é um ótimo exemplo. Por fim, existem agentes que otimizarão o prêmio sem executar a tarefa para a qual foram projetados. 


### O Que Distingue o Aprendizado Por Reforço do Aprendizado Profundo e do Aprendizado de Máquina?


De fato, não há uma divisão clara entre aprendizado de máquina, aprendizado profundo e aprendizado por reforço. É como uma relação paralelogramo – retângulo – quadrado, em que o aprendizado de máquina é a categoria mais ampla e o aprendizado por reforço é o mais estreito.


Da mesma forma, o aprendizado por reforço é uma aplicação especializada de técnicas de Deep Learning e Machine Learning, projetada para resolver problemas de uma maneira específica.


Embora as ideias pareçam divergir, não há uma divisão acentuada entre esses subtipos. Além disso, eles se mesclam nos projetos, pois os modelos são projetados para não se ater ao “tipo puro”, mas para executar a tarefa da maneira mais eficaz possível. Portanto, “o que distingue precisamente o aprendizado de máquina, o aprendizado profundo e o aprendizado por reforço” é, na verdade, uma pergunta difícil de responder. Mas vamos definir cada um deles!


**Aprendizado de Máquina** é uma forma de IA na qual os computadores têm a capacidade de melhorar progressivamente o desempenho de uma tarefa específica com dados, sem serem diretamente programados. Essa é a definição de [Arthur Lee Samuel](https://en.wikipedia.org/wiki/Arthur_Samuel). Ele cunhou o termo “aprendizado de máquina”, do qual existem dois tipos, aprendizado de máquina supervisionado e não supervisionado. 


O aprendizado de máquina supervisionado acontece quando um programador pode fornecer um rótulo para cada entrada de treinamento no sistema de aprendizado de máquina.


O aprendizado não supervisionado ocorre quando o modelo é fornecido apenas com os dados de entrada, mas sem rótulos explícitos. Ele precisa pesquisar os dados e encontrar a estrutura ou os relacionamentos ocultos. O [Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) pode não saber qual é a estrutura ou o que o modelo de aprendizado de máquina irá encontrar.


O **Aprendizado Profundo** consiste em várias camadas de redes neurais, projetadas para executar tarefas mais sofisticadas. A construção de modelos de aprendizado profundo foi inspirada no design do cérebro humano, mas simplificada. Os modelos de aprendizado profundo consistem em algumas camadas de rede neural que são, em princípio, responsáveis por aprender gradualmente recursos mais abstratos sobre dados específicos.


Embora as soluções de aprendizado profundo sejam capazes de fornecer resultados maravilhosos, em termos de escala, elas não são páreo para o cérebro humano. Cada camada usa o resultado de uma anterior como entrada e toda a rede é treinada como um todo. O conceito central de criar uma rede neural artificial não é novo, mas apenas recentemente o hardware moderno forneceu energia computacional suficiente para treinar efetivamente essas redes, expondo um número suficiente de exemplos. A adoção estendida trouxe estruturas como TensorFlow, Keras e PyTorch, as quais tornaram a construção de modelos de aprendizado de máquina muito mais conveniente.


O **Aprendizado Por Reforço**, como declarado acima, emprega um sistema de recompensas e penalidades para obrigar o computador a resolver um problema sozinho. O envolvimento humano é limitado à mudança do ambiente e ao ajuste do sistema de recompensas e penalidades. Como o computador maximiza a recompensa, ele está propenso a procurar maneiras inesperadas de fazê-lo. O envolvimento humano é focado em impedir que ele explore o sistema e motive a máquina a executar a tarefa da maneira esperada. O aprendizado por reforço é útil quando não existe uma “maneira adequada” de executar uma tarefa, mas existem regras que o modelo deve seguir para desempenhar corretamente suas tarefas. Abaixo a performance de um agente sendo treinado em um jogo clássico do Atari.


Performance inicial do agente:


![breakout_0](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/breakout_0.gif)


Após 15 minutos de treinamento:


![breakout_1](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/breakout_1.gif)


Após 30 minutos de treinamento:


![breakout_2](https://www.deeplearningbook.com.br/wp-content/uploads/2019/12/breakout_2.gif)


Em particular, se a inteligência artificial vai dirigir um carro ou aprender a jogar alguns clássicos do Atari, pode ser considerado um marco intermediário significativo. Uma aplicação potencial do aprendizado por reforço em veículos autônomos é uma das aplicações mais trabalhadas nos dias de hoje em todo mundo. Um desenvolvedor é incapaz de prever todas as situações futuras da estrada, portanto, deixar o modelo treinar-se com um sistema de penalidades e recompensas em um ambiente variado é possivelmente a maneira mais eficaz da IA ampliar a experiência que possui e coleta e assim aprender a conduzir um veículo autônomo sem que seja explicitamente programada para isso.


Continuaremos no próximo capítulo!


Referências:


[Inteligência Artificial Aplicada a Finanças](https://www.datascienceacademy.com.br/course/inteligencia-artificial-aplicada-financas)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[What is reinforcement learning? The complete guide](https://deepsense.ai/what-is-reinforcement-learning-the-complete-guide/)


[Reinforcement learning](https://www.geeksforgeeks.org/what-is-reinforcement-learning/)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-63---aplicacoes-da-aprendizagem-por-reforco-no-mundo-real"></div>

# Capítulo 63 – Aplicações da Aprendizagem Por Reforço no Mundo Real


Enquanto as Redes Neurais Convolucionais (CNNs) e as Redes Neurais Recorrentes (RNNs) estão se tornando cada vez mais importantes para as empresas devido às suas aplicações em Visão Computacional e Processamento de Linguagem Natural, o Aprendizado por Reforço como uma estrutura para a neurociência computacional de um modelo para o processo de tomada de decisão parece estar subvalorizado. A Aprendizagem Por Reforço não deve ser negligenciada no espaço da pesquisa corporativa, dados seus enormes potenciais em auxiliar na tomada de decisões. 


O Aprendizado por Reforço (ou Reinforcement Learning – RL), conhecido como modelo de aprendizado semi-supervisionado em Machine Learning, é uma técnica para permitir que um agente tome ações e interaja com um ambiente, a fim de maximizar as recompensas totais. Aprendizado por Reforço é geralmente modelado como um Processo de Decisão de Markov (MDP) e estudaremos isso em mais detalhes nos capítulos seguintes.


![](https://www.deeplearningbook.com.br/wp-content/uploads/2020/02/rl-1024x376.png)


Mas aqui vai uma explicação bem simples e objetiva para ajudar a compreender o conceito:


Imagine que um bebê recebe um controle remoto da TV em sua casa (ambiente). Em termos simples, o bebê (agente) primeiro observará e construirá sua própria representação do ambiente (estado). Em seguida, o bebê curioso executará certas ações, como pressionar o controle remoto (ação) e observará a resposta da TV (próximo estado). Como uma TV não responde e é monótona, o bebê não gosta dela (recebendo uma recompensa negativa) e realiza menos ações que levarão a esse resultado (atualização da política) e vice-versa. O bebê repetirá o processo até encontrar uma política (o que fazer em diferentes circunstâncias) com a qual está satisfeito (maximizar as recompensas totais (com desconto)). Isso é o Aprendizado por Reforço. Lembre-se que em Machine Learning o que fazemos é tentar reproduzir o aprendizado humano através de diferentes técnicas.


O estudo da Aprendizagem Por Reforço é construir uma estrutura matemática para resolver problemas. Por exemplo, para encontrar uma boa política, poderíamos usar métodos baseados em valores, como Q-learning, para medir o quão boa é uma ação em um determinado estado ou métodos baseados em políticas para descobrir diretamente quais ações executar em diferentes estados sem saber quão boas as ações são.


No entanto, os problemas que enfrentamos no mundo real podem ser extremamente complicados de várias maneiras diferentes e, portanto, um algoritmo típico de Aprendizagem Por Reforço não tem nenhuma pista para resolver. Por exemplo, o espaço de estado é muito grande no jogo do GO, o ambiente não pode ser totalmente observado no jogo de pôquer e há muitos agentes interagindo entre si no mundo real. Os pesquisadores inventaram métodos para resolver alguns dos problemas usando redes neurais profundas para modelar as políticas desejadas, funções de valor ou mesmo os modelos de transição, que, portanto, são chamados de Aprendizado por Reforço Profundo (Deep Reinforcement Learning). 


Mas abordaremos tudo isso em detalhes mais a frente. Por hora, vejamos algumas das principais aplicações da Aprendizagem Por Reforço.


### Gerenciamento de Recursos em Clusters de Computadores


Projetar algoritmos para alocar recursos limitados a diferentes tarefas é desafiador e requer heurísticas geradas por humanos. O artigo “[Gerenciamento de recursos com aprendizado por reforço profundo](https://people.csail.mit.edu/alizadeh/papers/deeprm-hotnets16.pdf)” explica como usar o RL para aprender automaticamente a alocar e programar recursos de computador para jobs em espera, com o objetivo de minimizar a desaceleração média do job (tarefa).


O espaço de estados foi formulado como a alocação de recursos atual e o perfil de recursos dos jobs. Para o espaço de ação, eles usaram um truque para permitir que o agente escolha mais de uma ação a cada etapa do tempo. A recompensa era a soma de (-1 / duração do job) em todos os jobs no sistema. Em seguida, eles combinaram o algoritmo REINFORCE e o valor da linha de base para calcular os gradientes da política e encontrar os melhores parâmetros de política que fornecem a distribuição de probabilidade das ações para minimizar o objetivo. 


### Controle de Semáforo


No artigo “[Sistema multiagente baseado em aprendizado por reforço para controle de sinais de tráfego de rede](http://web.eecs.utk.edu/~ielhanan/Papers/IET_ITS_2010.pdf)”, os pesquisadores tentaram projetar um controlador de semáforo para resolver o problema de congestionamento. Testados apenas em ambiente simulado, seus métodos mostraram resultados superiores aos métodos tradicionais e lançaram uma luz sobre os possíveis usos da RL de múltiplos agentes no projeto de sistemas de tráfego.


Cinco agentes foram colocados na rede de tráfego de cinco cruzamentos, com um agente RL no cruzamento central para controlar a sinalização de tráfego. O estado foi definido como um vetor de oito dimensões, com cada elemento representando o fluxo de tráfego relativo de cada faixa. Oito opções estavam disponíveis para o agente, cada uma representando uma combinação de fases, e a função de recompensa foi definida como redução no atraso em comparação com o passo anterior. Os autores usaram o DQN para aprender o valor Q dos pares {state, action}.


### Robótica


Há um incrível trabalho na aplicação de RL em robótica. Recomendamos a leitura desse [paper](https://www.ias.informatik.tu-darmstadt.de/uploads/Publications/Kober_IJRR_2013.pdf) com o resultado de uma pesquisa de RL em robótica. Neste outro [trabalho](https://arxiv.org/pdf/1504.00702.pdf), os pesquisadores treinaram um robô para aprender políticas para mapear imagens de vídeo brutas para as ações do robô. As imagens RGB foram alimentadas em uma CNN e as saídas foram os torques do motor. O componente RL era a pesquisa de política guiada para gerar dados de treinamento provenientes de sua própria distribuição de estado.


### Configuração de Sistemas Web


Existem mais de 100 parâmetros configuráveis ​​em um Sistema Web e o processo de ajuste dos parâmetros requer um operador qualificado e vários testes de rastreamento e erro. O artigo “[Uma abordagem de aprendizado por reforço à auto-configuração do sistema Web on-line](http://ranger.uta.edu/~jrao/papers/ICDCS09.pdf)” mostrou a primeira tentativa no domínio sobre como fazer a reconfiguração autônoma de parâmetros em sistemas web multicamada em ambientes dinâmicos baseados em VM.


O processo de reconfiguração pode ser formulado como um MDP finito. O espaço de estado era a configuração do sistema, o espaço de ação era {aumentar, diminuir, manter} para cada parâmetro e a recompensa era definida como a diferença entre o tempo de resposta pretendido e o tempo de resposta medido. Os autores usaram o algoritmo de Q-learning para executar a tarefa.


Embora os autores tenham usado alguma outra técnica, como a inicialização de políticas, para remediar o grande espaço de estados e a complexidade computacional do problema, em vez das combinações potenciais de RL e rede neural, acredita-se que o trabalho pioneiro tenha preparado o caminho para futuras pesquisas nessa área. .


### Química


O RL também pode ser aplicado na otimização de reações químicas. Pesquisadores mostraram que seu modelo superou um algoritmo de última geração e generalizou para mecanismos subjacentes diferentes no artigo “[Otimizando reações químicas com aprendizado de reforço profundo](https://pubs.acs.org/doi/full/10.1021/acscentsci.7b00492)”.


Combinado com o LSTM para modelar a função de política, o agente RL otimizou a reação química com o processo de decisão de Markov (MDP) caracterizado por {S, A, P, R}, em que S era o conjunto de condições experimentais (como temperatura, pH, etc), A foi o conjunto de todas as ações possíveis que podem alterar as condições experimentais, P foi a probabilidade de transição da condição atual da experiência para a próxima condição e R foi a recompensa que é uma função do estado.


A aplicação é excelente para demonstrar como a RL pode reduzir o trabalho demorado e de tentativa e erro em um ambiente relativamente estável.


### Recomendações Personalizadas


O trabalho de recomendações de notícias sempre enfrentou vários desafios, incluindo a dinâmica de mudança rápida das notícias, os usuários que se cansam facilmente e a Taxa de Cliques que não pode refletir a taxa de retenção de usuários. [Guanjie et al.](http://www.personal.psu.edu/~gjz5038/paper/www2018_reinforceRec/www2018_reinforceRec.pdf) aplicaram RL no sistema de recomendação de notícias em um documento intitulado “DRN: Uma Estrutura de Aprendizado de Reforço Profundo para Recomendação de Notícias” para combater os problemas.


Na prática, eles construíram quatro categorias de recursos, a saber: A) recursos do usuário, B) recursos de contexto como os recursos de estado do ambiente, C) recursos de notícias do usuário e D) recursos de notícias como os recursos de ação. Os quatro recursos foram inseridos na Deep Q-Network (DQN) para calcular o valor Q. Uma lista de notícias foi escolhida para recomendar com base no valor Q, e o clique do usuário nas notícias foi parte da recompensa que o agente da RL recebeu. 


Os autores também empregaram outras técnicas para resolver outros problemas desafiadores, incluindo repetição de memória, modelos de sobrevivência, Dueling Bandit Gradient Descent e assim por diante. 


### Leilões e Publicidade


Pesquisadores do Alibaba Group publicaram um artigo “[Leilões em tempo real com aprendizado de reforço de agentes múltiplos em publicidade gráfica](https://arxiv.org/pdf/1802.09756.pdf)” e afirmaram que sua solução distribuída de agentes múltiplos baseada em cluster (DCMAB) alcançou resultados promissores e, portanto, planejam realizar uma teste ao vivo na plataforma Taobao.


De um modo geral, a plataforma de anúncios Taobao é um local para os comerciantes fazerem um lance para exibir anúncios para os clientes. Isso pode ser um problema de vários agentes, porque os comerciantes fazem lances uns contra os outros e suas ações são inter-relacionadas. No artigo, comerciantes e clientes foram agrupados em diferentes grupos para reduzir a complexidade computacional. O espaço de estado dos agentes indicava o status de custo-receita dos agentes, o espaço de ação era o lance (contínuo) e a recompensa era a receita causada pelo cluster de clientes.


Talvez você esteja curioso por saber como seria o algoritmo para resolver esse tipo de problema. Aqui está o algoritmo criado pelos pesquisadores (mais detalhes no paper da pesquisa, no link anterior):


![](https://www.deeplearningbook.com.br/wp-content/uploads/2020/02/algoritmo.png)


### Jogos


A RL é tão conhecida hoje em dia porque é o algoritmo convencional usado para resolver jogos diferentes e às vezes alcançar um desempenho super-humano.


O mais famoso deve ser [AlphaGo](https://storage.googleapis.com/deepmind-media/alphago/AlphaGoNaturePaper.pdf) e [AlphaGo Zero](https://deepmind.com/blog/article/alphago-zero-starting-scratch). O AlphaGo, treinado com inúmeros jogos humanos, já alcançou um desempenho super-humano usando a rede de valor e a pesquisa de árvores Monte Carlo (MCTS) em sua rede de políticas. No entanto, os pesquisadores tentaram uma abordagem mais pura da RL – treinando-a do zero. Os pesquisadores deixaram o novo agente, AlphaGo Zero, jogar sozinho e finalmente derrotar o AlphaGo 100-0.


### Aprendizagem Profunda (Deep Learning)


Mais e mais tentativas de combinar RL e outras arquiteturas de aprendizado profundo podem ser vistas recentemente e mostraram resultados impressionantes.


Um dos trabalhos mais influentes da RL é o trabalho pioneiro da Deepmind para combinar a [CNN com a RL](https://www.cs.toronto.edu/~vmnih/docs/dqn.pdf). Ao fazer isso, o agente tem a capacidade de “ver” o ambiente por meio de sensores de alta dimensão e depois aprender a interagir com ele.


RL e RNN são outras combinações usadas pelas pessoas para tentar novas ideias. RNN é um tipo de rede neural que possui “memórias”. Quando combinada com a RL, a RNN oferece aos agentes a capacidade de memorizar as coisas. Por exemplo, combinaram [LSTM com RL](https://arxiv.org/pdf/1507.06527.pdf) para criar uma profunda rede Q recorrente (DRQN) para jogar jogos do Atari 2600. Também usaram RNN e RL para resolver problemas de otimização de reações químicas.


O Deepmind mostrou como usar [modelos generativos e RL](https://arxiv.org/pdf/1804.01118.pdf) para gerar programas. No modelo, o agente treinado adversamente usou o sinal como recompensa para melhorar as ações, em vez de propagar os gradientes para o espaço de entrada como no treinamento da GAN. Incrível, não?


### O Que Você Precisa Saber Antes de Aplicar a RL ao seu Problema?


Existem várias coisas necessárias para que a RL possa ser aplicada.


**Entendendo seu problema**: Você não precisa necessariamente usar RL no seu problema e, às vezes, simplesmente não pode usá-lo. Convém verificar se o seu problema possui algumas das seguintes características antes de decidir usar a RL: 


* a) tentativa e erro (você pode aprender a fazer melhor recebendo comentários do ambiente);
* b) recompensas atrasadas;
* c) pode ser modelado como MDP;
* d) seu problema é um problema de controle.


**Um ambiente simulado**: Muitas iterações são necessárias antes que um algoritmo RL funcione. Tenho certeza de que você não quer ver um agente de RL tentando coisas diferentes em um carro autônomo em uma rodovia, certo? Portanto, é necessário um ambiente simulado que possa refletir corretamente o mundo real.


**MDP**: Seu mundo precisa formular seu problema em um MDP. Você precisa projetar o espaço de estado, o espaço de ação, a função de recompensa e assim por diante. Seu agente fará o que é recompensado sob as restrições. Você pode não obter os resultados desejados se projetar as coisas de maneira diferente.


**Algoritmos**: Existem diferentes algoritmos de RL que você pode escolher e perguntas a serem feitas. Você deseja descobrir diretamente a política ou deseja aprender a função de valor? Você quer ir livre de modelo ou baseado em modelo? Você precisa combinar outros tipos de rede ou métodos neurais profundos para resolver seus problemas?


### Intuições de Outras Disciplinas


RL tem uma relação muito estreita com psicologia, biologia e neurociência. Se você pensar bem, o que um agente de RL faz é apenas tentativa e erro: aprende o quão bom ou ruim suas ações são baseadas nas recompensas que recebe do ambiente. E é exatamente assim que o ser humano aprende a tomar uma decisão. Além disso, o problema de exploração, o problema de cessão de recompensa/penalidade, as tentativas de modelar o ambiente também são algo que enfrentamos em nossa vida cotidiana.


A teoria da economia também pode lançar alguma luz sobre RL. Em particular, a análise da aprendizagem de reforço multi-agente (MARL) pode ser entendida a partir das perspectivas da teoria dos jogos, que é uma área de pesquisa desenvolvida por John Nash para entender as interações de agentes em um sistema. Além da teoria dos jogos, o MARL, Processo de Decisão Markov Parcialmente Observável (POMDP) ​​também pode ser útil para entender outros tópicos econômicos, como estrutura de mercado (por exemplo, monopólio, oligopólio, etc.), externalidade e assimetria de informação. 


### O que a Aprendizagem Por Reforço Pode Alcançar no Futuro?


A Aprendizagem Por Reforço seria influente e impactante das seguintes maneiras:


**Assistência humana**: Talvez seja exagero dizer que a RL pode um dia evoluir para inteligência geral artificial (AGI), mas a RL certamente tem o potencial de ajudar e trabalhar com pessoas. Imagine um robô ou um assistente virtual trabalhando com você e levando suas ações em consideração para executar ações a fim de alcançar um objetivo comum. Não seria ótimo?


**Entendendo as consequências de diferentes estratégias**: A vida é incrível, porque o tempo não volta e as coisas acontecem apenas uma vez. No entanto, às vezes gostaríamos de saber como as coisas poderiam ser diferentes (pelo menos a curto prazo) se eu adotasse uma ação diferente. A Croácia teria uma chance maior de ganhar a Copa do Mundo de 2018 se o treinador usasse outra estratégia? Obviamente, para conseguir isso, precisaríamos modelar perfeitamente o ambiente, as funções de transição e assim por diante e também analisar as interações entre os agentes.


As possibilidade são muitas e por isso Inteligência Artificial é um dos temas mais quentes do momento e os profissionais atentos a isso, ficarão com as melhores oportunidades. Continuaremos no próximo capítulo!


Referências:


[Inteligência Artificial Aplicada a Finanças](https://www.datascienceacademy.com.br/course/inteligencia-artificial-aplicada-financas)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[What is reinforcement learning? The complete guide](https://deepsense.ai/what-is-reinforcement-learning-the-complete-guide/)


[Reinforcement learning](https://www.geeksforgeeks.org/what-is-reinforcement-learning/)


[Applications of Reinforcement Learning in Real World](https://towardsdatascience.com/applications-of-reinforcement-learning-in-real-world-1a94955bcd12)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-64---componentes-do-aprendizado-por-reforco-(reinforcement-learning)"></div>

# Capítulo 64 – Componentes do Aprendizado Por Reforço (Reinforcement Learning)


O Aprendizado Por Reforço pode ser entendido através de seus componentes: agente, ambiente, estados, ações e recompensas, todos os quais explicaremos neste capítulo. Letras maiúsculas indicarão conjuntos de objetos e letras minúsculas indicarão um objeto específico. Por exemplo: **A** são todas as ações possíveis, enquanto **a** é uma ação específica contida no conjunto.


**Agente**: um agente executa ações; por exemplo, um drone fazendo uma entrega ou Super Mario navegando em um videogame. O algoritmo é o agente. Pode ser útil considerar que, na vida, o agente é você.


**Ação** (A): A é o conjunto de todos os movimentos possíveis que o agente pode fazer. Uma ação é quase autoexplicativa, mas deve-se notar que os agentes geralmente escolhem de uma lista de ações possíveis e discretas. Nos videogames, a lista pode incluir correr para a direita ou para a esquerda, pular alto ou baixo, agachar-se ou ficar parado. Nos mercados de ações, a lista pode incluir a compra, venda ou manutenção de qualquer um de uma matriz de ativos financeiros e seus derivativos. Ao lidar com drones, as alternativas incluiriam muitas velocidades e acelerações diferentes no espaço 3D.


**Fator de desconto**: O fator de desconto é multiplicado por recompensas futuras, conforme descoberto pelo agente, a fim de amortecer o efeito dessas recompensas na escolha de ação do agente. Por quê? Ele foi projetado para fazer com que as recompensas futuras valham menos que as recompensas imediatas; isto é, aplica um tipo de hedonismo de curto prazo no agente. Geralmente expressa com a letra grega minúscula gama: γ. Se γ for 0,8 e houver uma recompensa de 10 pontos após três etapas de tempo, o valor atual dessa recompensa será de 0,8³ x 10. Um fator de desconto de 1 faria as recompensas futuras valerem tanto quanto as recompensas imediatas. Estamos lutando contra o imediatismo aqui. O agente deve escolher as ações que levam à melhor solução global possível, não apenas a melhor solução imediata.


**Ambiente**: O mundo pelo qual o agente se move e que responde ao agente. O ambiente toma o estado atual e a ação do agente como entrada e retorna como saída a recompensa do agente e seu próximo estado. Se você é o agente, o ambiente pode ser as leis da física e as regras da sociedade que processam suas ações e determinam as consequências delas.


**Estado** (S): Um estado é uma situação concreta e imediata em que o agente se encontra; ou seja, um local e momento específico, uma configuração instantânea que coloca o agente em relação a outras coisas importantes, como ferramentas, obstáculos, inimigos ou prêmios. Pode ser a situação atual retornada pelo ambiente ou qualquer situação futura. Você já esteve no lugar errado na hora errada? Isso é um estado.


**Recompensa** (R): Uma recompensa é o feedback pelo qual medimos o sucesso ou o fracasso das ações de um agente em um determinado estado. Por exemplo, em um videogame, quando Mario toca uma moeda, ele ganha pontos. A partir de qualquer estado, um agente envia a saída na forma de ações para o ambiente, e o ambiente retorna o novo estado do agente (que resultou da ação no estado anterior), bem como recompensas, se houver. As recompensas podem ser imediatas ou atrasadas. Eles avaliam efetivamente a ação do agente.


**Política** (π): A política é a estratégia que o agente emprega para determinar a próxima ação com base no estado atual. Ele mapeia estados para ações, as ações que prometem a maior recompensa.


**Valor** (V): O retorno esperado a longo prazo com desconto, em oposição à recompensa de curto prazo R. Vπ (s) é definido como o retorno esperado a longo prazo do estado atual sob a política π. Descontamos as recompensas ou diminuímos seu valor estimado, quanto mais futuro elas ocorrerem. E lembre-se de Keynes: “A longo prazo, estamos todos mortos”. É por isso que você desconta recompensas futuras. É útil distinguir.


**Valor Q ou Valor da Ação** (Q): O valor Q é semelhante ao Valor, exceto pelo fato de ser necessário um parâmetro extra, a ação atual a. Qπ (s, a) refere-se ao retorno a longo prazo de uma ação que executa uma ação sob política π do estado atual s. Q mapeia pares de ação e estado para recompensas. Observe a diferença entre Q e política.


**Trajetória**: Uma sequência de estados e ações que influenciam esses estados. A vida de um agente é apenas uma bola lançada alta e arqueando-se no espaço-tempo sem ser perturbada, como os humanos no mundo moderno.


**Distinções Principais**: Recompensa é um sinal imediato recebido em um determinado estado, enquanto valor é a soma de todas as recompensas que você pode antecipar desse estado. Valor é uma expectativa de longo prazo, enquanto recompensa é um prazer imediato. O valor é comer salada de espinafre no jantar, antecipando uma vida longa e saudável; recompensa é comer hamburguer com batata frita e refrigerante para o jantar e comprometer sua saúde futura. Eles diferem em seus horizontes temporais. Assim, você pode ter estados em que o valor e a recompensa divergem: você pode receber uma recompensa baixa e imediata (espinafre), mesmo quando se move para uma posição com grande potencial de valor a longo prazo; ou você pode receber uma alta recompensa imediata (hamburguer com batata frita e refrigerante) que leva à diminuição das perspectivas ao longo do tempo. É por isso que a função de valor, em vez de recompensas imediatas, é o que o aprendizado por reforço procura prever e controlar.


Portanto, ambientes são funções que transformam uma ação executada no estado atual no próximo estado e uma recompensa; agentes são funções que transformam o novo estado e recompensam na próxima ação. Podemos conhecer e definir a função do agente, mas na maioria das situações em que é útil e interessante aplicar o aprendizado por reforço, não sabemos a função do ambiente. É uma caixa preta onde só vemos as entradas e saídas. É como o relacionamento da maioria das pessoas com a tecnologia: sabemos o que faz, mas não sabemos como funciona. O aprendizado por reforço representa a tentativa de um agente de aproximar a função do ambiente, para que possamos enviar ações para o ambiente de caixa preta que maximize as recompensas que ele distribui.


 


![simple_RL_schema](https://www.deeplearningbook.com.br/wp-content/uploads/2020/02/simple_RL_schema.png)


 


No loop de feedback acima, os subscritos indicam as etapas de tempo t e t + 1, cada uma das quais se refere a estados diferentes: o estado no momento t e o estado no momento t + 1. Diferente de outras formas de aprendizado de máquina – como aprendizado supervisionado e não supervisionado – o aprendizado por reforço só pode ser pensado sequencialmente em termos de pares de ação de estado que ocorrem um após o outro.


O aprendizado por reforço julga as ações pelos resultados que elas produzem. É orientado a objetivos, e seu objetivo é aprender sequências de ações que levarão um agente a atingir seu objetivo ou maximizar sua função objetivo. aqui estão alguns exemplos:


Nos videogames, o objetivo é terminar o jogo com mais pontos, para que cada ponto adicional obtido ao longo do jogo afete o comportamento subsequente do agente; ou seja, o agente pode aprender que deve atirar em navios de guerra, tocar em moedas ou desviar de meteoros para maximizar sua pontuação.


No mundo real, o objetivo pode ser que um robô viaje do ponto A ao ponto B, e cada centímetro que o robô é capaz de se aproximar do ponto B pode ser contado como pontos. Aqui está um exemplo de uma função objetiva para o aprendizado por reforço; ou seja, a maneira como define seu objetivo:


![reinforcementlearning_objective](https://www.deeplearningbook.com.br/wp-content/uploads/2020/02/reinforcementlearning_objective.png)


Estamos somando a função de recompensa r sobre t, que significa etapas de tempo. Portanto, essa função objetivo calcula toda a recompensa que poderíamos obter executando, digamos, um jogo. Aqui, x é o estado em um determinado momento, a é a ação executada nesse estado e r é a função de recompensa para x e a.


Outro exemplo é a otimização de portfólios financeiros (uma das principais aplicações atuais da Aprendizagem Por Reforço). Dado o volume de movimentação de diversos ativos financeiros, o agente procura a melhor combinação possível de investimentos que garanta o maior retorno financeiro no longo prazo. Essa é a tecnologia por trás dos Robôs Investidores e que ensinamos em detalhes em [Inteligência Artificial Aplicada a Finanças](https://www.datascienceacademy.com.br/course/inteligencia-artificial-aplicada-financas).


Quer aprender um pouco da Matemática desta incrível técnica de aprendizagem de máquina e como ela se relaciona com Deep Learning? Então acompanhe os próximos capítulos.


Referências:


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[A Beginner’s Guide to Deep Reinforcement Learning](https://pathmind.com/wiki/deep-reinforcement-learning#define)


[What is reinforcement learning? The complete guide](https://deepsense.ai/what-is-reinforcement-learning-the-complete-guide/)


[Reinforcement learning](https://www.geeksforgeeks.org/what-is-reinforcement-learning/)


[Applications of Reinforcement Learning in Real World](https://towardsdatascience.com/applications-of-reinforcement-learning-in-real-world-1a94955bcd12)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-65---distribuicoes-de-probabilidade,-redes-neurais-e-reinforcement-learning"></div>

# Capítulo 65 – Distribuições de Probabilidade, Redes Neurais e Reinforcement Learning


Nos [capítulos anteriores](https://www.deeplearningbook.com.br/componentes-do-aprendizado-por-reforco-reinforcement-learning/) estudamos os conceitos gerais ligados ao Aprendizado Por Reforço (Reinforcement Learning). A partir de agora vamos entrar nos detalhes mais técnicos ligados a este importante método de aprendizagem de máquina, estudando Distribuições de Probabilidade, Redes Neurais e Reinforcement Learning. Acompanhe.


### O Objetivo do Aprendizado Por Reforço


O objetivo do Aprendizado Por Reforço é escolher a melhor ação para qualquer estado, o que significa que as ações devem ser classificadas e valores devem ser atribuídos em relação uma a outra. Como essas ações dependem do estado, o que realmente estamos medindo é o valor dos pares de ação e estado; ou seja, uma ação tomada de um determinado estado, algo que o agente fez em algum lugar. Aqui estão alguns exemplos para demonstrar que o valor e o significado de uma ação dependem do estado em que é tomada:


* Se a ação é se casar com alguém, casar com uma pessoa de 35 anos quando você tem 18 anos provavelmente significa algo diferente de casar com uma pessoa de 35 anos quando você tem 90 anos, e esses dois resultados provavelmente têm motivações diferentes e levam a diferentes resultados.
* Se a ação estiver gritando “Fogo!”, Então executar a ação em um teatro lotado deve significar algo diferente de executar a ação ao lado de um esquadrão de homens armados com metralhadoras. Não podemos prever o resultado de uma ação sem conhecer o contexto.


Mapeamos os pares estado-ação para os valores que esperamos que eles produzam com a função Q, descrita no [capítulo anterior](https://www.deeplearningbook.com.br/componentes-do-aprendizado-por-reforco-reinforcement-learning/). A função Q usa como entrada o estado e a ação de um agente e os mapeia para prováveis ​​recompensas.


O Aprendizado Por Reforço é o processo de executar o agente por meio de sequências de pares de ação e estado, observando as recompensas resultantes e adaptando as previsões da função Q àquelas recompensas até que ele preveja com precisão o melhor caminho a ser seguido pelo agente. Essa previsão é conhecida como uma política.


### Distribuição de Probabilidade


O Aprendizado Por Reforço é uma tentativa de modelar uma distribuição de probabilidade complexa de recompensas em relação a um número muito grande de pares de ação de estado. Esse é um dos motivos pelos quais o Aprendizado Por Reforço é combinado com, digamos, um processo de decisão de Markov, um método de amostragem de uma distribuição complexa para inferir suas propriedades. Assemelha-se muito ao problema que inspirou Stan Ulam a inventar o método de Monte Carlo; ou seja, tentar inferir as chances de que uma determinada “mão” em um jogo de carta seja bem-sucedida.


Qualquer abordagem estatística é essencialmente uma confissão de ignorância. A imensa complexidade de alguns fenômenos (biológicos, políticos, sociológicos ou relacionados a jogos de tabuleiro) torna impossível raciocinar a partir de alguns princípios. A única maneira de estudá-los é através da estatística, medindo eventos superficiais e tentando estabelecer correlações entre eles, mesmo quando não entendemos o mecanismo pelo qual eles se relacionam. O Aprendizado Por Reforço, como redes neurais profundas, é uma dessas estratégias, contando com a amostragem para extrair informações dos dados.


Depois de um pouco de tempo empregando algo como um processo de decisão de Markov para aproximar a distribuição de probabilidade da recompensa sobre pares de ação do estado, um algoritmo de Aprendizado Por Reforço pode tender a repetir ações que levam à recompensa e deixar de testar alternativas. Há uma tensão entre a exploração de recompensas conhecidas e a exploração contínua para descobrir novas ações que também levam à vitória. Assim como as empresas de petróleo têm a dupla função de extrair petróleo de campos conhecidos e perfurar novas reservas, também podem ser criados algoritmos de Aprendizado Por Reforço para explorar em graus variados, a fim de garantir que eles não tomem ações recompensadoras em detrimento de vencedores conhecidos.


O Aprendizado Por Reforço é iterativo. Em suas aplicações mais interessantes, não começa sabendo quais recompensas os pares de ação e estado produzirão. Ele aprende essas relações percorrendo estados repetidas vezes, como atletas ou músicos percorrem estados na tentativa de melhorar seu desempenho.


### Redes Neurais


E onde as redes neurais se encaixam?


As redes neurais são aproximadores de função, que são particularmente úteis no Aprendizado Por Reforço quando o espaço de estado ou espaço de ação é muito grande para ser completamente conhecido.


Uma rede neural pode ser usada para aproximar uma função de valor ou uma função de política. Ou seja, as redes neurais podem aprender a mapear estados para valores ou pares de ação e estado para valores Q. Em vez de usar uma tabela de pesquisa para armazenar, indexar e atualizar todos os estados possíveis e seus valores, o que é impossível com problemas muito grandes, podemos treinar uma rede neural em amostras do estado ou espaço de ação para aprender a prever o quanto esses valores são importantes, nosso objetivo no Aprendizado Por Reforço.


As redes neurais usam coeficientes para aproximar a função que relaciona insumos (entradas) a produtos (saídas), e seu aprendizado consiste em encontrar os coeficientes ou pesos certos, ajustando iterativamente esses pesos ao longo de gradientes que prometem menos erros. No Aprendizado Por Reforço, redes convolucionais podem ser usadas para reconhecer o estado de um agente quando a entrada é visual; por exemplo. a tela em que o agente está em um jogo, ou o terreno percorrido por um drone. Ou seja, eles realizam sua tarefa típica de reconhecimento de imagem.


Mas as redes convolucionais derivam interpretações diferentes das imagens no Aprendizado Por Reforço do que no Aprendizado Supervisionado. No Aprendizado Supervisionado, a rede aplica um rótulo a uma imagem, como no exemplo abaixo:


![conv_classifier](https://www.deeplearningbook.com.br/wp-content/uploads/2020/02/conv_classifier.png)


De fato, a rede classificará os rótulos que melhor se ajustam à imagem em termos de probabilidades. Na imagem de um gato, pode-se decidir que a imagem tem 80% de probabilidade de ser um gato, 50% de ser um cavalo e 30% de ser um cachorro.


No Aprendizado Por Reforço, dada uma imagem que representa um estado, uma rede convolucional pode classificar as ações possíveis de executar nesse estado; por exemplo, pode prever que correr à direita retornará 5 pontos, pular 7 e correr à esquerda nenhum.


![conv_agent](https://www.deeplearningbook.com.br/wp-content/uploads/2020/02/conv_agent.png)


A imagem acima ilustra o que um agente faz, mapeando um estado para a melhor ação.


### Reinforcement Learning


Uma política mapeia um estado para uma ação.


Se você se lembra, isso é diferente de Q, que mapeia pares de ações de estado para recompensas.


Para ser mais específico, Q mapeia pares de ação de estado para a combinação mais alta de recompensa imediata com todas as recompensas futuras que podem ser obtidas por ações posteriores na trajetória. Aqui está a equação para Q:


![q_learning_equation](https://www.deeplearningbook.com.br/wp-content/uploads/2020/02/q_learning_equation.png)


Depois de atribuir valores às recompensas esperadas, a função Q simplesmente seleciona o par de ação de estado com o maior valor chamado Q.


No início do Aprendizado Por Reforço, os coeficientes da rede neural podem ser inicializados estocástica ou aleatoriamente. Usando o feedback do ambiente, a rede neural pode usar a diferença entre sua recompensa esperada e a recompensa verdadeira para ajustar seus pesos e melhorar sua interpretação dos pares de ação do estado.


Esse ciclo de feedback é análogo à retropropagação de erro no Aprendizado Supervisionado. No entanto, o Aprendizado Supervisionado começa com o conhecimento dos rótulos verdadeiros que a rede neural está tentando prever. Seu objetivo é criar um modelo que mapeie imagens diferentes para seus respectivos nomes.


O Aprendizado Por Reforço depende do ambiente para enviar a ele um número escalar em resposta a cada nova ação. As recompensas retornadas pelo ambiente podem ser variadas, atrasadas ou afetadas por variáveis ​​desconhecidas, introduzindo ruído no loop de feedback. Isso nos leva a uma expressão mais completa da função Q, que leva em consideração não apenas as recompensas imediatas produzidas por uma ação, mas também as recompensas atrasadas que podem ser retornadas várias vezes mais fundo na sequência.


Como seres humanos, a função Q é recursiva. Chamar a função Q em um determinado par de estado-ação exige que chamemos uma função Q aninhada para prever o valor do próximo estado, que por sua vez depende da função Q do estado seguinte e assim por diante.


Continue acompanhando os próximos capítulos.


Referências:


[Inteligência Artificial Aplicada a Finanças](https://www.datascienceacademy.com.br/course/inteligencia-artificial-aplicada-financas)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[A Beginner’s Guide to Deep Reinforcement Learning](https://pathmind.com/wiki/deep-reinforcement-learning#define)


[What is reinforcement learning? The complete guide](https://deepsense.ai/what-is-reinforcement-learning-the-complete-guide/)


[Reinforcement learning](https://www.geeksforgeeks.org/what-is-reinforcement-learning/)


[Applications of Reinforcement Learning in Real World](https://towardsdatascience.com/applications-of-reinforcement-learning-in-real-world-1a94955bcd12)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-66---algoritmo-de-agente-baseado-em-ia-com-reinforcement-learning---parte-1"></div>

# Capítulo 66 – Algoritmo de Agente Baseado em IA com Reinforcement Learning – Parte 1


O Aprendizado por Reforço (Reinforcement Learning) é uma abordagem computacional para entender e automatizar aprendizado direcionado e tomada de decisão. Distingue-se de outras abordagens por sua ênfase na aprendizagem de um agente a partir da interação direta com seu ambiente, sem exigir supervisão ou modelos completos do ambiente. 


Em nossa opinião, a Aprendizado por Reforço é o primeiro campo a abordar seriamente problemas computacionais que surgem ao aprender com a interação com um ambiente para atingir objetivos de longo prazo. É um dos métodos mais avançados em Inteligência Artificial.  




O Aprendizado por Reforço usa a estrutura formal dos Processos de Decisão de Markov para definir a interação entre um agente de aprendizagem e seu ambiente em termos de estados, ações e recompensas. Essa estrutura pretende ser uma maneira simples de representar características essenciais do problema de Inteligência Artificial. Esses recursos incluem uma sensação de causa e efeito, um senso de incerteza e não-determinismo, e a existência de metas explícitas. Algo muito similar ao aprendizado humano.  




Os conceitos de valor e função de valor são essenciais para a maior parte dos métodos de Aprendizado por Reforço. Assumimos a posição de que a função de valor é importante para a pesquisa eficiente no espaço das políticas. O uso de funções de valor distingue os métodos de Aprendizado por Reforço dos métodos evolutivos que buscam diretamente no espaço de políticas orientado por avaliações de políticas inteiras.


Para ilustrar a ideia geral do Aprendizado por Reforço, vamos descrever um algoritmo (conjunto de etapas) que implementa o que seria um agente baseado em IA usando essa técnica. Passaremos por cada detalhe do algoritmo, inclusive alguns detalhes matemáticos. A construção de um algoritmo é a primeira parte do trabalho de construção de uma aplicação de [Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia). Vamos usar o contexto de um jogo, para que o exemplo fique ainda mais claro. Mas o processo descrito aqui não é muito diferente de um agente de carro autônomo, por exemplo.


Muitos se preocupam apenas com a programação, sem compreender que existe um raciocínio lógico antes disso, que determina como deve ser a solução a ser implementada. Esse raciocínio lógico pode ser descrito em etapas, o que chamados de algoritmo. Isso é o que queremos praticar com você agora.


### Algoritmo de um Agente Baseado em IA


Considere o famoso Jogo da Velha. 


![jogo_da_velha](https://www.deeplearningbook.com.br/wp-content/uploads/2020/02/jogo_da_velha-300x267.png)


Dois jogadores revezam-se jogando em um tabuleiro de três por três, conforme a figura acima. Um jogador joga Xs e o outro OS até que um jogador ganhe colocando três marcas em uma fileira, horizontal, vertical ou diagonal. Se o tabuleiro estiver totalmente preenchido e nenhum jogador conseguir três marcas, então o jogo fica empatado. 


Vamos assumir que estamos jogando contra um jogador imperfeito, aquele cujo jogo às vezes está incorreto e nos permite vencer. Por enquanto, consideremos empates e perdas igualmente ruins para nós. Como podemos construir um agente de IA que encontrará as imperfeições no jogo de seu oponente e aprenderá a maximizar sua chances de ganhar?


Embora este seja um problema simples, ele não pode ser facilmente resolvido de maneira satisfatória. através de técnicas clássicas. Por exemplo, a solução clássica “[minimax](https://en.wikipedia.org/wiki/Minimax)” da Teoria dos Jogos, não seria ideal aqui porque assume uma maneira particular de jogar pelo oponente. Por exemplo, um jogador minimax nunca chegaria a um estado de jogo do qual poderia perder, mesmo que, de fato, sempre tenha saído desse estado por causa de jogo incorreto do oponente. 


Métodos clássicos de otimização para problemas de decisão sequenciais, como programação dinâmica, poderiam calcular uma solução ideal para qualquer oponente, mas exige como entrada, uma especificação completa desse oponente, incluindo as probabilidades com as quais o oponente faz cada jogada em cada estado do tabuleiro. Vamos supor que esta informação não está disponível a priori para esse problema, pois não existe para a grande maioria dos problemas de interesse prático. 


Por outro lado, essas informações podem ser estimadas a partir da experiência, neste caso, jogando muitos jogos contra o oponente. O melhor que se pode fazer sobre esse problema é primeiro aprender um modelo do comportamento do oponente, até algum nível de confiança e, em seguida, aplicar a programação dinâmica para calcular uma solução ideal o modelo aproximado do oponente. No final, isso não é tão diferente de alguns dos métodos de aprendizado por reforço.


Um método evolutivo aplicado a esse problema pesquisaria diretamente o espaço de políticas possíveis para alguém com alta probabilidade de vencer o oponente. Aqui, uma política é uma regra que informa ao agente o que fazer para cada estado do jogo – todas as configurações possíveis de Xs e Os no tabuleiro três por três. Para cada política considerada, uma estimativa de sua probabilidade de vitória seria obtida jogando algum número de jogos contra o oponente. Essa avaliação direcionaria então quais políticas devem ser consideradas a seguir. 


Um método evolutivo típico escalaria no espaço de políticas, gerando e avaliando sucessivamente políticas na tentativa de obter melhorias incrementais. Ou, talvez, um algoritmo genético possa ser usado para manter e avaliar uma população de políticas. Literalmente centenas de diferentes métodos de otimização podem ser aplicados.


Uma função de valor poderia ser um método eficaz nesse cenário. Aqui está como o problema do jogo da velha seria tratado com um método que faz uso de uma função de valor. 


Primeiro, montaríamos uma tabela de números, uma para cada estado possível do jogo. Cada número será a estimativa mais recente da probabilidade de ganharmos nesse estado. Tratamos essa estimativa como o valor do estado, e toda a tabela é a função de valor aprendido. O estado A tem um valor mais alto que o estado B ou é considerado “melhor” do que o estado B, se a estimativa atual da probabilidade de ganharmos em A for maior do que em B. Supondo que sempre jogamos Xs, então para todos os estados com três Xs seguidos a probabilidade de ganhar é 1, porque já vencemos. 


Da mesma forma, para todos os estados com três Os seguidos ou preenchidos, a probabilidade correta é 0, pois não podemos ganhar com eles. Definimos os valores iniciais de todos os outros estados para 0,5, representando que temos 50% de chance de ganhar.


Em seguida, jogamos muitos jogos contra o oponente. Para selecionar nossos movimentos, examinamos os estados que resultariam de cada um de nossos movimentos possíveis (um para cada espaço em branco no tabuleiro) e procuramos seus valores atuais na tabela. Na maioria das vezes nos movemos avidamente, selecionando o movimento que leva ao estado com maior valor, ou seja, com o maior valor de probabilidade estimada de vitória. Ocasionalmente, no entanto, selecionamos um movimento aleatoriamente. Estes são chamados movimentos exploratórios porque nos levam a ter uma experiência que, de outra forma, jamais poderíamos ter. Uma sequência de movimentos feitos e considerados durante um jogo podem ser diagramados como na figura abaixo:


![agente](https://www.deeplearningbook.com.br/wp-content/uploads/2020/02/agente-1024x918.png)


Poderíamos usar Deep Learning para realizar parte do aprendizado do processo descrito anteriormente e alimentar o agente com o resultado desse aprendizado. Isso é o que chamamos de Deep Reinforcement Learning.


Reinforcement Learning e Deep Reinforcement Learning são estudados na prática em [Inteligência Artificial Aplicada a Finanças](https://www.datascienceacademy.com.br/course/inteligencia-artificial-aplicada-financas). Muitos robôs investidores usam Aprendizado por Reforço como técnica principal.


Continuaremos na parte 2. Acompanhe o próximo capítulo. 


Referências:


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[A Beginner’s Guide to Deep Reinforcement Learning](https://pathmind.com/wiki/deep-reinforcement-learning#define)


[What is reinforcement learning? The complete guide](https://deepsense.ai/what-is-reinforcement-learning-the-complete-guide/)


[Reinforcement learning](https://www.geeksforgeeks.org/what-is-reinforcement-learning/)


[Reinforcement Learning, Second Edition](https://mitpress.mit.edu/books/reinforcement-learning-second-edition)


[Applications of Reinforcement Learning in Real World](https://towardsdatascience.com/applications-of-reinforcement-learning-in-real-world-1a94955bcd12)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-67---algoritmo-de-agente-baseado-em-ia-com-reinforcement-learning---parte-2"></div>

# Capítulo 67 – Algoritmo de Agente Baseado em IA com Reinforcement Learning – Parte 2


Vamos continuar nosso estudo sobre o Algoritmo de Agente Baseado em IA com Reinforcement Learning e compreender mais alguns detalhes importantes.


Aprendizado por Reforço (Reinforcement Learning) refere-se a um tipo de método de Aprendizado de Máquina (Machine Learning) no qual o agente recebe uma recompensa atrasada na próxima etapa para avaliar sua ação anterior. Recentemente, à medida que o algoritmo evolui com a combinação de redes neurais artificiais, ele é capaz de resolver tarefas mais complexas.


Embora exista um grande número de algoritmos de Aprendizado por Reforço, não parece haver uma comparação abrangente entre cada um deles. Quais algoritmos seriam aplicados a uma tarefa específica? Este capítulo tem como objetivo resolver esse problema discutindo brevemente a configuração da Aprendizado por Reforço e fornecendo uma introdução para alguns dos algoritmos conhecidos.


Componentes do Aprendizado Por Reforço
--------------------------------------


Vamos relembrar os componentes do Aprendizado Por Reforço:


**Ação (A)**: Todos os movimentos possíveis que o agente pode executar


**Estado (S)**: Situação atual retornada pelo ambiente.


**Recompensa (R)**: Um retorno imediato é enviado do ambiente para avaliar a última ação.


**Política (π)**: A estratégia que o agente emprega para determinar a próxima ação com base no estado atual.


**Valor (V)**: O retorno esperado a longo prazo com desconto, em oposição à recompensa de curto prazo R. Vπ (s) é definido como o retorno esperado a longo prazo da atual política de desdobramento de estados π.


**Valor Q ou Valor da Ação (Q)**: O valor Q é semelhante ao Valor, exceto pelo fato de ser necessário um parâmetro extra, a ação atual a. Qπ (s, a) refere-se ao retorno a longo prazo do estado atual s, realizando uma ação sob a política π.


Agora vamos compreender quais são os principais tipos de algoritmos usados em Aprendizado Por Reforço.


Model-free v.s. Model-based
---------------------------


O modelo representa a simulação da dinâmica do ambiente. Ou seja, o modelo aprende a probabilidade de transição T (s1 | (s0, a)) a partir do par de estado atual s0 e a ação a para o próximo estado s1. Se a probabilidade de transição for detectada com êxito, o agente saberá qual a probabilidade de entrar em um estado específico, dado o estado e a ação atuais. 


No entanto, algoritmos baseados em modelo se tornam impraticáveis à medida que o espaço de estado e o espaço de ação aumentam (S \* S \* A, para uma configuração tabular).


Por outro lado, algoritmos sem modelo (Model-free) dependem de tentativa e erro para atualizar seu conhecimento. Como resultado, ele não requer espaço para armazenar toda a combinação de estados e ações. Em geral, os algoritmos desse tipo obtém resultados bem superiores, mas são mais complexos de programar.


On-policy v.s. Off-policy
-------------------------


Um agente on-policy aprende o valor com base em sua ação atual **a** derivada da política atual, enquanto sua contraparte off-policy o aprende com base na ação **a**\* obtida de outra política. No Q-learning, essa política é a política gananciosa (falaremos mais sobre isso em Q-learning).


Abordagens Para Um Algoritmo de Aprendizado por Reforço
-------------------------------------------------------


Existem três abordagens para implementar um algoritmo de Aprendizado por Reforço (Reinforcement Learning):


### Baseado em Valor


Em um método de Aprendizado por Reforço baseado em valor, você deve tentar maximizar uma função de valor V (s). Nesse método, o agente espera um retorno a longo prazo dos estados atuais sob a política π.


### Baseado em Políticas


Em um método de Aprendizado por Reforço baseado em política, você tenta criar uma política em que a ação executada em todos os estados ajude o agente a obter a recompensa máxima no futuro. Esse método tem dois sub-tipos:


* Determinístico: Para qualquer estado, a mesma ação é produzida pela política π.
* Estocástico: Toda ação tem uma certa probabilidade.


### Baseado em Modelo


Neste método de Aprendizado por Reforço, você precisa criar um modelo virtual para cada ambiente. O agente aprende a atuar nesse ambiente específico.


Modelos de Aprendizagem de Reforço
----------------------------------


Além escolher uma ou mais das abordagens acima mencionadas, precisamos definir o modelo de Aprendizado por Reforço. Existem três modelos de aprendizagem importantes amplamente usados em Reinforcement Learning:


### Processo de Decisão de Markov


Nesse processo de aprendizagem do agente, os seguintes parâmetros são usados para obter uma solução:


* Conjunto de ações – A
* Conjunto de estados – S
* Recompensa – R
* Política – n
* Valor – V


A abordagem matemática para mapear uma solução no Aprendizado por Reforço é reconhecido como um Processo de Decisão de Markov (MDP).


![MDP](https://www.deeplearningbook.com.br/wp-content/uploads/2020/03/MDP.png)


### Q-Learning


Q-Learning é um método baseado em valor de fornecer informações para informar qual ação um agente deve executar.


Vamos entender esse método pelo seguinte exemplo simples, no qual o agente inteligente deve aprender a chegar à porta de saída (porta 5):


* Há cinco quartos em um prédio que são conectados por portas.
* Cada quarto é numerado de 0 a 4.
* A parte externa do edifício pode ser uma grande área externa (5).
* As portas número 1 e 4 levam ao prédio a partir da sala 5.


![q-learning](https://www.deeplearningbook.com.br/wp-content/uploads/2020/03/q-learning-1024x347.png)


Em seguida, você precisa associar um valor de recompensa a cada porta:


1. As portas que levam diretamente ao objetivo recebem uma recompensa de 100.
2. Portas que não estão diretamente conectadas à sala de destino não oferecem recompensa.
3. Como as portas são de mão dupla, duas setas são atribuídas para cada quarto.
4. Cada seta na imagem acima contém um valor de recompensa instantâneo.


Explicação:


Nesta imagem, você pode ver que a sala representa um estado. O movimento do agente de uma sala para outra representa uma ação. Um estado é descrito como um nó, enquanto as setas mostram a ação.


![q-learning2](https://www.deeplearningbook.com.br/wp-content/uploads/2020/03/q-learning2.png)


Por exemplo, um agente deve aprender a passar da porta 2 a porta 5. Aqui seriam as opções:


Estado inicial = estado 2  

Estado 2-> estado 3  

Estado 3 -> estado (2,1,4)  

Estado 4-> estado (0,5,3)  

Estado 1-> estado (5,3)  

Estado 0-> estado 4


Como são várias possibilidades, nosso algoritmo deve recompensar aquelas que levam ao destino da forma mais rápida e penalizar aquelas que não levam. O agente então vai experimentando as possibilidades e criando uma tabela com o que traz recompensa e o que não traz. Se o aprendizado for bem sucedido o agente aprenderá o melhor conjunto de ações que leva ao destino.


Deep Q Network (DQN)
--------------------


Embora o Q-learning seja um algoritmo muito poderoso, sua principal fraqueza é a falta de generalidade. Se você visualizar o Q-learning como números de atualização em uma matriz bidimensional (Espaço de Ação \* Espaço de Estado), ele se parecerá com a programação dinâmica. Isso indica que, para os estados que o agente de Q-learning não viu antes, não tem ideia de qual ação executar. Em outras palavras, o agente de Q-learning não tem a capacidade de estimar valor para estados invisíveis. Para lidar com esse problema, o DQN se livra da matriz bidimensional introduzindo a Rede Neural Artificial Profunda (Deep Learning).


O DQN utiliza uma rede neural para estimar a função de valor Q. A entrada para a rede é a corrente, enquanto a saída é o valor Q correspondente a cada ação.


![atari](https://www.deeplearningbook.com.br/wp-content/uploads/2020/03/atari.png)


Em 2013, o DeepMind aplicou o DQN ao jogo Atari, conforme ilustrado na figura acima. A entrada é a imagem bruta da situação atual do jogo, que passa por várias camadas, incluindo a camada convolucional e a camada totalmente conectada. A saída é o valor Q para cada uma das ações que o agente pode executar.


Deep Deterministic Policy Gradient (DDPG)
-----------------------------------------


Embora o DQN tenha alcançado grande sucesso em problemas dimensionais mais altos, como o jogo Atari, o espaço de ação ainda é discreto. No entanto, muitas tarefas de interesse, especialmente tarefas de controle físico, o espaço de ação é contínuo. Se você discretizar muito bem o espaço de ação, acabará tendo um espaço de ação muito grande. Por exemplo, suponha que o grau de sistema aleatório livre seja 10. Para cada grau, você divide o espaço em 4 partes. Você acaba tendo 4¹⁰ = 1048576 ações. Também é extremamente difícil convergir para um espaço de ação tão grande.


O DDPG conta com a arquitetura ator-crítico com dois elementos de mesmo nome, ator e crítico. Um ator é usado para ajustar o parâmetro ? para a função de política, ou seja, decidir a melhor ação para um estado específico.


O DDPG também empresta as ideias de repetição da experiência e separação da rede de destino, do DQN. Um problema do DDPG é que ele raramente realiza exploração de ações. Uma solução para isso é adicionar ruído no espaço de parâmetros ou no espaço de ação.


Como o objetivo deste livro é abordar principalmente Deep Learning, nos próximos capítulos estudaremos os algoritmos que empregam Deep Learning, o que chamamos de Deep Reinforcement Learning, talvez um dos métodos de IA mais avançados da atualidade. O método jé é estudado na DSA no curso de [Inteligência Artificial Aplicada a Finanças](https://www.datascienceacademy.com.br/course/inteligencia-artificial-aplicada-financas), para otimização de portfólios financeiros e robôs investidores baseados em IA.


Estudar e aprender tem um efeito interessante: nos fazem mais humildes. Quando uma pessoa é muito arrogante, ela em geral é vazia em termos de conteúdo, pois arrogância é sinal de ignorância, falta de conhecimento. Quanto mais aprendemos, mais humildes ficamos, pois percebemos que o aprendizado é um ato contínuo e que temos muito, muito a aprender. Passamos a ver o mundo com outros olhos. Por isso estudar é transformador.


Até o próximo capítulo.


Referências:


[Formação Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-machine-learning)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[A Beginner’s Guide to Deep Reinforcement Learning](https://pathmind.com/wiki/deep-reinforcement-learning#define)


[Reinforcement Learning: What is, Algorithms, Applications, Example](https://www.guru99.com/reinforcement-learning-tutorial.html)


[What is reinforcement learning? The complete guide](https://deepsense.ai/what-is-reinforcement-learning-the-complete-guide/)


[Reinforcement Learning algorithms — an intuitive overview](https://medium.com/@SmartLabAI/reinforcement-learning-algorithms-an-intuitive-overview-904e2dff5bbc)


[Reinforcement learning](https://www.geeksforgeeks.org/what-is-reinforcement-learning/)


[Reinforcement Learning, Second Edition](https://mitpress.mit.edu/books/reinforcement-learning-second-edition)


[Applications of Reinforcement Learning in Real World](https://towardsdatascience.com/applications-of-reinforcement-learning-in-real-world-1a94955bcd12)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-68---algoritmo-de-agente-baseado-em-ia-com-reinforcement-learning---q-learning"></div>

# Capítulo 68 – Algoritmo de Agente Baseado em IA com Reinforcement Learning – Q-Learning


O Q-learning é um algoritmo de Aprendizado Por Reforço que busca encontrar a melhor ação a ser tomada, dado o estado atual. É considerado *off-policy* porque a função q-learning aprende com ações que estão fora da política atual, como executar ações aleatórias. Mais especificamente, o q-learning busca aprender uma política que maximize a recompensa total.


O ‘q’ no q-learning significa qualidade. A qualidade, neste caso, representa a utilidade de uma determinada ação para obter alguma recompensa futura.


Esse é um dos algoritmos mais usados em Aprendizado Por Reforço, o qual vamos estudar agora. É amplamente empregado em robótica, automação de games e robôs investidores na bolsa de valores.


Algoritmo Q-Learning
--------------------


Q-learning é um algoritmo de aprendizado baseado em valor. Os algoritmos baseados em valor atualizam a função de valor com base em uma equação (particularmente a equação de Bellman). Enquanto o outro tipo, baseado em políticas, estima a função de valor com uma política gananciosa obtida a partir do último aprimoramento da política.


Funções de valor são funções de par de ação de estado que estimam quão boa será uma ação específica em um determinado estado ou qual o retorno esperado para essa ação.


O Q-Learning é um algoritmo off-policy (pode atualizar as funções de valor estimado usando ações hipotéticas, aquelas que ainda não foram tentadas) para o aprendizado da diferença temporal (método para estimar as funções de valor). Pode-se provar que, com treinamento suficiente, o Q-learning converge com a probabilidade 1 para uma aproximação da função de valor da ação para uma política de destino arbitrária. O Q-Learning aprende a política ideal, mesmo quando as ações são selecionadas de acordo com uma política mais exploratória ou até aleatória. O Q-learning pode ser implementado da seguinte maneira:


![q-learning](https://www.deeplearningbook.com.br/wp-content/uploads/2020/03/q-learning-1-1024x308.png)


Onde:


* s: é o estado anterior.
* a: é a ação anterior.
* Q (): é o algoritmo Q-learning.
* s ‘: é o estado atual.
* alfa: é a taxa de aprendizado, definida geralmente entre 0 e 1. A configuração para 0 significa que os valores Q nunca são atualizados; portanto, nada é aprendido. Definir alfa como um valor alto, como 0,9, significa que o aprendizado pode ocorrer rapidamente.
* gama: é o fator de desconto, também definido entre 0 e 1. Isso modela o fato de que recompensas futuras valem menos que recompensas imediatas.
* max: é a recompensa máxima que é alcançável no estado após o atual (a recompensa por executar a ação ideal posteriormente).


O algoritmo pode ser interpretado como:


* Inicialize a tabela de valores Q, **Q (s, a)**.
* Observe o estado atual, s.
* Escolha uma ação, a, para esse estado com base na política de seleção.
* Tome a ação e observe a recompensa, r, bem como o novo estado, s ‘.
* Atualize o valor Q para o estado usando a recompensa observada e a recompensa máxima possível para o próximo estado.
* Defina o estado para o novo estado e repita o processo até que um estado terminal seja alcançado.


Aqui o algoritmo:


![algoritmo](https://www.deeplearningbook.com.br/wp-content/uploads/2020/03/algoritmo-1.png)


A próxima etapa para o agente é interagir com o ambiente e fazer atualizações nos pares de estado e ação em nossa tabela q: Q [estado, ação].


### Explore ou Exploit


Um agente interage com o ambiente com 1 de 2 maneiras possíveis. 


A primeira é usar a tabela q como referência e visualizar todas as ações possíveis para um determinado estado. O agente seleciona a ação com base no valor máximo dessas ações. Isso é conhecido como ***Exploit***, pois usamos as informações que temos disponíveis para tomar uma decisão.


A segunda maneira é agir aleatoriamente. Isso é chamado de ***Explore***. Em vez de selecionar ações com base na recompensa máxima futura, selecionamos uma ação aleatoriamente. A ação aleatória é importante porque permite ao agente explorar e descobrir novos estados que, de outra forma, não podem ser selecionados durante o processo de Exploit. Você pode equilibrar a Exploit / Explore usando o parâmetro épsilon (ε) e definindo o valor de quantas vezes deseja fazer Exploit versus Explore. 


Quer criar um agente inteligente baseado em Aprendizado Por Reforço usando o algoritmo Q-Learning em Python?


Então não perca o próximo capítulo.


Referências:


[Formação Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-machine-learning)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[A Beginner’s Guide to Deep Reinforcement Learning](https://pathmind.com/wiki/deep-reinforcement-learning#define)


[Reinforcement Learning: What is, Algorithms, Applications, Example](https://www.guru99.com/reinforcement-learning-tutorial.html)


[What is reinforcement learning? The complete guide](https://deepsense.ai/what-is-reinforcement-learning-the-complete-guide/)


[Reinforcement Learning algorithms — an intuitive overview](https://medium.com/@SmartLabAI/reinforcement-learning-algorithms-an-intuitive-overview-904e2dff5bbc)


[Reinforcement learning](https://www.geeksforgeeks.org/what-is-reinforcement-learning/)


[Reinforcement Learning, Second Edition](https://mitpress.mit.edu/books/reinforcement-learning-second-edition)


[Applications of Reinforcement Learning in Real World](https://towardsdatascience.com/applications-of-reinforcement-learning-in-real-world-1a94955bcd12)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-69---treinando-um-agente-baseado-em-ia-para-jogar-box-no-atari-usando-linguagem-python"></div>

# Capítulo 69 – Treinando Um Agente Baseado em IA Para Jogar Box no Atari Usando Linguagem Python


Esta aula considera que você possui conhecimento em Linguagem Python. Se esse não for o caso, acesse nosso curso gratuito e comece aprender agora mesmo: [Python Fundamentos Para Análise de Dados.](https://www.datascienceacademy.com.br/cursosgratuitos)


Consideramos ainda que você já estudou os capítulos anteriores do Deep Learning Book.


Nesta aula vamos desenvolver um agente inteligente em Python usando o algoritmo Q-Learning. O método de aprendizado será a Aprendizagem Por Reforço que estudamos nos capítulos anteriores do livro. 


Nosso objetivo será Treinar Um Agente Baseado em IA Para Jogar Box no Atari (se você é mais jovem, pode não saber o que é o Atari. Ele marcou toda uma geração e podemos considerar como sendo o avô dos consoles de video game atuais. Mais detalhes [aqui](https://en.wikipedia.org/wiki/Atari_2600).)


![atari](https://www.deeplearningbook.com.br/wp-content/uploads/2020/04/atari-1024x973.png)


O desenvolvimento completo está no Jupyter Notebook que publicamos no Google Colab e tem acesse gratuito de qualquer computador conectado a internet no Planeta Terra. Mas para acessar o Google Colab você vai precisar de uma conta gratuita com o Google. 


Clique no botão abaixo para acessar o Google Colab com o Jupyter Notebook e se for necessário a criação da conta o Google vai notificar você:


 


[![Google Colab](https://www.deeplearningbook.com.br/wp-content/uploads/2020/04/colab.png)](https://colab.research.google.com/drive/1fhTBa71rdxAzvo5CV_ipfTepPVNOmtoj)


 


O Jupyter Notebook está em modo de somente leitura, pois está na conta da DSA. Para executar na sua conta, clique no menu File e salve uma cópia ou apenas execute no modo Playground clicando no botão na parte superior.


**Esse Jupyter Notebook é um “caderno” completo de conhecimento, com fórmulas, definições, links e, claro, código Python.**


Você pode estar se perguntando: Como treinar um agente baseado em IA para jogar Box pode ajudar no aprendizado de Inteligência Artificial? Sua pergunta faz sentido. A questão é que as técnicas aprendidas nesse exemplo são usadas em aplicações mais avançadas, como por exemplo o robô de otimização de portfólios que ensinamos no curso de IA Aplicada a Finanças. Antes de aprender a correr, é preciso aprender a andar. Comece com o jogo e tudo fará cada vez mais sentido.


Estude, aprenda e divirta-se! Algumas aplicações comerciais de IA de última geração usam as técnicas que você encontra no trabalho deste e dos próximos capítulos.


No Capítulo 70 terá algo ainda mais interessante.


Referências:


[Formação Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Formação Análise Estatística](https://www.datascienceacademy.com.br/bundle/formacao-analise-estatistica)


[Formação Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados)


<div id="capitulo-70---deep-q-network-e-processos-de-decisao-de-markov"></div>

# Capítulo 70 – Deep Q-Network e Processos de Decisão de Markov


Nos capítulos anteriores estudamos os fundamentos do Aprendizado Por Reforço. Agora podemos subir mais alguns degraus e estudar uma evolução dessa fascinante técnica de aprendizado de máquina que une Deep Learning e Aprendizado Por Reforço: Deep Q-Network.


Acompanhe a leitura com atenção e na próxima aula traremos uma aplicação prática desse modelo de aprendizagem profunda.


O Processo
----------


O processo de Q-Learning cria uma matriz (tabela) exata para o agente a qual ele “consulta” para maximizar sua recompensa a longo prazo durante seu aprendizado. Embora essa abordagem não seja errada por si só, é prática apenas para ambientes muito pequenos e rapidamente perde a viabilidade quando o número de estados e ações no ambiente aumenta.


A solução para o problema acima vem da constatação de que os valores na matriz têm apenas importância relativa, ou seja, os valores têm importância apenas em relação aos outros valores. Assim, esse pensamento nos leva a Deep Q-Network, que usa uma rede neural profunda para aproximar os valores. Essa aproximação de valores não prejudica desde que a importância relativa seja preservada. Ou seja, substituímos a Q Table no processo Q-Learning por um modelo de Deep Learning para o aprendizado dos valores Q. Por isso Deep Q-Network também é chamada de Deep Q-Learning.


A etapa básica de trabalho da Deep Q-Network é que o estado inicial seja alimentado na rede neural e retorne o valor Q de todas as ações possíveis, como na saída.


A diferença entre Q-Learning e Deep Q-Learning pode ser ilustrada da seguinte maneira:


 


**Q-learning Usa uma Q Matrix (ou Q Table)**


![q-learning](https://www.deeplearningbook.com.br/wp-content/uploads/2020/05/q-learning.png)


 


**Deep Q-learning substitui a Q Matrix por uma rede neural profunda (Deep Learning):**


![Deep-Q-Learning](https://www.deeplearningbook.com.br/wp-content/uploads/2020/05/Deep-Q-Learning.png)


 


Vamos compreender as vantagens em usar Dep Q-Learning.


Definindo o Mundo
-----------------


Uma tarefa de aprendizado por reforço é o treinamento de um agente que interage com seu ambiente. O agente faz a transição entre diferentes cenários do ambiente, chamados de estados, executando ações. As ações, em troca, geram recompensas, que podem ser positivas, negativas ou zero. O único objetivo do agente é maximizar a recompensa total que ele recebe sobre um episódio, que é tudo o que acontece entre um estado inicial e um estado terminal. Por isso, reforçamos o agente para executar determinadas ações, oferecendo-lhe recompensas positivas, e afastando-o de outras ações, fornecendo-lhe recompensas negativas. É assim que um agente aprende a desenvolver uma estratégia ou política.


Tome o Super Mario como exemplo: Mario é o agente que interage com o mundo (o ambiente). Os estados são exatamente o que vemos na tela, e um episódio é um nível: o estado inicial é como o nível começa e o estado terminal é como o nível termina, se o concluímos ou perecemos enquanto tentávamos. As ações avançam, retrocedem, saltam, etc. As recompensas são dadas dependendo do resultado das ações: quando Mario coleta moedas ou bônus, recebe uma recompensa positiva e, quando cai ou é atingido por um inimigo, recebe uma recompensa negativa . Quando Mario apenas anda em frente, a recompensa que recebe é zero, como se dissesse “você não fez nada de especial”.


 


![super-mario](https://www.deeplearningbook.com.br/wp-content/uploads/2020/05/super-mario-1024x576.jpg)


 


Mas há um problema aqui: para poder receber recompensas, algumas ações “não especiais” são necessárias – é preciso caminhar em direção às moedas antes de poder recebê-las. Portanto, um agente deve aprender a lidar com recompensas adiadas, aprendendo a vinculá-las às ações que realmente as causaram. Essa é a característica mais fascinante no aprendizado por reforço.


Processos de Decisão de Markov
------------------------------


Cada estado em que o agente se encontra é uma conseqüência direta do estado anterior e da ação escolhida. O estado anterior também é uma consequência direta do que veio antes dele, e assim por diante até chegarmos ao estado terminal. Cada uma dessas etapas, e sua ordem, retém informações sobre o estado atual – e, portanto, têm efeito direto sobre qual ação o agente deve escolher a seguir. Mas há um problema óbvio aqui: quanto mais avançamos, mais informações o agente precisa para salvar e processar a cada passo necessário. Isso pode facilmente chegar ao ponto em que é simplesmente inviável realizar cálculos.


Para resolver isso, assumimos que todos os estados são Markov; isto é – assumimos que qualquer estado depende unicamente do estado que veio antes dele e da transição desse estado para o atual (a ação executada e a recompensa dada). Vamos ver um exemplo – veja estes dois jogos Tic Tac Toe (o famoso Jogo da Velha):


 


![tic](https://www.deeplearningbook.com.br/wp-content/uploads/2020/05/tic-1024x409.jpeg)


 


Ambos os jogos atingiram o mesmo estado, mas de maneiras diferentes. Ainda assim, em ambos os casos, o jogador azul deve capturar a célula superior direita, ou ele perderá. Tudo o que precisávamos para determinar esse estado era o último estado, nada mais.


É importante lembrar que, ao usar a suposição de Markov, dados estão sendo perdidos – em jogos complexos como Chess ou Go, a ordem dos movimentos pode ter algumas informações implícitas sobre a estratégia ou o modo de pensar do oponente. Ainda assim, a suposição de Markov é fundamental quando se tenta calcular estratégias de longo prazo.


A Equação de Bellman
--------------------


Vamos seguir em frente e desenvolver nossa primeira estratégia. Considere o caso mais simples: suponha que já sabemos qual é a recompensa esperada para cada ação em cada etapa. Como vamos escolher uma ação neste caso? Simplesmente – escolheremos a sequência de ações que eventualmente gerará a maior recompensa. Essa recompensa cumulativa que receberemos é frequentemente referida como Q Value (uma abreviação de Quality Value) e podemos formalizar matematicamente nossa estratégia como:


![bellman](https://www.deeplearningbook.com.br/wp-content/uploads/2020/05/bellman-1024x112.png)


A equação acima afirma que o valor Q produzido por estar no estado s e selecionar a ação a é a recompensa imediata recebida, r (s, a), mais o valor Q mais alto possível do estado s’ (que é o estado em que chegamos depois de executar a ação a dos estados). Receberemos o valor Q mais alto de s’ escolhendo a ação que maximiza o valor Q. Também apresentamos γ, geralmente chamado de fator de desconto, que controla a importância das recompensas de longo prazo versus as imediatas.


Essa equação é conhecida como Equação de Bellman, e sua página na Wikipedia fornece uma explicação abrangente de sua derivação matemática. Essa equação elegante é bastante poderosa e é muito útil devido a duas características importantes:


1. Enquanto ainda mantemos as suposições dos estados de Markov, a natureza recursiva da Equação de Bellman permite que as recompensas dos estados futuros se propaguem para estados passados ​​longínquos.
2. Não é necessário saber realmente quais são os verdadeiros valores Q quando começamos; Desde a sua recursividade, podemos adivinhar algo, e eventualmente convergirá para os valores reais.


Q-Learning
----------


Agora temos uma estratégia básica – em qualquer estado, execute a ação que acabará gerando a maior recompensa acumulada. Algoritmos como esse são chamados gananciosos, por uma razão óbvia.


Como implementaríamos isso para resolver os desafios da vida real? Uma maneira é desenhar uma tabela para armazenar todas as combinações possíveis de ação e estado e usá-la para salvar os valores Q. Podemos então atualizá-la usando a Equação de Bellman como regra de atualização:


 


![q-learning-table](https://www.deeplearningbook.com.br/wp-content/uploads/2020/05/q-learning-table-1024x511.gif)


Mas nosso algoritmo ganancioso tem um problema sério: se você continuar selecionando as mesmas melhores ações, nunca tentará algo novo e poderá perder uma abordagem mais gratificante só porque nunca tentou (exatamente como acontece com nós seres humanos).


Para resolver isso, usamos uma abordagem ε-gananciosa: para alguns 0 < ε <1, escolhemos a ação gananciosa (usando nossa tabela) com uma probabilidade p = 1-ε, ou uma ação aleatória com probabilidade p = ε. Assim, damos ao agente a chance de explorar novas oportunidades.


Esse algoritmo é conhecido como Q-Learning e resume o que estudamos nos capítulos anteriores.


Deep Q-Networks
---------------


O que acontece quando o número de estados e ações se torna muito grande? Na verdade, isso não é tão raro – mesmo um jogo simples como o Tic Tac Toe tem centenas de estados diferentes (tente calcular isso) e não se esqueça de multiplicarmos esse número por 9, que é o número de ações possíveis. Então, como vamos resolver problemas realmente complexos?


Uma solução possível é a Deep Q-Network! Combinamos Q Learning e Deep Learning, o que gera Deep Q-Networks. A ideia é simples: substituiremos a tabela de valores Q por uma rede neural que tente aproximar os valores Q. É geralmente referido como o aproximador ou a função de aproximação e indicado como Q (s, a; θ), em que θ representa os pesos treináveis da rede.


Agora, só faz sentido usar a Equação de Bellman como a função de custo – mas o que exatamente minimizaremos? Vamos dar uma outra olhada:


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2020/05/form1-1024x112.png)


O sinal “=” marca a atribuição, mas existe alguma condição que também satisfaça uma igualdade? Bem, sim – quando o valor Q atingiu seu valor convergente e final. E esse é exatamente o nosso objetivo – para minimizar a diferença entre o lado esquerdo e o lado direito – e bingo!


 


![cost](https://www.deeplearningbook.com.br/wp-content/uploads/2020/05/cost.png)


 


Isso parece familiar? Provavelmente – é a função erro do quadrado médio (função usada em regressão linear, um dos modelos mais básicos em Machine Learning), onde o valor Q atual é a previsão (y) e as recompensas imediatas e futuras são o destino (y’):


 


![mse](https://www.deeplearningbook.com.br/wp-content/uploads/2020/05/mse-1024x112.png)


 


É por isso que Q (s’, a; θ) é geralmente referido como Q-target (a variável target em modelo tradicional de Machine Learning).


Seguindo em frente, precisamos treinar a rede. No Aprendizado por Reforço, o conjunto de treinamento é criado à medida que avançamos; pedimos ao agente para tentar selecionar a melhor ação usando a rede atual – e registramos o estado, a ação, a recompensa e o próximo estado em que ele terminou. Decidimos o tamanho de um lote b e, toda vez que novos registros de b foram gravados, selecionamos b registros aleatoriamente (!!) na memória e treinamos a rede. Os buffers de memória usados geralmente são chamados de Experience Replay. Existem vários tipos de tais memórias – uma muito comum é um buffer de memória cíclico. Isso garante que o agente continue treinando sobre seu novo comportamento, em vez de coisas que podem não ser mais relevantes.


As coisas estão ficando reais, então vamos falar sobre arquitetura: se imitar uma tabela, a rede deve receber como entrada o estado e a ação e deve gerar um valor Q:


 


![magic](https://www.deeplearningbook.com.br/wp-content/uploads/2020/05/magic.jpeg)


 


Embora correta, essa arquitetura é muito ineficiente do ponto de vista técnico. Observe que a função de custo requer o valor Q máximo futuro, portanto, precisaremos de várias previsões de rede para um único cálculo de custo. Então, em vez disso, podemos usar a seguinte arquitetura:


 


![black](https://www.deeplearningbook.com.br/wp-content/uploads/2020/05/black.jpeg)


 


Aqui, fornecemos à rede apenas os estados como entrada e recebemos valores Q para todas as ações possíveis de uma só vez. Muito melhor. E é praticamente isso. Parabéns! Você acabou de aprender sobre um dos modelos mais avançados em Inteligência Artificial. Se vem acompanhando o livro capítulo a capítulo até aqui não deve ter sido tão difícil. 


Antes de encerrarmos, aqui está algo extra: 


Alguns parágrafos atrás, comparamos a função de custo da Deep Q-Network com o erro quadrado médio. Mas o MSE compara as previsões y aos rótulos verdadeiros y’- e os rótulos verdadeiros são constantes durante todo o procedimento de treinamento. Obviamente, esse não é o caso na Deep Q-Network: y e y’ são previstos pela própria rede e, portanto, podem variar a cada iteração. O impacto é claro.


Por isso usamos a Double Deep Q-Network, que usa rótulos semi-constantes durante o treinamento. Mantemos duas cópias da rede Q, mas apenas uma está sendo atualizada – a outra permanece imóvel. De vez em quando, porém, substituímos a rede constante por uma cópia da Q Network treinada, daí a razão pela qual chamamos de “semi-constante”. 


Aqui na Data Science Academy acreditamos que a melhor maneira de entender novos conceitos é praticando e por isso nossos cursos tem um perfil prático, com projetos voltados ao mercado de trabalho e ao que as empresas precisam!


Na próxima traremos um exemplo prático da Deep Q-Network. Até lá.


Referências:


[Formação Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-machine-learning)


[Customizando Redes Neurais com Funções de Ativação Alternativas](http://www.cienciaedados.com/customizando-redes-neurais-com-funcoes-de-ativacao-alternativas/)


[A Beginner’s Guide to Deep Reinforcement Learning](https://pathmind.com/wiki/deep-reinforcement-learning#define)


[Reinforcement Learning: What is, Algorithms, Applications, Example](https://www.guru99.com/reinforcement-learning-tutorial.html)


[What is reinforcement learning? The complete guide](https://deepsense.ai/what-is-reinforcement-learning-the-complete-guide/)


[Qrash Course: Reinforcement Learning 101 & Deep Q Networks in 10 Minutes](https://towardsdatascience.com/qrash-course-deep-q-networks-from-the-ground-up-1bbda41d3677)


[Reinforcement Learning algorithms — an intuitive overview](https://medium.com/@SmartLabAI/reinforcement-learning-algorithms-an-intuitive-overview-904e2dff5bbc)


[Reinforcement learning](https://www.geeksforgeeks.org/what-is-reinforcement-learning/)


[Reinforcement Learning, Second Edition](https://mitpress.mit.edu/books/reinforcement-learning-second-edition)


[Applications of Reinforcement Learning in Real World](https://towardsdatascience.com/applications-of-reinforcement-learning-in-real-world-1a94955bcd12)


[Practical Recommendations for Gradient-Based Training of Deep Architectures](https://arxiv.org/pdf/1206.5533v2.pdf)


[Gradient-Based Learning Applied to Document Recognition](http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf)


[Neural Networks & The Backpropagation Algorithm, Explained](https://ayearofai.com/rohan-lenny-1-neural-networks-the-backpropagation-algorithm-explained-abf4609d4f9d)


[Recurrent neural network based language model](http://www.fit.vutbr.cz/research/groups/speech/publi/2010/mikolov_interspeech2010_IS100722.pdf)


[The Elements of Statistical Learning: Data Mining, Inference, and Prediction, Second Edition](https://www.amazon.com.br/Elements-Statistical-Learning-Prediction-Statistics-ebook/dp/B00475AS2E/ref=sr_1_1?ie=UTF8&qid=1482130176&sr=8-1&keywords=The+Elements+of+Statistical+Learning%3A+Data+Mining%2C+Inference%2C+and+Prediction%2C+Second+Edition)


[Gradient Descent For Machine Learning](https://machinelearningmastery.com/gradient-descent-for-machine-learning/)


[Pattern Recognition and Machine Learning](https://www.amazon.com.br/Pattern-Recognition-Machine-Learning-Christopher/dp/0387310738/ref=sr_1_1?ie=UTF8&qid=1482130309&sr=8-1&keywords=Pattern+Recognition+and+Machine+Learning)


<div id="capitulo-71---inteligencia-artificial-para-jogar-blackjack---parte-1"></div>

# Capítulo 71 – Inteligência Artificial Para Jogar Blackjack – Parte 1


Aprender é um dos prazeres da vida. Aprender se divertindo é melhor ainda, não acha?


A partir deste capítulo e durante os próximos vamos trabalhar em um projeto completo para estudar o Aprendizado Por Reforço na prática, especificamente a Deep Q-Network. Criaremos um Agente baseado em Inteligência Artificial para jogar Blackjack.


Eu sei que é difícil acreditar, então antes que você pergunte, já vou responder: Sim, o Projeto é inteiramente gratuito, sem custo, sem pegadinha. Ao final você terá um Assistente Virtual de IA Para Jogar Blackjack.


![Blackjack](https://www.deeplearningbook.com.br/wp-content/uploads/2020/05/imagem1-1024x571.png)


Nosso objetivo é ajudar a desenvolver e democratizar o conhecimento de Inteligência Artificial no Brasil.


Precisaremos de diversas aulas para construir o Assistente Virtual, treinar, testar e avaliar e durante as aulas vamos explorar outros temas ligados ao Aprendizado Por Reforço que estudamos nos capítulos anteriores. Não fique ansioso e aproveite a jornada, pois haverá muito conhecimento e aprendizado durante todas as aulas.


Um projeto como esse tem nível avançado, mas faremos o nosso melhor para explicar tudo bem passo a passo. Vamos começar?


Cada parte do projeto terá um Jupyter Notebook com tudo explicado passo a passo. Não precisa instalar nada no seu computador, apenas usar o ambiente em nuvem do Google Colab através de um navegador. Clique na imagem abaixo para acessar o Jupyter Notebook deste capítulo:


[![Colab](https://www.deeplearningbook.com.br/wp-content/uploads/2020/04/colab.png)](https://colab.research.google.com/drive/1LamDN9XR8-J_CmafGDuc3WaTnif2XFk8?usp=sharing)


 


O Jupyter Notebook está em modo de somente leitura, pois está na conta da DSA. Para executar na sua conta, clique no menu File e salve uma cópia ou apenas execute no modo Playground clicando no botão na parte superior.


Esse Jupyter Notebook é um “caderno” completo de conhecimento, com fórmulas, definições, links e, claro, código Python.


Referências:


[Formação Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Formação Análise Estatística](https://www.datascienceacademy.com.br/bundle/formacao-analise-estatistica)


[Formação Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados)


<div id="capitulo-72---inteligencia-artificial-para-jogar-blackjack---parte-2"></div>

# Capítulo 72 – Inteligência Artificial Para Jogar Blackjack – Parte 2


Vamos trabalhar na Parte 2 do nosso Projeto e construir o modelo Modelo Deep Q Network.


Mas não faremos “apenas” isso. Vamos criar um Plot para visualizar as jogadas do Agente Baseado em IA ao jogar Blackjack. Clique na imagem abaixo para acessar o Jupyter Notebook com o código completo.


[![](https://www.deeplearningbook.com.br/wp-content/uploads/2020/04/colab.png)](https://colab.research.google.com/drive/13H_N5hRKi6CcCJoJEg5RJJwR31euIOLC?usp=sharing)


O Jupyter Notebook está em modo de somente leitura, pois está na conta da DSA. Para executar na sua conta, clique no menu File e salve uma cópia ou apenas execute no modo Playground clicando no botão na parte superior.


Esse Jupyter Notebook é um “caderno” completo de conhecimento, com fórmulas, definições, links e, claro, código Python.


Referências:


[Formação Engenheiro de Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-machine-learning)


[Formação Linguagem Python Para Data Science](https://www.datascienceacademy.com.br/bundle/formacao-linguagem-python-para-data-science)


<div id="capitulo-73---inteligencia-artificial-para-jogar-blackjack---parte-3"></div>

# Capítulo 73 – Inteligência Artificial Para Jogar Blackjack – Parte 3


Vamos trabalhar na Parte 3 do Projeto e implementar a memória do nosso agente inteligente.


Clique na imagem abaixo para acessar o Jupyter Notebook com o código completo.


[![](https://www.deeplearningbook.com.br/wp-content/uploads/2020/04/colab.png)](https://colab.research.google.com/drive/1AJOXWF2hnsQmMGIENYZnzPLWO6d2OI5b?usp=sharing)


O Jupyter Notebook está em modo de somente leitura, pois está na conta da DSA. Para executar na sua conta, clique no menu File e salve uma cópia ou apenas execute no modo Playground clicando no botão na parte superior.


Esse Jupyter Notebook é um “caderno” completo de conhecimento, com fórmulas, definições, links e, claro, código Python.


Referências:


[Formação Engenheiro de  Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Formação Análise Estatística](https://www.datascienceacademy.com.br/bundle/formacao-analise-estatistica)


[Formação Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados)


<div id="capitulo-74---inteligencia-artificial-para-jogar-blackjack---parte-4"></div>

# Capítulo 74 – Inteligência Artificial Para Jogar Blackjack – Parte 4


Vamos trabalhar na Parte 4 do Projeto e implementar a lógica de treinamento do nosso agente inteligente.


Clique na imagem abaixo para acessar o Jupyter Notebook com o código completo.


[![](https://www.deeplearningbook.com.br/wp-content/uploads/2020/04/colab.png)](https://colab.research.google.com/drive/1snz_5tHybAIQcScsFtiMfWPuqk1CNd79?usp=sharing)


O Jupyter Notebook está em modo de somente leitura, pois está na conta da DSA. Para executar na sua conta, clique no menu File e salve uma cópia ou apenas execute no modo Playground clicando no botão na parte superior.


Esse Jupyter Notebook é um “caderno” completo de conhecimento, com fórmulas, definições, links e, claro, código Python.


Referências:


[Formação Engenheiro de Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[Formação Análise Estatística](https://www.datascienceacademy.com.br/bundle/formacao-analise-estatistica)


[Formação Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados)


<div id="capitulo-75---inteligencia-artificial-para-jogar-blackjack---parte-5"></div>

# Capítulo 75 – Inteligência Artificial Para Jogar Blackjack – Parte 5


Vamos trabalhar na Parte 5 do Projeto para treinar, avaliar e concluir nosso agente inteligente.


Clique na imagem abaixo para acessar o Jupyter Notebook com o código completo.


[![](https://i2.wp.com/deeplearningbook.com.br/wp-content/uploads/2020/04/colab.png?resize=299%2C147)](https://colab.research.google.com/drive/1LSMK3HsFoMRx17Nj7JlM8XAKA01FV65D#scrollTo=zqv4gqcGnS1c)


O Jupyter Notebook está em modo de somente leitura, pois está na conta da DSA. Para executar na sua conta, clique no menu File e salve uma cópia ou apenas execute no modo Playground clicando no botão na parte superior.


Esse Jupyter Notebook é um “caderno” completo de conhecimento, com fórmulas, definições, links e, claro, código Python.


Referências:


[Formação Engenheiro de Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-machine-learning)

<div id="capitulo-76---o-que-e-bert-(bidirectional-encoder-representations-from-transformers)?"></div>

# Capítulo 76 – O Que é BERT (Bidirectional Encoder Representations from Transformers)?


BERT (Bidirectional Encoder Representations from Transformers) é o algoritmo de aprendizado profundo (Deep Learning) do Google para PLN (Processamento de Linguagem Natural). Ajuda computadores e máquinas a entender a linguagem como nós, humanos, fazemos. Simplificando, o BERT pode ajudar o Google a entender melhor o significado das palavras nas consultas no mecanismo de busca.


Por exemplo, nas frases “quinze para as seis” e “nove para as seis”, a preposição “para” é interpretada de uma maneira diferente pelos humanos em comparação com um motor de busca que a trata como um só. O BERT permite que os mecanismos de busca entendam essas diferenças para fornecer resultados de pesquisa mais relevantes aos usuários.


Desenvolvido no ano de 2018, o BERT é um modelo pré-treinado para Processamento de Linguagem Natural, de código aberto (open-source). Agora, ele pode ser usado por qualquer pessoa para treinar seus sistemas de processamento de linguagem. Para facilitar as melhores consultas de pesquisa, ele é construído em representações contextuais de pré-treinamento, como o Transformer, ULMFiT, o transformador OpenAI, Semi-Supervised Sequence Learning e Elmo.


Um ponto importante de diferença entre o BERT e outros modelos de PLN é que é a primeira tentativa do Google de um modelo pré-treinado que é profundamente bidirecional e faz pouco uso de qualquer outra coisa além de um corpus de texto simples. Como é um modelo de código aberto, qualquer pessoa com conhecimento sólido de algoritmos de aprendizado de máquina pode usá-lo para desenvolver um modelo de PLN sem ter que integrar conjuntos de dados diferentes para treinamento de modelo, economizando recursos e dinheiro.


Outro diferencial importante em relação ao BERT é que ele foi pré-treinado em um corpus gigantesco de texto que ultrapassa 33 milhões de itens.


### O Que é Uma Rede Neural?


Conforme vimos nos capítulos deste livro, algoritmos projetados para redes neurais funcionam identificando ou reconhecendo padrões. Prever tendências globais no domínio econômico, classificar o conteúdo da imagem e identificar a caligrafia são algumas das aplicações comuns das redes neurais no mundo real. Elas empregam conjuntos de dados para reconhecimento de padrões. Na verdade, o BERT foi pré-treinado na Wikipedia que ultrapassa 2500 milhões de palavras.


### O Que é Processamento de Linguagem Natural?


O Processamento de Linguagem Natural (PLN) é um ramo da Inteligência Artificial projetado para ajudar as máquinas a entender o processo natural de comunicação dos seres humanos.


Você digita uma palavra na caixa de pesquisa do Google e uma série de sugestões aparecem. Você se comunica com chatbots de uma empresa. Todas essas comunicações são possibilitadas via PLN.


Exemplos de avanços possibilitados por PLN incluem ferramentas de escuta social, chatbots e sugestões de palavras em seu smartphone. Embora PLN não seja uma novidade para os mecanismos de pesquisa, o BERT representa um avanço no processamento de linguagem natural por meio do treinamento bidirecional.


### Como Funciona o BERT?


Vamos estudar o funcionamento do BERT em mais detalhes no capítulo seguinte, mas o BERT treina os modelos de linguagem com base no conjunto completo de palavras em uma consulta ou frase conhecida como treinamento bidirecional, enquanto os modelos de PLN tradicionais treinam os modelos de linguagem na ordem da sequência de palavras (da direita para a esquerda ou da esquerda para a direita). O BERT facilita os modelos de linguagem a discernir o contexto das palavras com base nas palavras circundantes, em vez de palavras que o seguem ou precedem.


O Google chama esse processo de “profundamente bidirecional” e com razão, pela simples razão de que o verdadeiro significado do que as palavras estão comunicando só é possível por meio de uma análise profunda da rede neural.


Por exemplo, seria difícil para uma máquina diferenciar entre a palavra “banco”, como sendo uma agência bancária, da palavra “banco”, como sendo o local para sentar em uma praça, por exemplo. O modelo contextual funciona mapeando uma representação distinta de toda a frase para entender melhor seus contextos.


### O BERT Substituiu o Algoritmo RankBrain?


RankBrain foi o primeiro algoritmo baseado em IA do Google a compreender as consultas de pesquisa e o contexto de uma palavra em uma frase. Ele usa aprendizado de máquina para fornecer os resultados de pesquisa mais relevantes para as consultas do usuário. Corresponde às consultas e ao conteúdo das páginas da web para entender melhor o contexto das palavras em uma frase. É importante compreender que o BERT não foi introduzido como um substituto do RankBrain. Na verdade, ele adiciona mais poder para que os pontos mais precisos do que o usuário está solicitando ou desejando sejam melhor compreendidos e processados. No entanto, se o Google precisa entender melhor o contexto de uma palavra, o BERT certamente se sairá melhor. O Google pode usar vários métodos para entender uma única consulta, incluindo RankBrain e BERT.


No próximo capítulo veremos um pouco dos detalhes técnicos do BERT. Até lá.


Referências:


[Processamento de Linguagem Natural com Transformers](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers)


[A Primer in BERTology: What we know about how BERT works](https://arxiv.org/abs/2002.12327)




<div id="capitulo-77---modelo-bert-para-processamento-de-linguagem-natural"></div>

# Capítulo 77 – Modelo BERT Para Processamento de Linguagem Natural


BERT (Bidirectional Encoder Representations from Transformers) é um modelo de Deep Learning criado por pesquisadores do [Google AI Language](https://arxiv.org/pdf/1810.04805.pdf). O BERT causou um rebuliço na comunidade de aprendizado de máquina ao apresentar resultados de última geração em uma ampla variedade de tarefas de PLN (Processamento de Linguagem Natural), incluindo respostas automáticas ao banco de dados de perguntas (SQuAD v1.1), inferência de linguagem natural (MNLI) e outras tarefas.


Vamos conhecer um pouco mais em detalhes o que é e como funciona o Modelo BERT Para Processamento de Linguagem Natural.


Principal Inovação
------------------


A principal inovação técnica do BERT é a aplicação do treinamento bidirecional do Transformer (um modelo de atenção) à modelagem de linguagem. Isso é diferente dos esforços anteriores que olhavam para uma sequência de texto da esquerda para a direita ou treinamento combinado da esquerda para a direita e da direita para a esquerda. Os resultados do BERT mostram que é um modelo de linguagem treinado bidirecionalmente que pode ter um senso mais profundo de contexto e fluxo de linguagem do que modelos de linguagem de direção única. No artigo original do BERT (link nas referências), os pesquisadores detalham uma nova técnica chamada Masked LM (MLM), que permite o treinamento bidirecional em modelos nos quais era impossível anteriormente.


Transfer Learning
-----------------


No campo da Visão Computacional, os pesquisadores têm mostrado repetidamente o valor da aprendizagem por transferência (Transfer Learning) – pré-treinar um modelo de rede neural em uma tarefa conhecida, por exemplo ImageNet, e depois realizar o ajuste fino – usando a rede neural treinada como base de um novo modelo de propósito específico. Nos últimos anos, pesquisadores têm mostrado que uma técnica semelhante pode ser útil em muitas tarefas de linguagem natural.


Uma abordagem diferente, que também é popular em tarefas de PLN e exemplificada no recente artigo do ELMo, é o treinamento baseado em recursos. Nesta abordagem, uma rede neural pré-treinada produz embeddings de palavras que são então usados como recursos em modelos de PLN.


Como Funciona o BERT
--------------------


O BERT faz uso do Transformer, um mecanismo de atenção que aprende as relações contextuais entre palavras (ou subpalavras) em um texto. Em sua forma original, o Transformer inclui dois mecanismos separados – um codificador que lê a entrada de texto e um decodificador que produz uma previsão para a tarefa. Como o objetivo do BERT é gerar um modelo de linguagem, apenas o mecanismo do codificador é necessário. 


Ao contrário dos modelos direcionais, que lêem a entrada de texto sequencialmente (da esquerda para a direita ou da direita para a esquerda), o codificador Transformer lê toda a sequência de palavras de uma vez. Portanto, é considerado bidirecional, embora seja mais preciso dizer que é não direcional. Esta característica permite que o modelo aprenda o contexto de uma palavra com base em todos os seus arredores (esquerdo e direito da palavra).


O gráfico abaixo é uma descrição de alto nível do codificador Transformer. A entrada é uma sequência de tokens, que são primeiro incorporados em vetores e depois processados ​​na rede neural. A saída é uma sequência de vetores de tamanho H, em que cada vetor corresponde a um token de entrada com o mesmo índice.


Ao treinar modelos de linguagem, existe o desafio de definir uma meta de previsão. Muitos modelos prevêem a próxima palavra em uma sequência (por exemplo, “A criança voltou para casa de \_\_\_”), uma abordagem direcional que limita inerentemente o aprendizado do contexto. 


Para superar esse desafio, o BERT usa duas estratégias de treinamento: Masked LM (MLM) e Next Sentence Prediction (NSP), que estudaremos no próximo capítulo.


 


![bert](https://www.deeplearningbook.com.br/wp-content/uploads/2020/11/bert.png)


 


Referências:


[Processamento de Linguagem Natural com Transformers](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers)


[BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding](https://arxiv.org/pdf/1810.04805.pdf)


[Open Sourcing BERT: State-of-the-Art Pre-training for Natural Language Processing](https://ai.googleblog.com/2018/11/open-sourcing-bert-state-of-art-pre.html)


[BERT Explained: State of the art language model for NLP](https://towardsdatascience.com/bert-explained-state-of-the-art-language-model-for-nlp-f8b21a9b6270)


[The Illustrated BERT, ELMo, and co. (How NLP Cracked Transfer Learning)](http://jalammar.github.io/illustrated-bert/)


<div id="capitulo-78---modelo-bert---previsao-da-proxima-frase"></div>

# Capítulo 78 – Modelo BERT – Previsão da Próxima Frase


Vamos complementar o capítulo anterior e compreender alguns detalhes do funcionamento do BERT para Processamento de Linguagem Natural.


Antes de alimentar as sequências de palavras no BERT, 15% das palavras em cada sequência são substituídas por um token [MASK]. O modelo então tenta prever o valor original das palavras *mascaradas*, com base no contexto fornecido pelas outras palavras não mascaradas na sequência. Em termos técnicos, a previsão das palavras de saída requer:


* Adicionar uma camada de classificação no topo da saída do codificador.
* Multiplicar os vetores de saída pela matriz de embedding, transformando-os na dimensão do vocabulário.
* Calcular a probabilidade de cada palavra do vocabulário com a função de ativação softmax.


![bert](https://www.deeplearningbook.com.br/wp-content/uploads/2020/11/bert.png)


A função de perda no modelo BERT leva em consideração apenas a previsão dos valores mascarados e ignora a previsão das palavras não mascaradas. Como consequência, o modelo converge mais devagar do que os modelos direcionais, uma característica que é compensada por sua maior percepção do contexto.


Nota: na prática, a implementação de BERT é um pouco mais elaborada e não substitui todas as palavras mascaradas de 15%. Consulte o Apêndice A para obter informações adicionais.


**Previsão da Próxima Frase (Next Sentence Prediction – NSP)**


No processo de treinamento do BERT, o modelo recebe pares de frases como entrada e aprende a prever se a segunda frase do par é a frase subsequente no documento original. Durante o treinamento, 50% das entradas são um par em que a segunda frase é a frase subsequente no documento original, enquanto nos outros 50% uma frase aleatória do corpus é escolhida como segunda frase. A suposição é que a frase aleatória será desconectada da primeira frase.


Para ajudar o modelo a distinguir entre as duas sentenças no treinamento, a entrada é processada da seguinte maneira antes de entrar no modelo:


Um token [CLS] é inserido no início da primeira frase e um token [SEP] é inserido no final de cada frase.


Uma embedding de frase indicando a frase A ou a frase B é adicionada a cada token. Embeddings de frases são semelhantes em conceito aos embeddings de token com um vocabulário de 2.


Uma embedding posicional é adicionada a cada token para indicar sua posição na sequência. O conceito e a implementação da embedding posicional são apresentados no artigo do Transformer fornecido pelo Google (link ao final do capítulo).


![nsp](https://www.deeplearningbook.com.br/wp-content/uploads/2020/12/nsp-1024x322.png)


Para prever se a segunda frase está realmente conectada à primeira, as seguintes etapas são executadas:


Toda a sequência de entrada passa pelo modelo do Transformer.


A saída do token [CLS] é transformada em um vetor em forma de 2 × 1, usando uma camada de classificação simples (matrizes aprendidas de pesos e vieses).


A probabilidade de IsNextSequence é calculada com a função de ativação softmax.


Ao treinar o modelo BERT, o Mask LM (MLM) e a Previsão da Próxima Frase (NSP) são treinados em conjunto, com o objetivo de minimizar a função perda combinada das duas estratégias.


**Como Usar o BERT**


Usar o BERT para uma tarefa específica é relativamente simples. O BERT pode ser usado para uma ampla variedade de tarefas de linguagem, adicionando apenas uma pequena camada ao modelo central.


Tarefas de classificação, como análise de sentimento, são feitas de maneira semelhante à classificação da próxima frase, adicionando uma camada de classificação na parte superior da saída do Transformer para o token [CLS].


Em tarefas de resposta a perguntas (por exemplo, SQuAD v1.1), o software recebe uma pergunta sobre uma sequência de texto e é obrigado a marcar a resposta na sequência. Usando o BERT, um modelo de Q&A pode ser treinado aprendendo dois vetores extras que marcam o início e o fim da resposta.


No Named Entity Recognition (NER), o software recebe uma sequência de texto e é obrigado a marcar os vários tipos de entidades (Pessoa, Organização, Data, etc.) que aparecem no texto. Usando BERT, um modelo NER pode ser treinado alimentando o vetor de saída de cada token em uma camada de classificação que prevê o rótulo NER.


No treinamento de ajuste fino, a maioria dos hiperparâmetros permanecem os mesmos que no treinamento do BERT, e o artigo fornece orientação específica (Seção 3.5 do paper oficial do Google) sobre os hiperparâmetros que requerem ajuste. A equipe do BERT usou essa técnica para obter resultados de última geração em uma ampla variedade de tarefas desafiadoras de linguagem natural, detalhadas na Seção 4 do artigo.


**Aprendizado**


O tamanho do modelo é importante, mesmo em grande escala. BERT\_large, com 345 milhões de parâmetros, é o maior modelo desse tipo. É comprovadamente superior em tarefas de pequena escala ao BERT\_base, que usa a mesma arquitetura com “apenas” 110 milhões de parâmetros.


Com dados de treinamento suficientes, mais etapas de treinamento = maior precisão. Por exemplo, na tarefa MNLI, a precisão de BERT\_base melhora em 1,0% quando treinada em etapas de 1M (tamanho de lote de 128.000 palavras) em comparação com 500.000 etapas com o mesmo tamanho de lote.


A abordagem bidirecional (MLM) do BERT converge mais lentamente do que as abordagens da esquerda para a direita (porque apenas 15% das palavras são previstas em cada lote), mas o treinamento bidirecional ainda supera o treinamento da esquerda para a direita após um pequeno número de etapas de pré-treinamento.


![take](https://www.deeplearningbook.com.br/wp-content/uploads/2020/12/take-1024x677.png)


**Conclusão**


O BERT é, sem dúvida, um avanço no uso de Aprendizado de Máquina para Processamento de Linguagem Natural. O fato de ser acessível e permitir um ajuste fino rápido provavelmente permitirá uma ampla gama de aplicações práticas no futuro. Nos capítulos sobre BERT deste livro, procuramos descrever as principais ideias do artigo sem nos afogarmos em detalhes técnicos excessivos. Para aqueles que desejam um mergulho mais profundo, recomendamos a leitura do artigo completo e dos artigos auxiliares referenciados nele, bem como do treinamento de [Processamento de Linguagem Natural](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers) no portal da DSA. 


Outra referência útil é o código-fonte e os modelos do BERT, que cobrem 103 linguagens e foram generosamente liberados como código aberto pela equipe de pesquisa.


**Apêndice A – Máscara de Palavras (MLM)**


O treinamento do modelo de linguagem NO BERT é feito prevendo 15% dos tokens na entrada, que foram escolhidos aleatoriamente. Esses tokens são pré-processados ​​da seguinte forma – 80% são substituídos por um token “[MASK]”, 10% por uma palavra aleatória e 10% usam a palavra original. A intuição que levou os autores a escolher essa abordagem é a seguinte:


Se usássemos [MASK] 100% do tempo, o modelo não produziria necessariamente boas representações de token para palavras não mascaradas. Os tokens não mascarados ainda eram usados ​​para contexto, mas o modelo foi otimizado para prever palavras mascaradas.


Se usássemos [MASK] 90% das vezes e palavras aleatórias 10% das vezes, isso ensinaria ao modelo que a palavra observada nunca está correta.


Se usássemos [MASK] 90% do tempo e mantivéssemos a mesma palavra 10% do tempo, o modelo poderia apenas copiar trivialmente o embedding não contextual.


Nenhuma mudança foi feita nas proporções desta abordagem, e pode ter funcionado melhor com proporções diferentes. Além disso, o desempenho do modelo não foi testado simplesmente mascarando 100% dos tokens selecionados.


Referências:


[Processamento de Linguagem Natural](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers)


[BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding](https://arxiv.org/pdf/1810.04805.pdf)


[Open Sourcing BERT: State-of-the-Art Pre-training for Natural Language Processing](https://ai.googleblog.com/2018/11/open-sourcing-bert-state-of-art-pre.html)


[BERT Explained: State of the art language model for NLP](https://towardsdatascience.com/bert-explained-state-of-the-art-language-model-for-nlp-f8b21a9b6270)


[The Illustrated BERT, ELMo, and co. (How NLP Cracked Transfer Learning)](http://jalammar.github.io/illustrated-bert/)


<div id="capitulo-79---conhecendo-o-modelo-gpt-3-(generative-pre-trained-transformer)"></div>

# Capítulo 79 – Conhecendo o Modelo GPT-3 (Generative Pre-trained Transformer)


Os modelos Generative Pre-Training Transformer (GPT) da OpenAI conquistaram a comunidade de Processamento de Linguagem Natural (PLN) com a introdução de modelos de linguagem muito poderosos. Esses modelos podem realizar várias tarefas de PLN, como responder a perguntas, vinculação textual, resumo de texto, etc., sem nenhum treinamento supervisionado. Esses modelos de linguagem precisam de muito poucos ou nenhum exemplo para entender as tarefas e alcançar um desempenho equivalente ou até melhor do que os modelos de última geração treinados de maneira supervisionada.


![GPT-3](https://www.deeplearningbook.com.br/wp-content/uploads/2021/01/GPT-3-2-300x150.jpg)


Neste e nos próximos capítulos vamos cobrir a jornada desses modelos e entender como eles evoluíram ao longo de um período de 2 anos. Estaremos cobrindo os seguintes tópicos aqui:


1. Discussão do artigo GPT-1 ([Improving Language Understanding by Generative Pre-training](https://cdn.openai.com/research-covers/language-unsupervised/language_understanding_paper.pdf)).  

2. Discussão do artigo GPT-2 ([Language Models are unsupervised multitask learners](https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf)) e suas melhorias subsequentes em relação ao GPT-1.  

3. Discussão do artigo GPT-3 ([Language models are few shot learners](https://arxiv.org/pdf/2005.14165.pdf)) e as melhorias que o tornaram um dos modelos mais poderosos que o PLN já viu até agora.


Vamos abordar ainda os conceitos básicos de terminologias de PLN e arquitetura Transformer. Os modelos GPT vão estar presentes na Formação IA Aplicada ao Direito, na Data Science Academy.


Vamos começar conhecendo o membro mais jovem da família com uma visão geral do modelo e da sua história.


O Que é o GPT-3?
================


Recentemente estávamos discutindo se a implementação do Generative Pretrained Transformer-2 (GPT-2) era razoável. Se o debate parece recente, é porque é (escrito a partir de 2020): O notório modelo GPT-2 foi anunciado pela OpenAI em fevereiro de 2019, mas não foi totalmente lançado até quase 9 meses depois (embora tenha sido replicado antes disso). O cronograma de lançamento foi admitidamente um tanto experimental mais para fomentar a discussão da publicação de forma aberta responsável, ao invés de um último esforço para evitar um apocalipse da IA. Isso não impediu os críticos de questionar as vantagens publicitárias de um ciclo de lançamento ameaçador.


Tudo isso é um pouco discutível agora, porque a OpenAI não apenas treinou um modelo de linguagem muito maior no GPT-3, mas você pode se inscrever para acessá-lo por meio de sua nova API. Comparar GPT-3 com GPT-2 é como comparar maçãs com passas, porque o modelo é muito maior. Enquanto o GPT-2 pesava apenas 1,542 bilhão de parâmetros (com versões de lançamento menores em 117, 345 e 762 milhões), o GPT-3 de tamanho completo tem 175 bilhões de parâmetros. GPT-3 também foi combinado com um conjunto de dados maior para pré-treinamento: 570 GB de texto em comparação com 40 GB para o GPT-2.


  

![gpt](https://www.deeplearningbook.com.br/wp-content/uploads/2021/01/gpt-1024x614.jpg)


GPT-3 é um modelo de linguagem alimentado por rede neural. Um modelo de linguagem é um modelo que prevê a probabilidade de uma frase existir no mundo. Por exemplo, um modelo de linguagem pode rotular a frase “Eu levo meu cachorro para passear” como mais provável de existir (ou seja, na Internet) do que a frase “Eu levo minha banana para passear”. Isso é verdadeiro tanto para sentenças quanto para frases e, de maneira mais geral, qualquer sequência de caracteres.


GPT-3 é o maior transformador de processamento de linguagem natural (PLN) lançado até agora, eclipsando o recorde anterior, o Turing-NLG da Microsoft Research com 17 bilhões de parâmetros, em cerca de 10 vezes. Não é novidade que houve bastante empolgação em torno do modelo e, dada a abundância de demonstrações de GPT-3 no Twitter e em outros lugares, a OpenAI aparentemente conseguiu acomodar bem o fornecimento de acesso beta à nova API. Isso resultou em uma explosão de demos: algumas boas, outras ruins, todas interessantes. Algumas dessas demos agora estão sendo apresentadas como produtos a serem lançados em breve e, em alguns casos, podem até ser úteis. Uma coisa é certa, PLN conseguiu uma notória evolução.


Como a maioria dos modelos de linguagem, o GPT-3 é elegantemente treinado em um conjunto de dados de texto não rotulado. Palavras ou frases são removidas aleatoriamente do texto, e o modelo deve aprender a preenchê-las usando apenas as palavras ao redor como contexto. É uma tarefa de treinamento simples que resulta em um modelo poderoso e generalizável.


A própria arquitetura do modelo GPT-3 é uma rede neural baseada em transformador. Essa arquitetura se tornou popular cerca de 2 a 3 anos atrás e é a base para o popular modelo de PLN BERT que abordamos nos capítulos anteriores. Do ponto de vista da arquitetura, o GPT-3 não é muito novo! Então, o que o torna tão especial e mágico?


É REALMENTE GRANDE. Quero dizer muito grande. Com 175 bilhões de parâmetros, é o maior modelo de linguagem já criado (GPT-2 tinha apenas 1,5 bilhão de parâmetros!), E foi treinado no maior conjunto de dados de qualquer modelo de linguagem. Esta, ao que parece, é a principal razão pela qual o GPT-3 é tão impressionante.


E aqui está a parte mágica. Como resultado, o GPT-3 pode fazer o que nenhum outro modelo pode fazer (bem): executar tarefas específicas sem nenhum ajuste especial. Você pode pedir ao GPT-3 para ser um tradutor, um programador, um poeta ou um autor famoso, e pode fazê-lo com menos de 10 exemplos de treinamento. É o mais próximo que chegamos de uma IA genérica, como descrito no famoso livro O Algoritmo Mestre.


A maioria dos outros modelos (como o BERT) requer uma etapa de ajuste fino elaborada, onde você reúne milhares de exemplos de pares de frases (digamos) francês-inglês para ensiná-lo a traduzir. Com o GPT-3, você não precisa fazer aquela etapa de ajuste fino. Este é o cerne da questão. Isso é o que deixa as pessoas entusiasmadas com o GPT-3: tarefas de linguagem personalizadas sem dados de treinamento.


Nos próximos capítulos vamos compreender como surgiu o GPT-3, seus antecessores e funcionamento. 


Referências:


[Processamento de Linguagem Natural](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers)


[Attention Is All You Need](https://arxiv.org/abs/1706.03762)


[OpenAI](https://openai.com/blog/openai-api/)


<div id="capitulo-80---melhorando-a-compreensao-da-linguagem-por-meio-do-pre-treinamento-generativo-(gpt-1)"></div>

# Capítulo 80 – Melhorando a Compreensão da Linguagem Por Meio do Pré-treinamento Generativo (GPT-1)


Para compreender o GPT-3, seu estado atual e seu uso futuro, é importante dar alguns passos atrás e compreender os modelos predecessores, o GPT-1 e o GPT-2. 


Começamos pela versão 1. Aqui está o paper original do modelo GPT-1: [Improving Language Understanding by Generative Pre-Training](https://cdn.openai.com/research-covers/language-unsupervised/language_understanding_paper.pdf).


Antes dos modelos GPT, a maioria dos modelos de Processamento de Linguagem Natural (PLN) de última geração eram treinados especificamente em uma tarefa particular, como classificação de sentimento, classificação textual, etc., usando aprendizado supervisionado. No entanto, os modelos supervisionados têm duas limitações principais:


* Eles precisam de uma grande quantidade de dados anotados para aprender uma tarefa específica que muitas vezes não está facilmente disponível.
* Eles falham em generalizar para tarefas diferentes daquelas para as quais foram treinados (comum em qualquer modelo de Machine Learning tradicional).


O modelo GPT-1 propôs aprender um modelo de linguagem generativa usando dados não rotulados e, em seguida, ajustar o modelo, fornecendo exemplos de tarefas posteriores específicas, como análise de sentimento, classificação textual, etc.


A aprendizagem não supervisionada serviu como objetivo de pré-treinamento para modelos supervisionados e ajustados, daí o nome de *Pré-treinamento Generativo*.


Vamos examinar os conceitos e abordagens discutidos no paper do GPT-1.


**1. Objetivos e Conceitos de Aprendizagem**: Este aprendizado semi-supervisionado (pré-treinamento não supervisionado seguido de ajuste fino supervisionado) para tarefas de PLN tem os seguintes três componentes:


**a) Modelagem de Linguagem Não Supervisionada (Pré-treinamento)**: Para aprendizagem não supervisionada, o objetivo do modelo de linguagem padrão foi usado, conforme a fórmula abaixo.


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2021/01/form1-300x55.png)


onde T era o conjunto de tokens em dados não supervisionados {t\_1,…, t\_n}, k era o tamanho da janela de contexto, θ eram os parâmetros da rede neural treinada usando gradiente estocástico descendente.


**b) Ajuste Fino Supervisionado:** Esta parte tem como objetivo maximizar a probabilidade de observar o rótulo y para determinados recursos ou tokens x\_1,…, x\_n.


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2021/01/form2-300x62.png)


onde C era o conjunto de dados rotulado composto de exemplos de treinamento.


Em vez de simplesmente maximizar o objetivo mencionado na equação (ii), os autores adicionaram um objetivo de aprendizagem auxiliar para o ajuste fino supervisionado para obter melhor generalização e convergência mais rápida. O objetivo de treinamento modificado foi declarado como:


![form3](https://www.deeplearningbook.com.br/wp-content/uploads/2021/01/form3-300x48.png)


onde L₁(C) era o objetivo auxiliar do modelo de aprendizagem da linguagem e λ era o peso dado a este objetivo secundário de aprendizagem. λ foi definido como 0,5.


O ajuste fino supervisionado foi obtido adicionando uma camada linear e uma softmax ao modelo do transformador para obter os rótulos de tarefa para tarefas posteriores. Muito similar a outros modelos que vi ao longo deste livro.


**c) Transformações de Entradas Específicas da Tarefa**: Para fazer alterações mínimas na arquitetura do modelo durante o ajuste fino, as entradas para as tarefas específicas foram transformadas em sequências ordenadas. Os tokens foram reorganizados da seguinte maneira:


– Os tokens de início e fim foram adicionados às sequências de entrada.  

– Um token delimitador foi adicionado entre as diferentes partes do exemplo para que a entrada pudesse ser enviada como uma sequência ordenada.


Para tarefas como responder a perguntas, perguntas de múltipla escolha, etc., várias sequências foram enviadas para cada exemplo. Por exemplo. um exemplo de treinamento composto de sequências para contexto, pergunta e resposta para a tarefa de responder a perguntas.


**2. Conjunto de Dados**: GPT-1 usou o conjunto de dados [BooksCorpus](https://yknzhu.wixsite.com/mbweb) para treinar o modelo de linguagem. BooksCorpus tinha cerca de 7.000 livros não publicados que ajudaram a treinar o modelo de linguagem em dados não vistos. É improvável que esses dados sejam encontrados no conjunto de teste. Além disso, esse corpus tinha grandes trechos de texto contíguo, o que ajudou o modelo a aprender dependências de grande alcance.


**3. Arquitetura do Modelo e Detalhes de Implementação**: GPT-1 usou a estrutura do transformador do decodificador de 12 camadas apenas com autoatenção mascarada para treinar o modelo de linguagem. A arquitetura do modelo permaneceu a mesma em grande medida, conforme descrito no trabalho original sobre transformadores. O mascaramento ajudou a alcançar o objetivo do modelo de linguagem em que o modelo de linguagem não tinha acesso às palavras subsequentes à direita da palavra atual. A seguir estão os detalhes de implementação:


**a) Para Treinamento Não Supervisionado:**


* O vocabulário Byte Pair Encoding (BPE) com 40.000 fusões foi usado.
* O modelo usou o estado de 768 dimensões para codificar tokens em embeddings de palavras. Embeddings de posição também foram aprendidos durante o treinamento.
* O modelo de 12 camadas foi usado com 12 cabeças de atenção em cada camada de autoatenção.
* Para a posição de alimentação para a frente, a camada 3072 de estado dimensional foi usada.
* O otimizador Adam foi usado com taxa de aprendizado de 2,5e-4.
* Atenção, residuais e dropouts de embeddings foram utilizadas para regularização, com taxa de dropout de 0,1. A versão modificada da regularização L2 também foi usada para pesos sem polarização.
* GELU foi usado como função de ativação.
* O modelo foi treinado por 100 épocas em minilotes de tamanho 64 e comprimento de sequência de 512. O modelo tinha 117M parâmetros no total.


**b) Para Ajuste Fino Supervisionado:** O ajuste fino supervisionado levou apenas 3 épocas para a maioria das tarefas posteriores. Isso mostrou que a modelo já havia aprendido muito sobre o idioma durante o pré-treinamento. Portanto, o ajuste fino mínimo foi suficiente. A maioria dos hiperparâmetros do pré-treinamento não supervisionado foi usada para o ajuste fino.


**4. Desempenho e Resumo**: O GPT-1 teve um desempenho melhor do que os modelos de última geração supervisionados especificamente treinados em 9 das 12 tarefas nas quais os modelos foram comparados. Outra conquista significativa deste modelo foi seu desempenho decente de *tiro zero* em várias tarefas. O artigo demonstrou que o modelo evoluiu em desempenho *zero shot* em diferentes tarefas de PLN, como responder a perguntas, resolução de esquema, análise de sentimento, etc. devido ao pré-treinamento. O GPT-1 provou que o modelo de linguagem serviu como um objetivo pré-treinamento eficaz que poderia ajudar a generalizar bem o modelo. A arquitetura facilitou a transferência de aprendizado e pode realizar várias tarefas de PLN com muito pouco ajuste. Este modelo mostrou o poder do pré-treinamento generativo e abriu caminhos para outros modelos que poderiam desencadear melhor esse potencial com conjuntos de dados maiores e mais parâmetros.


O GPT-1 agrega muitas das técnicas de Deep Learning que vimos nos capítulos deste livro, sendo o ápice até então. Mas logo depois os pesquisadores do OpenAI (autores do GPT) se superaram e lançaram o GPT-2, que estudaremos no próximo capítulo.


Referências:



[Processamento de Linguagem Natural](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers)


[Attention Is All You Need](https://arxiv.org/abs/1706.03762)


[OpenAI](https://openai.com/blog/openai-api/)


[The Journey of Open AI GPT models](https://medium.com/walmartglobaltech/the-journey-of-open-ai-gpt-models-32d95b7b7fb2)


[The Ultimate Guide to OpenAI’s GPT-3 Language Model](https://www.twilio.com/blog/ultimate-guide-openai-gpt-3-language-model)


[You Can Actually Understand GPT-3 With These YouTube Videos](https://towardsdatascience.com/you-can-understand-gpt-3-with-these-youtube-videos-6a30887c928b)


[GPT-3 Explained in Under 3 Minutes](https://daleonai.com/gpt3-explained-fast)



<div id="capitulo-81---modelos-de-linguagem-como-tarefas-nao-supervisionadas-(gpt-2)"></div>

# Capítulo 81 – Modelos de Linguagem Como Tarefas Não Supervisionadas (GPT-2)


Vamos seguir estudando o modelo GPT, agora com a sua segunda versão. Estamos considerando que você leu o capítulo anterior.


Os desenvolvimentos no modelo GPT-2 foram principalmente em termos de usar um conjunto de dados maior e adicionar mais parâmetros ao modelo para aprender um modelo de linguagem ainda mais forte. Vejamos os desenvolvimentos significativos no modelo GPT-2 e os conceitos discutidos no artigo:


**1- Objetivos e Conceitos de Aprendizagem**
--------------------------------------------


A seguir estão os dois conceitos importantes discutidos no artigo GPT-2 no contexto do PLN (Processamento de Linguagem Natural).


**Condicionamento de Tarefas**: vimos que o objetivo de treinamento do modelo de linguagem é formulado como P(saída | entrada). No entanto, o GPT-2 teve como objetivo aprender várias tarefas usando o mesmo modelo não supervisionado. Para isso, o objetivo de aprendizagem deve ser modificado para P(saída | entrada, tarefa). Esta modificação é conhecida como condicionamento de tarefa, em que se espera que o modelo produza saídas diferentes para a mesma entrada para tarefas diferentes. Alguns modelos implementam condicionamento de tarefa em um nível arquitetônico onde o modelo é alimentado com a entrada e a tarefa. Para modelos de linguagem, a saída, entrada e tarefa, todos são sequências de linguagem natural. Assim, o condicionamento de tarefas para modelos de linguagem é realizado fornecendo exemplos ou instruções de linguagem natural para o modelo realizar uma tarefa. O condicionamento de tarefas forma a base para a transferência de tarefas de tiro zero, que abordaremos a seguir.


**Zero Shot Learning e Zero Short Task Transfer**: uma capacidade interessante do GPT-2 é a transferência de tarefa zero shot. O aprendizado zero shot é um caso especial de transferência de tarefa zero shot onde nenhum exemplo é fornecido e o modelo entende a tarefa com base na instrução fornecida. Em vez de reorganizar as sequências, como foi feito para o GPT-1 para o ajuste fino, a entrada para o GPT-2 foi fornecida em um formato que esperava que o modelo entendesse a natureza da tarefa e fornecesse respostas. Isso foi feito para emular o comportamento de transferência de tarefa de tiro zero. Por exemplo. para a tarefa de tradução de inglês para francês, o modelo recebeu uma frase em inglês seguida da palavra francês e um prompt (:). O modelo deveria entender que se trata de uma tarefa de tradução e fornecer a contrapartida francesa da frase inglesa.


**2. Conjunto de Dados**
------------------------


Para criar um conjunto de dados extenso e de boa qualidade, os autores usaram a plataforma do Reddit e extraíram dados de links externos de artigos com alta votação. O conjunto de dados resultante, denominado WebText, tinha 40 GB de dados de texto de mais de 8 milhões de documentos. Este conjunto de dados foi usado para treinar GPT-2 e era enorme em comparação com o conjunto de dados Book Corpus usado para treinar o modelo GPT-1. Todos os artigos da Wikipedia foram removidos do WebText, pois muitos conjuntos de teste contêm artigos da Wikipedia.


**3. Arquitetura do Modelo e Detalhes de Implementação**
--------------------------------------------------------


GPT-2 tinha 1,5 bilhão de parâmetros. que era 10 vezes mais do que GPT-1 (117M parâmetros). As principais diferenças da GPT-1 foram:


* GPT-2 tinha 48 camadas e usava 1600 vetores dimensionais para incorporação de palavras.
* Um vocabulário maior de 50.257 tokens foi usado.
* Tamanho de lote maior de 512 e janela de contexto maior de 1024 tokens foram usados.
* A normalização da camada foi movida para a entrada de cada sub-bloco e uma normalização da camada adicional foi adicionada após o bloco final de autoatenção.
* Na inicialização, o peso das camadas residuais foi dimensionado em 1 / √N, onde N era o número de camadas residuais.


Os autores treinaram quatro modelos de linguagem com 117M (igual ao GPT-1), 345M, 762M e 1.5B (GPT-2) parâmetros. Cada modelo subsequente teve menor perplexidade do que o anterior. Isso estabeleceu que a perplexidade dos modelos de linguagem no mesmo conjunto de dados diminui com o aumento do número de parâmetros. Além disso, o modelo com o maior número de parâmetros teve melhor desempenho em todas as tarefas downstream.


**4. Desempenho e Resumo**
--------------------------


O GPT-2 foi avaliado em vários conjuntos de dados de tarefas posteriores, como compreensão de leitura, resumo, tradução, resposta a perguntas, etc. Vejamos algumas dessas tarefas e o desempenho do GPT-2 nelas em detalhes:


GPT-2 melhorou o estado da arte então existente para 7 de 8 conjuntos de dados de modelagem de linguagem em configuração zero shot. O conjunto de dados de livros infantis avalia o desempenho em modelos de linguagem em categorias de palavras como substantivos, preposições, entidades nomeadas, etc. 


O GPT-2 aumentou a precisão do estado da arte em aproximadamente 7% para substantivo comum e reconhecimento de entidade nomeada. O conjunto de dados avalia o desempenho dos modelos na identificação de dependências de longo alcance e na previsão da última palavra de uma frase. GPT-2 reduziu a perplexidade de 99,8 para 8,6 e melhorou a precisão significativamente.


GPT-2 superou 3 de 4 modelos de linha de base em tarefas de compreensão de leitura em configuração de tiro zero. Na tarefa de tradução do francês para o inglês, o GPT-2 teve um desempenho melhor do que a maioria dos modelos não supervisionados na configuração zero shot, mas não superou o modelo não supervisionado de última geração.


O GPT-2 não teve um bom desempenho na sumarização de texto e seu desempenho foi semelhante ou inferior aos modelos clássicos treinados para sumarização.


O GPT-2 conseguiu obter resultados de última geração em 7 dos 8 conjuntos de dados de modelagem de linguagem testados em zero-shot.


O GPT-2 mostrou que o treinamento em um conjunto de dados maior e com mais parâmetros melhorou a capacidade do modelo de linguagem de compreender tarefas e superar o estado da arte de muitas tarefas em configurações de tiro zero. A equipe afirmou que com o aumento da capacidade do modelo, o desempenho aumentou de forma log-linear. Além disso, a queda na perplexidade dos modelos de linguagem não mostrou saturação e continuou diminuindo com o aumento do número de parâmetros. Na verdade, o GPT-2 subjugou o conjunto de dados WebText e o treinamento por mais tempo poderia ter reduzido a perplexidade ainda mais. Isso mostrou que o tamanho do modelo de GPT-2 não era o limite e construir modelos de linguagem ainda maiores reduziria a perplexidade e tornaria os modelos de linguagem melhores no entendimento da linguagem natural.


E então, veio o GPT-3, assunto do próximo capítulo.


Referências:



[Processamento de Linguagem Natural](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers)


[Attention Is All You Need](https://arxiv.org/abs/1706.03762)


[OpenAI](https://openai.com/blog/openai-api/)


[The Journey of Open AI GPT models](https://medium.com/walmartglobaltech/the-journey-of-open-ai-gpt-models-32d95b7b7fb2)


[The Ultimate Guide to OpenAI’s GPT-3 Language Model](https://www.twilio.com/blog/ultimate-guide-openai-gpt-3-language-model)


[You Can Actually Understand GPT-3 With These YouTube Videos](https://towardsdatascience.com/you-can-understand-gpt-3-with-these-youtube-videos-6a30887c928b)


[GPT-3 Explained in Under 3 Minutes](https://daleonai.com/gpt3-explained-fast)



<div id="capitulo-82---gpt-3---caracteristicas-e-limitacoes"></div>

# Capítulo 82 – GPT-3 – Características e Limitações


Em sua busca para construir modelos de linguagem muito fortes e poderosos que não precisariam de nenhum ajuste fino e apenas de algumas demonstrações para entender as tarefas e executá-las, a Open AI construiu o modelo GPT-3 com 175 bilhões de parâmetros. Este modelo tem 10 vezes mais parâmetros do que o poderoso modelo de linguagem Turing NLG da Microsoft e 100 vezes mais parâmetros do que o GPT-2. 


Devido ao grande número de parâmetros e ao extenso conjunto de dados em que o GPT-3 foi treinado, ele tem um bom desempenho em tarefas de PLN (Processamento de Linguagem Natural) em configuração zero-shot e few-shot. Devido à sua grande capacidade, ele tem recursos como escrever artigos que são difíceis de distinguir dos escritos por humanos. Ele também pode realizar tarefas dinâmicas nas quais nunca foi explicitamente treinado, como somar números, escrever consultas SQL e códigos, decifrar palavras em uma frase, escrever códigos React e JavaScript com a descrição da tarefa em linguagem natural, etc. 


Vamos entender as características e limitações mencionados no [paper](https://arxiv.org/pdf/2005.14165.pdf) do GPT-3.


1. Objetivos e Conceitos de Aprendizagem
----------------------------------------


**Aprendizagem no contexto**: grandes modelos de linguagem desenvolvem reconhecimento de padrões e outras habilidades usando os dados de texto em que são treinados. Ao aprender o objetivo principal de prever a próxima palavra, dada as palavras de contexto, os modelos de linguagem também começam a reconhecer padrões em dados que os ajudam a minimizar a perda da tarefa de modelagem de linguagem. Mais tarde, essa capacidade ajuda o modelo durante a transferência de tarefa de tiro zero. Quando apresentado com alguns exemplos e/ou uma descrição do que precisa fazer, os modelos de linguagem correspondem ao padrão dos exemplos com o que aprendeu no passado para dados semelhantes e usa esse conhecimento para executar as tarefas. Esta é uma capacidade poderosa de grandes modelos de linguagem que cresce com o aumento do número de parâmetros do modelo.


**Configuração de poucas tentativas, uma e nenhuma tentativa**: como discutido nos capítulos anteriores, poucas configurações, uma e nenhuma tentativa são casos especializados de transferência de tarefa de poucas tentativas. Na configuração de poucas tentativas, o modelo é fornecido com a descrição da tarefa. Na configuração one-shot, o modelo é fornecido exatamente um exemplo e na configuração zero-shot nenhum exemplo é fornecido. 


2. Conjunto de Dados
--------------------


O GPT-3 foi treinado em uma mistura de cinco *corpora* diferentes, cada um com um determinado peso atribuído a ele. Conjuntos de dados de alta qualidade foram amostrados com mais frequência e o modelo foi treinado para mais de uma época neles. Os cinco conjuntos de dados usados ​​foram: Common Crawl, WebText2, Books1, Books2 e Wikipedia.


3. **Arquitetura do Modelo e Detalhes de Implementação**
--------------------------------------------------------


A arquitetura do GPT-3 é a mesma do GPT-2. Algumas diferenças principais do GPT-2 são:


* O GPT-3 tem 96 camadas com cada camada tendo 96 cabeças de atenção.
* O tamanho dos embeddings de palavras foi aumentado para 12888 no GPT-3, sendo 1600 no GPT-2.
* O tamanho da janela de contexto foi aumentado de 1024 no GPT-2 para 2048 tokens no GPT-3.
* O otimizador Adam foi usado com β\_1 = 0,9, β\_2 = 0,95 e ε = 10 ^ (- 8).
* Foram usados ​​padrões alternados de atenção esparsa e densa localmente.


4. Desempenho e Resumo
----------------------


O modelo GPT-3 foi avaliado em uma série de modelagem de linguagem e conjuntos de dados de PLN. O GPT-3 teve um desempenho melhor do que o estado da arte para conjuntos de dados de modelagem de linguagem como LAMBADA e Penn Tree Bank em poucos ou zero-shot. 


Para outros conjuntos de dados, ele não conseguiu superar o estado da arte, mas melhorou o desempenho de última geração. O GPT-3 também teve um desempenho razoavelmente bom em tarefas de PLN, como resposta a perguntas em livros fechados e resolução de esquemas, tradução, etc., muitas vezes superando o estado da arte ou tendo um desempenho comparável a modelos ajustados. Para a maioria das tarefas, o modelo teve um desempenho melhor na configuração de poucas tentativas em comparação com uma e nenhuma tentativa.


Além de avaliar o modelo em tarefas de PLN convencionais, o modelo também foi avaliado em tarefas sintéticas como adição aritmética, decodificação de palavras, geração de artigos de notícias, aprendizagem e uso de palavras novas, etc. Para essas tarefas também, o desempenho aumentou com o aumento no número de parâmetros e o modelo teve melhor desempenho na configuração de poucas tentativas do que uma e nenhuma tentativa.


5. Limitações e Impactos Mais Amplos
------------------------------------


O documento discute vários pontos fracos do modelo GPT-3 e áreas abertas para melhorias. Vamos resumi-los aqui.


Embora o GPT-3 seja capaz de produzir texto de alta qualidade, às vezes começa a perder coerência ao formular frases longas e repete sequências de texto indefinidamente. Além disso, o GPT-3 não tem um desempenho muito bom em tarefas como inferência de linguagem natural (determinar que se uma frase implica outra frase), preencher os espaços em branco, algumas tarefas de compreensão de leitura etc. O artigo cita a unidirecionalidade dos modelos GPT como a causa provável para essas limitações e sugere o treinamento de modelos bidirecionais nesta escala para superar esses problemas.


Outra limitação apontada pelo artigo é o objetivo de modelagem de linguagem genérica do GPT-3, que pesa cada token igualmente e não tem a noção de tarefa ou previsão de tokens orientada para a meta. Para contornar isso, o artigo sugere abordagens como aumento do objetivo de aprendizagem, uso de aprendizagem por reforço para ajustar modelos, adição de outras modalidades, etc.


Outras limitações do GPT-3 incluem inferência complexa e cara do modelo devido à sua arquitetura pesada, menos interpretabilidade da linguagem e resultados gerados pelo modelo e incerteza sobre o que ajuda o modelo a atingir seu comportamento de aprendizado de poucas tentativas.


Junto com essas limitações, o GPT-3 acarreta o risco potencial de uso indevido de sua capacidade de geração de texto semelhante ao humano para phishing, spamming, disseminação de informações incorretas ou realização de outras atividades fraudulentas. Além disso, o texto gerado pelo GPT-3 possui os preconceitos da linguagem e os artigos gerados pelo GPT-3 podem apresentar preconceitos de gênero, etnia, raça ou religião e, portanto, torna-se extremamente importante utilizar tais modelos com cuidado e monitorar o texto gerado por eles antes de sua utilização.


Conclusão
---------


Resumimos a jornada e os desenvolvimentos dos modelos OpenAI GPT e sua evolução ao longo deste e dos capítulos anteriores. Esses modelos são, sem dúvida, modelos de linguagem muito poderosos e revolucionaram o domínio do Processamento de Linguagem Natural ao realizar uma infinidade de tarefas usando apenas as instruções e alguns exemplos. Embora estes modelos não estejam em pé de igualdade com os humanos no entendimento da linguagem natural, eles certamente mostraram um caminho a seguir para atingir esse objetivo.


Referências:



[Processamento de Linguagem Natural](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers)


[Attention Is All You Need](https://arxiv.org/abs/1706.03762)


[OpenAI](https://openai.com/blog/openai-api/)


[The Journey of Open AI GPT models](https://medium.com/walmartglobaltech/the-journey-of-open-ai-gpt-models-32d95b7b7fb2)


[The Ultimate Guide to OpenAI’s GPT-3 Language Model](https://www.twilio.com/blog/ultimate-guide-openai-gpt-3-language-model)


[You Can Actually Understand GPT-3 With These YouTube Videos](https://towardsdatascience.com/you-can-understand-gpt-3-with-these-youtube-videos-6a30887c928b)


[GPT-3 Explained in Under 3 Minutes](https://daleonai.com/gpt3-explained-fast)



<div id="capitulo-83---liquid-neural-network---rede-neural-liquida"></div>

# Capítulo 83 – Liquid Neural Network – Rede Neural Líquida


A partir deste capítulo vamos estudar algumas arquiteturas de Deep Learning bem modernas e recentes que começam a ganhar destaque à medida que a Inteligência Artificial evolui. Muitas dessas arquiteturas são variações das arquiteturas estudada ao longo deste livro. Vale ressaltar, que boa parte do que vimos neste livro surgiu ou evoluiu nos últimos 5 anos. Ou seja, estamos fazendo parte dessa história. Isso não é formidável? 


Vejamos o que são as **Liquid Neural Networks** e como elas podem revolucionar o diagnóstico médico e a direção autônoma de veículos.


Os pesquisadores do MIT desenvolveram um tipo de rede neural que aprende *on-the-fly*, não apenas durante sua fase de treinamento. Esses algoritmos flexíveis, chamados de redes neurais “líquidas”, mudam suas equações para se adaptar continuamente a novas entradas de dados. O avanço pode ajudar na tomada de decisões com base em fluxos de dados que mudam com o tempo, incluindo aqueles envolvidos no diagnóstico médico e na direção autônoma de veículos.


“Este é um caminho a seguir para o futuro do controle de robôs, processamento de linguagem natural, processamento de vídeo e qualquer forma de processamento de dados de série temporal”, diz Ramin Hasani, o principal autor do estudo. “O potencial é realmente significativo”.


![Machine-learning](https://www.deeplearningbook.com.br/wp-content/uploads/2021/02/Machine-learning.jpg)


A pesquisa será apresentada na Conferência AAAI sobre Inteligência Artificial em Fevereiro/2021. Além de Hasani, um pós-doutorado no Laboratório de Ciência da Computação e Inteligência Artificial do MIT (CSAIL), os co-autores do MIT incluem Daniela Rus, diretora do CSAIL e o Professor Andrew e Erna Viterbi de Engenharia Elétrica e Ciência da Computação e aluno de PhD Alexander Amini. Outros co-autores incluem Mathias Lechner do Instituto de Ciência e Tecnologia da Áustria e Radu Grosu da Universidade de Tecnologia de Viena.


Os dados de séries temporais são onipresentes e vitais para nossa compreensão do mundo, de acordo com Hasani. “O mundo real tem tudo a ver com sequências. Mesmo nossa percepção – você não está percebendo imagens, está percebendo sequências de imagens”, diz ele. “Portanto, os dados de série temporal realmente criam nossa realidade.”


Ele aponta os aplicativos de processamento de vídeo, dados financeiros e diagnósticos médicos como exemplos de séries temporais fundamentais para a sociedade. As vicissitudes desses fluxos de dados em constante mudança podem ser imprevisíveis. Ainda assim, analisar esses dados em tempo real e usá-los para antecipar comportamento futuro, pode impulsionar o desenvolvimento de tecnologias emergentes, como carros autônomos. Então, Hasani construiu um algoritmo adequado para a tarefa.


Caso queira aprender a aplicar modelos de Machine Learning a fluxos de dados em tempo real, mostramos isso em detalhes no curso [Big Data Real-Time Analytics com Python e Spark](https://www.datascienceacademy.com.br/course/analise-de-dados-com-python).


Hasani projetou uma rede neural que pode se adaptar à variabilidade dos sistemas do mundo real. Redes neurais são algoritmos que reconhecem padrões por meio da análise de um conjunto de exemplos de “treinamento”. Costuma-se dizer que elas imitam as vias de processamento do cérebro – definiu Hasani. “Uma rede neural artificial pode ter apenas 302 neurônios em seu sistema nervoso”, diz ele, “mas pode gerar uma dinâmica inesperadamente complexa.”


Hasani codificou sua rede neural com atenção especial ao comportamento dos neurônios que se ativam e se comunicam entre si por meio de impulsos elétricos. Nas equações que usou para estruturar sua rede neural, ele permitiu que os parâmetros mudassem ao longo do tempo com base nos resultados de um conjunto de equações diferenciais.


Essa flexibilidade é fundamental. O comportamento da maioria das redes neurais é corrigido após a fase de treinamento, o que significa que não conseguem se ajustar às mudanças no fluxo de dados de entrada. Hasani diz que a fluidez de sua rede “líquida” a torna mais resistente a imprevistos ou dados barulhentos, como se a chuva forte obscurecesse a visão de uma câmera em um carro que dirige sozinho. “Portanto, é mais robusto”, diz ele.


Há outra vantagem da flexibilidade da rede, ele acrescenta: “É mais interpretável”.


Hasani diz que sua rede líquida contorna a inescrutabilidade comum a outras redes neurais. “Apenas mudando a representação de um neurônio”, o que Hasani fez com as equações diferenciais, “você pode realmente explorar alguns graus de complexidade que não poderia explorar de outra forma.” Para o pequeno número de neurônios altamente expressivos de Hasani, é mais fácil examinar a “caixa preta” da tomada de decisão da rede e diagnosticar por que a rede fez uma certa caracterização.


“O modelo em si é mais rico em termos de expressividade”, diz Hasani. Isso pode ajudar os engenheiros a entender e melhorar o desempenho da rede.


A rede de Hasani se destacou em uma bateria de testes. Ela superou outros algoritmos de série temporal de última geração em alguns pontos percentuais ao prever com precisão valores futuros em conjuntos de dados, que vão desde a química atmosférica até os padrões de tráfego. “Em muitas aplicações vemos que o desempenho é confiavelmente alto “, diz ele. Além disso, o pequeno tamanho da rede significava permitiu que os testes fossem concluídos sem um alto custo de computação. “Todo mundo fala em aumentar a escala de sua rede”, diz Hasani. “Queremos diminuir, ter menos nós, porém mais ricos.”


Hasani planeja continuar melhorando o sistema e prepará-lo para aplicação industrial. “Temos uma rede neural comprovadamente mais expressiva, inspirada na natureza. Mas este é apenas o começo do processo”, diz ele. “A questão óbvia é como fazer para estender isso? Achamos que este tipo de rede poderia ser um elemento-chave dos sistemas de inteligência futuros.”


Esta pesquisa foi financiada, em parte, pela Boeing, a National Science Foundation, o Austrian Science Fund e Electronic Components and Systems for European Leadership.


No próximo capítulo estudamos um pouco mais essa arquitetura. Até lá.


Referências:


[Why is ‘Liquid’ Neural Network From MIT a Revolutionary Innovation?](https://www.analyticsinsight.net/why-is-liquid-neural-network-from-mit-a-revolutionary-innovation/)


[“Liquid” machine-learning system adapts to changing conditions](https://news.mit.edu/2021/machine-learning-adapts-0128)


<div id="capitulo-84---clip-(contrastive-language-image-pre-training):-conectando-texto-e-imagens"></div>

# Capítulo 84 – CLIP (Contrastive Language Image Pre-training): Conectando Texto e Imagens


O ano de 2021 começou com um estrondo! A OpenAI lançou duas grandes inovações no campo da Visão Computacional: CLIP e DALL-E.


A rede CLIP tem uma abordagem realmente interessante e possivelmente revolucionária para tarefas de classificação de imagens usando o pré-treinamento contrastante para realizar o aprendizado zero-shot semelhante ao do GPT-3, que abordamos em capítulos anteriores.


Embora o aprendizado profundo (Deep Learning) tenha revolucionado a Visão Computacional, as abordagens atuais têm vários problemas: conjuntos de dados de visão computacional típicos são trabalhosos e caros para criar, enquanto ensinam apenas um conjunto estreito de conceitos visuais; os modelos de visão computacional padrão são bons em uma tarefa e apenas em uma tarefa, e requerem um esforço significativo para se adaptar a uma nova tarefa; e os modelos que apresentam bom desempenho em benchmarks apresentam desempenho decepcionantemente ruim em testes de estresse, lançando dúvidas sobre toda a abordagem de aprendizado profundo para visão computacional.


Mas a OpenAI criou uma rede neural que visa resolver esses problemas: é treinada em uma ampla variedade de imagens com uma ampla variedade de supervisão de linguagem natural que está abundantemente disponível na internet. Por design, a rede pode ser instruída em linguagem natural para realizar uma grande variedade de benchmarks de classificação, sem otimizar diretamente para o desempenho do benchmark, semelhante aos recursos de “tiro zero” (Zero-Shot) do GPT-2 e GPT-3. Esta é uma mudança importante: ao não otimizar diretamente para o benchmark, o modelo se torna muito mais representativo e o sistema fecha essa “lacuna de robustez” em até 75%, ao mesmo tempo em que iguala o desempenho do ResNet-50 original no ImageNet zero-shot sem usar nenhum dos os exemplos rotulados de 1,28M originais.


![CLIP](https://www.deeplearningbook.com.br/wp-content/uploads/2021/03/clip-1024x1024.png)


Embora os dois modelos acima tenham a mesma precisão no conjunto de teste ImageNet, o desempenho do CLIP é muito mais representativo de como se sairá em conjuntos de dados que medem a precisão em diferentes configurações não ImageNet. Por exemplo, ObjectNet verifica a capacidade de um modelo de reconhecer objetos em muitas poses diferentes e com muitos fundos diferentes dentro de casas, enquanto ImageNet Rendition e ImageNet Sketch verificam a capacidade de um modelo de reconhecer representações mais abstratas de objetos.


O Que e CLIP Tenta Resolver?
----------------------------


Antes de entender como o CLIP funciona, vamos ver o que a OpenAI pretende resolver.


Temos visto grandes melhorias na visão computacional para resolver uma infinidade de problemas, mas cada uma delas vem com suas desvantagens, como:


Muitos modelos de visão computacional atuais, como ResNet e InceptionNet, são capazes de atingir desempenho de nível humano em conjuntos de dados de classificação de imagens complexos, no entanto, eles precisam da disponibilidade de grandes conjuntos de dados, o que é difícil de criar.


Mesmo que os modelos de última geração possam ter um desempenho extremamente bom em conjuntos de dados como ImageNet, eles caem drasticamente quando introduzidos em variantes ou dados prontos para uso, pois foram otimizados apenas para desempenho no benchmark e falham em desempenho em cenários da vida real .


O OpenAI visa resolver esses problemas de grandes conjuntos de dados e desempenho ruim na vida real com o CLIP. O CLIP não só provou fornecer resultados de última geração na classificação de imagens, mas também outras tarefas de visão, como classificação de objetos, reconhecimento de ações em vídeos e OCR. Isso mostra que um único algoritmo como o CLIP pode trabalhar com uma variedade de tarefas e conjuntos de dados sem a necessidade de construir conjuntos de dados enormes, mas é caro do ponto de vista computacional.


O CLIP também desempenha um papel vital no funcionamento do DALL-E, que amos abordar nos capítulos seguintes!


Compreendendo a Arquitetura CLIP
--------------------------------


CLIP (Contrastive Language – Image Pre-training) baseia-se em um grande corpus de trabalho em transferência zero-shot, supervisão de linguagem natural e aprendizagem multimodal. A ideia de aprendizado de dados zero-shot remonta a mais de uma década, mas até recentemente era estudada principalmente em visão computacional como uma forma de generalizar para categorias de objetos invisíveis. Um insight crítico foi alavancar a linguagem natural como um espaço de previsão flexível para permitir a generalização e transferência. Em 2013, Richer Socher e coautores em Stanford desenvolveram uma prova de conceito treinando um modelo no dataset CIFAR-10 para fazer previsões em um espaço de incorporação de vetores de palavras e mostraram que esse modelo poderia prever duas classes invisíveis. No mesmo ano, DeVISE escalou essa abordagem e demonstrou que era possível ajustar um modelo ImageNet para que pudesse generalizar para prever corretamente objetos fora do conjunto de treinamento original.


Mais inspirador para o CLIP é o trabalho de Ang Li e seus co-autores na FAIR, que em 2016 demonstrou o uso de supervisão de linguagem natural para permitir a transferência zero-shot para vários conjuntos de dados de classificação de visão computacional existentes, como o conjunto de dados ImageNet. Eles conseguiram isso ajustando um modelo ImageNet CNN (Convolutional Neural Network, que estudamos ao longo deste livro) para prever um conjunto muito mais amplo de conceitos visuais (visuais n-gramas) a partir do texto de títulos, descrições e tags de 30 milhões de fotos do Flickr e foram capazes de alcançar 11,5% de precisão no ImageNet tiro zero.


Finalmente, CLIP faz parte de um grupo de artigos que revisitam a aprendizagem de representações visuais a partir da supervisão de linguagem natural. Esta linha de trabalho usa arquiteturas mais modernas como o Transformer e inclui VirTex, que explorou a modelagem de linguagem autoregressiva, ICMLM, que investigou a modelagem de linguagem mascarada, e ConVIRT, que estudou o mesmo objetivo contrastivo usado no CLIP, mas no campo de imagens médicas.


Não é incrível estarmos escrevendo neste momento a história da Inteligência Artificial que vai impactar a história da própria humanidade ao longo dos próximos anos? Se você concorda, acompanhe os próximos capítulos.


Referências:


[Formação Engenheiro de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


[CLIP: Connecting Text and Images](https://openai.com/blog/clip/)


[A study and comparison of human and deep learning recognition performance under visual distortions](https://arxiv.org/abs/1705.02498)


[ImageNet-trained CNNs are biased towards texture; increasing shape bias improves accuracy and robustness](https://openreview.net/pdf?id=Bygh9j09KX)


[Strike (with) a pose: Neural networks are easily fooled by strange poses of familiar objects.](https://openaccess.thecvf.com/content_CVPR_2019/papers/Alcorn_Strike_With_a_Pose_Neural_Networks_Are_Easily_Fooled_by_CVPR_2019_paper.pdf)


[Objectnet: A large-scale bias-controlled dataset for pushing the limits of object recognition models](https://papers.nips.cc/paper/2019/file/97af07a14cacba681feacf3012730892-Paper.pdf)


[Language Models are Unsupervised Multitask Learners](https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf)


<div id="capitulo-85---transformadores---o-estado-da-arte-em-processamento-de-linguagem-natural"></div>

# Capítulo 85 – Transformadores – O Estado da Arte em Processamento de Linguagem Natural


Transformadores (Transformers) representam uma arquitetura de Deep Learning que visa resolver tarefas sequence-to-sequence enquanto lida com dependências de longo alcance com facilidade. Esse não é um conceito fácil de compreender, mas ajudaremos você!


Vamos iniciar agora uma sequência de capítulos baseados no artigo: [Attention is All You Need](https://arxiv.org/abs/1706.03762) (Atenção é tudo que você precisa). E os autores não estavam brincando quando escolheram esse título porque você vai precisar de toda a atenção à sua disposição para isso. Mas não deixe isso te assustar, pois vai valer a pena!


O famoso paper “Atenção é tudo que você precisa” de 2017 mudou a forma como pensávamos sobre a atenção. Com dados suficientes, multiplicações de matrizes, camadas lineares e normalização de camadas, podemos realizar a tradução automática de texto de última geração, desejo antigo de quem trabalha com Inteligência Artificial.


No entanto, 2020 foi definitivamente o ano dos transformadores! Da linguagem natural agora eles estão em tarefas de visão computacional. Como passamos da atenção para a auto-atenção? Por que o transformador funciona tão bem? Quais são os componentes críticos para seu sucesso?


Acompanhe essa sequência de capítulos e descubra! Vamos começar com algumas definições.


O Que é um Transformador?
-------------------------


O Transformer em Processamento de Linguagem Natural é uma arquitetura que visa resolver tarefas sequence-to-sequence enquanto lida com dependências de longo alcance com facilidade. Ele se baseia inteiramente na autoatenção (Self-Attention) para computar as representações de sua entrada e saída SEM usar RNNs (Redes Neurais Recorrentes) alinhadas em sequência ou convolução. ?


O Transformer é um modelo de aprendizado profundo introduzido em 2017 que utiliza o mecanismo de atenção, pesando a influência de diferentes partes dos dados de entrada. É usado principalmente no campo do Processamento de Linguagem Natural (PLN), mas pesquisas recentes também desenvolveram sua aplicação em outras tarefas, como compreensão de vídeo. 


Assim como as Redes Neurais Recorrentes (RNNs), os transformadores são projetados para lidar com dados de entrada sequenciais, como linguagem natural, para tarefas como tradução e resumo de texto. No entanto, ao contrário das RNNs, os Transformers não exigem que os dados sequenciais sejam processados ​​em ordem. Em vez disso, a operação de atenção identifica o contexto para qualquer posição na sequência de entrada. Por exemplo, se os dados de entrada forem uma frase em linguagem natural, o Transformer não precisará processar o início antes do final. Em vez disso, identifica o contexto que confere significado a uma palavra na frase. Devido a esse recurso, o Transformer permite muito mais paralelização do que RNNs e, portanto, reduz os tempos de treinamento. 


Os transformadores rapidamente se tornaram o modelo de escolha para problemas de PLN, substituindo modelos de rede neural recorrente, como a LSTM (Long-Short Term Memory). Como o modelo Transformer facilita a paralelização durante o treinamento, ele permite o treinamento em conjuntos de dados maiores do que era possível antes de ser introduzido. Isso levou ao desenvolvimento de sistemas pré-treinados, como BERT (Bidirectional Encoder Representations from Transformers) e GPT (Generative Pre-Training Transformer), que foram treinados com enormes conjuntos de dados de linguagem geral, como Wikipedia Corpus e Common Crawl, e podem ser ajustado para tarefas específicas de linguagem. 


Um Pouco de História
--------------------


Antes da introdução dos Transformers, a maioria dos sistemas de PLN de última geração contava com redes neurais recorrentes (RNNs), como LSTMs e unidades recorrentes com portas (GRUs), com mecanismos de atenção adicionais. O Transformer foi construído sobre essas tecnologias de atenção sem usar uma estrutura RNN, destacando o fato de que os mecanismos de atenção por si só, sem processamento sequencial recorrente, são poderosos o suficiente para atingir o desempenho das RNNs com atenção.


Conforme vimos em capítulos anteriores deste livro, as RNNs processam tokens sequencialmente, mantendo um vetor de estado que contém uma representação dos dados vistos após cada token. Para processar o token, o modelo combina o estado que representa a frase até o token com a informação do novo token para criar um novo estado, representando a frase até o token. Teoricamente, as informações de um token podem se propagar arbitrariamente ao longo da sequência, se em todos os pontos o estado continuar a codificar informações contextuais sobre o token. Mas, na prática, esse mecanismo é imperfeito: devido em parte ao problema do desaparecimento do gradiente, o estado do modelo no final de uma frase longa geralmente não contém informações precisas e *extraíveis* sobre os tokens anteriores.


Este problema foi resolvido com a introdução de mecanismos de atenção. Os mecanismos de atenção permitem que um modelo olhe diretamente e se baseie no estado em qualquer ponto anterior ao longo da frase. A camada de atenção pode acessar todos os estados anteriores e pesá-los de acordo com alguma medida de relevância aprendida para o token atual, fornecendo informações mais nítidas sobre tokens relevantes distantes. Um exemplo claro da utilidade da atenção está na tradução, onde o contexto é fundamental para determinar o significado de uma palavra em uma frase. Em um sistema de tradução de inglês para francês, a primeira palavra da saída em francês provavelmente depende muito do início da entrada em inglês. 


No entanto, em um modelo LSTM de codificador-decodificador clássico, para produzir a primeira palavra da saída em francês, o modelo recebe apenas o vetor de estado da última palavra em inglês. Teoricamente, esse vetor pode codificar informações sobre toda a frase em inglês, fornecendo ao modelo todo o conhecimento necessário, mas na prática essas informações muitas vezes não são bem preservadas. Se um mecanismo de atenção for introduzido, o modelo pode, em vez disso, aprender os estados dos primeiros tokens em inglês ao produzir o início da saída em francês, dando a ele um conceito muito melhor do que está traduzindo.


Quando adicionados às RNNs, os mecanismos de atenção levaram a grandes ganhos no desempenho. A introdução do Transformer trouxe à luz o fato de que os mecanismos de atenção eram poderosos em si mesmos, e que o processamento sequencial recorrente dos dados não era necessário para alcançar os ganhos de desempenho das RNNs com atenção. O Transformer usa um mecanismo de atenção sem ser uma RNN, processando todos os tokens ao mesmo tempo e calculando pesos de atenção entre eles. O fato de que os Transformers não dependem do processamento sequencial e se prestam muito facilmente à paralelização permite que os Transformers sejam treinados com mais eficiência em conjuntos de dados maiores.


Arquitetura
-----------


Como os modelos inventados antes dele, o Transformer é uma arquitetura codificador-decodificador. O codificador consiste em um conjunto de camadas de codificação que processa a entrada iterativamente uma camada após a outra e o decodificador consiste em um conjunto de camadas de decodificação que fazem a mesma coisa com a saída do codificador.


A função de cada camada do codificador é processar sua entrada para gerar codificações, contendo informações sobre quais partes das entradas são relevantes entre si. Ele passa seu conjunto de codificações para a próxima camada do codificador como entradas. Cada camada decodificadora faz o oposto, pegando todas as codificações e as processando, usando suas informações contextuais incorporadas para gerar uma sequência de saída. 


Para conseguir isso, cada codificador e camada de decodificador faz uso de um mecanismo de atenção, que para cada entrada, pesa a relevância de todas as outras entradas e extrai informações delas de acordo para produzir a saída. Cada camada do decodificador também tem um mecanismo de atenção adicional que extrai informações das saídas dos decodificadores anteriores, antes que a camada do decodificador extraia informações das codificações. Ambas as camadas do codificador e do decodificador têm uma rede neural feed-forward para processamento adicional das saídas e contêm conexões residuais e etapas de normalização de camada.


Como dito no início, não é um conceito trivial e recomendamos a leitura dos capítulos anteriores deste livro se quiser realmente compreender como chegamos aos Transformadores.


Nos próximos capítulos vamos estudar os Transformadores em mais detalhes e se quiser aplicar os Transformadores na prática, eles são abordados em quase todos os cursos da [Formação Engenheiro de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia). 


Até o próximo capítulo.


Referências:


[Processamento de Linguagem Natural com Transformers](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers)


[Attention Is All You Need](https://arxiv.org/abs/1706.03762)


[The Illustrated Transformer](http://jalammar.github.io/illustrated-transformer/)


[Understanding Attention In Deep Learning](https://towardsdatascience.com/attaining-attention-in-deep-learning-a712f93bdb1e)


[How Transformers work in deep learning and NLP: an intuitive introduction](https://theaisummer.com/transformer/)


<div id="capitulo-86---como-funcionam-os-transformadores-em-processamento-de-linguagem-natural---parte-1"></div>

# Capítulo 86 – Como Funcionam os Transformadores em Processamento de Linguagem Natural – Parte 1


A partir de agora e nos próximos capítulos vamos compreender o funcionamento dos Transformadores, uma das técnicas mais avançadas da atualidade em Inteligência Artificial, especialmente no Processamento de Linguagem Natural.


Os Transformadores não são tão difíceis de entender. É a combinação de todos os conceitos que pode tornar a compreensão complexa, incluindo a atenção. É por isso que vamos construir lentamente todos os conceitos fundamentais. Não tenha pressa. Não existe atalho para o aprendizado.


Com Redes Neurais Recorrentes (RNNs), costumamos tratar frases sequencialmente para manter a ordem da frase no lugar (já vimos isso em capítulos anteriores deste livro). Para satisfazer esse design, cada componente RNN (camada) precisa da saída anterior (oculta). Como tal, os cálculos LSTM empilhados são executados sequencialmente.


Até que os Transformadores aparecessem! O bloco de construção fundamental de um Transformador é a auto-atenção. Para começar, precisamos superar o processamento sequencial, recorrência e LSTMs!


Como?


Simplesmente alterando a representação de entrada!


Representando a Frase de Entrada
--------------------------------


A revolução do Transformador começou com uma pergunta simples: por que não alimentamos toda a sequência de entrada? Sem dependências entre estados ocultos! Isso pode ser legal!


Como exemplo, a frase “Hello, I love you” (“olá, eu te amo”):


![tokenization](https://www.deeplearningbook.com.br/wp-content/uploads/2021/06/tokenization-300x108.png)


Essa etapa de processamento geralmente é chamada de tokenização e é a primeira das três etapas antes de alimentarmos a entrada no modelo. Isso vale para qualquer técnica em PLN, conforme mostramos no curso de [Processamento de Linguagem Natural](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers) na DSA.


Portanto, em vez de uma sequência de elementos, agora temos um conjunto. Conjuntos são uma coleção de elementos distintos, onde a disposição dos elementos no conjunto não importa.


Em outras palavras, a ordem é irrelevante. Indicamos a entrada definida como:


![token](https://www.deeplearningbook.com.br/wp-content/uploads/2021/06/token-300x27.png)


Os elementos da sequência xi são chamados de tokens.


Após a tokenização, projetamos palavras em um espaço geométrico distribuído ou simplesmente construímos embeddings de palavras.


Word Embeddings
---------------


Em geral, um embedding é uma representação de um símbolo (palavra, caractere, frase) em um espaço distribuído de baixa dimensão de vetores de valor contínuo.


Palavras não são símbolos discretos. Elas estão fortemente correlacionadas uma com a outra. É por isso que quando as projetamos em um espaço euclidiano contínuo, podemos encontrar associações entre elas. Para compreender o que é espaço euclidiano recomendamos nosso curso de [Matemática Para Data Science](https://www.datascienceacademy.com.br/course/matematica-para-data-science).


Então, dependendo da tarefa, podemos empurrar os embedding de palavras para mais longe ou mantê-los juntos.


Idealmente, um embedding captura a semântica da entrada, colocando entradas semanticamente semelhantes próximas no espaço de embedding.


Na linguagem natural, podemos encontrar significados de palavras semelhantes ou até mesmo estruturas sintáticas semelhantes (ou seja, os objetos são agrupados). Em qualquer caso, quando você os projeta no espaço 2D ou 3D, você pode identificar visualmente alguns clusters. 


Para obter um exemplo prático das word embeddings, experimente brincar com este [notebook](https://www.tensorflow.org/text/guide/word_embeddings) fornecido pela equipe do TensorFlow.


Seguindo em frente, criaremos um truque para fornecer alguma noção de ordem no conjunto.


Codificações Posicionais
------------------------


Ao converter uma sequência em um conjunto (tokenização), você perde a noção de ordem.


Você consegue encontrar a ordem das palavras (tokens) na sequência: “Hello, I love you”? Provavelmente sim! Mas e quanto a 30 palavras não ordenadas?


Lembre-se de que o aprendizado de máquina envolve escala. A rede neural certamente não consegue entender nenhuma ordem em um conjunto.


Uma vez que os Transformadores processam sequências como conjuntos, eles são, em teoria, invariantes de permutação.


Vamos ajudá-los a ter um senso de ordem alterando ligeiramente os embeddings com base na posição. Oficialmente, a codificação posicional é um conjunto de pequenas constantes, que são adicionadas ao vetor de embeddings de palavras antes da primeira camada de auto-atenção.


Portanto, se a mesma palavra aparecer em uma posição diferente, a representação real será um pouco diferente, dependendo de onde ela aparece na frase de entrada.


![input-processing-tokenization-embedding](https://www.deeplearningbook.com.br/wp-content/uploads/2021/06/input-processing-tokenization-embedding-300x202.png)


No artigo original do Transformador, os autores criaram a função senoidal para a codificação posicional. A função seno diz ao modelo para prestar atenção a um determinado comprimento de onda lambda λ.


Em nosso caso, o lambda λ será dependente da posição na frase e i é usado para distinguir entre posições ímpares e pares. Matematicamente:


![formula](https://www.deeplearningbook.com.br/wp-content/uploads/2021/06/formula-300x95.png)


Isso contrasta com os modelos recorrentes, em que temos uma ordem, mas estamos lutando para prestar atenção aos tokens que não estão próximos o suficiente.


Agora podemos passar para a Parte 2. Até o próximo capítulo.


Os Transformadores estarão presentes na Formação IA Aplicada ao Direito, que será lançada em breve na DSA.


Referências:


[Attention Is All You Need](https://arxiv.org/abs/1706.03762)


[Deep Learning Para Aplicações de IA com PyTorch e Lightning](https://www.datascienceacademy.com.br/course/deep-learning-para-aplicacoes-de-ia-com-pytorch-e-lightning)


[Processamento de Linguagem Natural](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers)


[The Illustrated Transformer](https://jalammar.github.io/illustrated-transformer/)


[Understanding Attention In Deep Learning](https://towardsdatascience.com/attaining-attention-in-deep-learning-a712f93bdb1e)


[How Transformers work in deep learning and NLP: an intuitive introduction](https://theaisummer.com/transformer/)


<div id="capitulo-87---como-funcionam-os-transformadores-em-processamento-de-linguagem-natural---parte-2"></div>

# Capítulo 87 – Como Funcionam os Transformadores em Processamento de Linguagem Natural – Parte 2


Vamos seguir com a continuação do capítulo anterior. Este capítulo fornece algumas informações básicas necessárias para compreender o conceito por trás da autoatenção que veremos no capítulo seguinte. 


### Atenção Baseada em Recursos: Chave, Valor e Consulta


Os conceitos de consulta de chave-valor vêm de sistemas de recuperação de informações. É extremamente útil esclarecer esses conceitos primeiro.


Vamos começar com um exemplo de busca de um vídeo no youtube.


Quando você pesquisa (consulta) um vídeo específico, o mecanismo de pesquisa mapeia sua consulta em relação a um conjunto de chaves (título do vídeo, descrição, etc.) associado a possíveis vídeos armazenados. Em seguida, o algoritmo apresentará os vídeos (valores) com as melhores correspondências. Esta é a base da pesquisa baseada em conteúdo / recursos.


Trazendo essa ideia para mais perto da atenção do transformador, temos algo assim:


![transformador](https://www.deeplearningbook.com.br/wp-content/uploads/2021/06/transformador-1024x442.png)


Na recuperação de um único vídeo, a atenção está na escolha do vídeo com pontuação máxima de relevância.


Mas podemos relaxar essa ideia. Para este fim, a principal diferença entre os sistemas de atenção e recuperação é que introduzimos uma noção mais abstrata e suave de “recuperação” de um objeto. Ao definir um grau de semelhança (peso) entre nossas representações (vídeos para o youtube), podemos ponderar nossa consulta.


Em vez de escolher onde olhar de acordo com a posição dentro de uma sequência, agora prestamos atenção ao conteúdo que queremos olhar!


Portanto, avançando um passo, dividimos ainda mais os dados em pares de chave-valor.


Usamos as chaves para definir os pesos de atenção para ver os dados e os valores como as informações que realmente obteremos.


Para o chamado mapeamento chave-valor, precisamos quantificar a similaridade, que veremos a seguir.


### Semelhança Vetorial em Espaços Dimensionais Elevados


Em geometria, o produto vetorial interno é interpretado como uma projeção vetorial. Uma maneira de definir a similaridade do vetor é computar o produto interno normalizado. 


No espaço de baixa dimensão, como o exemplo 2D abaixo, isso corresponderia ao valor do cosseno.


![vector-similarity](https://www.deeplearningbook.com.br/wp-content/uploads/2021/06/vector-similarity-300x274.png)


 


Matematicamente:


![math](https://www.deeplearningbook.com.br/wp-content/uploads/2021/06/math-300x61.png)


Podemos associar a semelhança entre os vetores que representam qualquer coisa (por exemplo, animais) calculando o produto escalar, ou seja, o cosseno do ângulo.


Em transformadores, esta é a operação mais básica e é tratada pela camada de autoatenção, como veremos no capítulo seguinte.


Referências:


[Attention Is All You Need](https://arxiv.org/abs/1706.03762)


[Deep Learning Para Aplicações de IA com PyTorch e Lightning](https://www.datascienceacademy.com.br/course/deep-learning-para-aplicacoes-de-ia-com-pytorch-e-lightning)


[Processamento de Linguagem Natural](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers)


[The Illustrated Transformer](https://jalammar.github.io/illustrated-transformer/)


[Understanding Attention In Deep Learning](https://towardsdatascience.com/attaining-attention-in-deep-learning-a712f93bdb1e)


[How Transformers work in deep learning and NLP: an intuitive introduction](https://theaisummer.com/transformer/)


<div id="capitulo-88---como-funcionam-os-transformadores-em-processamento-de-linguagem-natural---parte-3"></div>

# Capítulo 88 – Como Funcionam os Transformadores em Processamento de Linguagem Natural – Parte 3


Vamos seguir nossa discussão sobre os Transformadores com a parte mais importante, a Auto-Atenção. Este capítulo considera que você leu os capítulos anteriores.


Auto-Atenção: O Encoder do Transformer
--------------------------------------


O que é Auto-Atenção?


“A Auto-Atenção, às vezes chamada de Intra-Atenção, é um mecanismo de atenção que relaciona diferentes posições de uma única sequência para computar uma representação da sequência.” ~ Ashish Vaswani et al. do Google Brain.


A Auto-Atenção nos permite encontrar correlações entre diferentes palavras de entrada, indicando a estrutura sintática e contextual da frase (e por isso os Transformadores, que são baseados na Auto-Atenção, são muito utilizados em Processamento de Linguagem Natural).


Vamos tomar como exemplo a sequência de entrada “Hello, I love you” (Olá, Eu te amo). Uma camada de Auto-Atenção treinada associará a palavra “love” às palavras ‘I” e “you” a um peso maior do que a palavra “Hello”. Pela linguística, sabemos que essas palavras compartilham uma relação sujeito-verbo-objeto e essa é uma maneira intuitiva de entender o que a Auto-Atenção irá capturar.


![self-attention-probability-score-matrix](https://www.deeplearningbook.com.br/wp-content/uploads/2021/07/self-attention-probability-score-matrix-226x300.png)


Na prática, o Transformer usa 3 representações diferentes: as consultas, chaves e valores da matriz de embedding. Isso pode ser feito facilmente multiplicando nossa entrada representada pela expressão abaixo:


![formula](https://www.deeplearningbook.com.br/wp-content/uploads/2021/07/form.png)


com 3 matrizes de peso diferentes, Wq, Wk e Wv. Em essência, é apenas uma multiplicação de matrizes de embeddings. O diagrama abaixo mostra como isso funciona:


![key-query-value](https://www.deeplearningbook.com.br/wp-content/uploads/2021/07/key-query-value-1024x287.png)


Tendo as matrizes Query (Q), Key (K) e Value (V), agora podemos aplicar a camada de Auto-Atenção como:


![form2](https://www.deeplearningbook.com.br/wp-content/uploads/2021/07/form2.png)


No artigo original dos Transformadores, a atenção do produto escalonado foi escolhida como uma função de pontuação para representar a correlação entre duas palavras (o peso da atenção). Observe que também podemos utilizar outra função de similaridade. A raiz quadrada de d\_k na fórmula acima age simplesmente como um fator de escala para garantir que os vetores não explodam.


Este termo simplesmente encontra a similaridade da consulta de pesquisa com uma entrada em um banco de dados. Finalmente, aplicamos uma função softmax para obter os pesos finais de atenção como uma distribuição de probabilidade (da mesma forma que fazemos em diversos modelos de Deep Learning para classificação).


Lembre-se de que distinguimos as Chaves (K) dos Valores (V) como representações distintas. Assim, a representação final é a matriz de Auto-Atenção (a expressão com softmax na fórmula acima) multiplicada pela matriz de valores V.


Podemos pensar na matriz de Auto-Atenção como para onde olhar e na matriz de valor como o que eu realmente quero obter.


E aqui há um detalhes sobre a similaridade do vetor:


Primeiro, temos matrizes em vez de vetores e, como resultado, multiplicações de matrizes. Em segundo lugar, não diminuímos pela magnitude do vetor, mas pelo tamanho da matriz (d\_k), que é o número de palavras em uma frase! E o tamanho da frase varia. 🙂


O que faríamos a seguir?


Normalização e conexões de salto curto, semelhantes ao processamento de um tensor após convolução (CNN) ou recorrência (RNN). Mas deixamos isso para o próximo capítulo. Até lá.


Referências:


[Attention Is All You Need](https://arxiv.org/abs/1706.03762)


[Deep Learning Para Aplicações de IA com PyTorch e Lightning](https://www.datascienceacademy.com.br/course/deep-learning-para-aplicacoes-de-ia-com-pytorch-e-lightning)


[Processamento de Linguagem Natural](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers)


[The Illustrated Transformer](https://jalammar.github.io/illustrated-transformer/)


[Understanding Attention In Deep Learning](https://towardsdatascience.com/attaining-attention-in-deep-learning-a712f93bdb1e)


[How Transformers work in deep learning and NLP: an intuitive introduction](https://theaisummer.com/transformer/)


<div id="capitulo-89---como-funcionam-os-transformadores-em-processamento-de-linguagem-natural---parte-4"></div>

# Capítulo 89 – Como Funcionam os Transformadores em Processamento de Linguagem Natural – Parte 4


Vamos prosseguir estudando os transformadores. *Este capítulo considera que você leu os capítulos anteriores*.


### Conexões Residuais de Salto Curto


Na linguagem, existe uma noção significativa de uma compreensão mais ampla do mundo e de nossa capacidade de combinar ideias. Os humanos utilizam amplamente essas influências de cima para baixo (nossas expectativas) para combinar palavras em diferentes contextos. De uma maneira bem simples, as conexões de salto curto fornecem a um transformador uma pequena capacidade de permitir que as representações de diferentes níveis de processamento interajam.


Com a formação de vários caminhos, podemos “passar” nosso entendimento de nível superior das últimas camadas do modelo, para as camadas anteriores. Isso nos permite remodular como entendemos a entrada. Novamente, essa é a mesma ideia do entendimento humano de cima para baixo, que nada mais é do que expectativas.


### Normalização de Camada


A seguir, vamos abrir a caixa preta do Layer Norm ou apenas LN (Normalização de Camada).


Na normalização de camada (LN), a média e a variância são calculadas entre canais e dimensões espaciais. Na linguagem, cada palavra é um vetor. Como estamos lidando com vetores, temos apenas uma dimensão espacial (mais detalhes sobre isso em [Matemática Para Data Science](https://www.datascienceacademy.com.br/course/matematica-para-data-science)).


![form1](https://www.deeplearningbook.com.br/wp-content/uploads/2021/11/form1-300x247.png)


Em um tensor 4D com dimensões espaciais combinadas, podemos visualizar isso com a seguinte figura:


![layer-norm](https://www.deeplearningbook.com.br/wp-content/uploads/2021/11/layer-norm-300x231.png)


Depois de aplicar uma camada de normalização e formar uma conexão residual de salto curto, estamos aqui:


![](https://www.deeplearningbook.com.br/wp-content/uploads/2021/11/encoders-attention-with-normalizarion-220x300.png)


Mesmo que este possa ser um bloco de construção autônomo, os criadores do transformador adicionam outra camada linear na parte superior e a renormalizam junto com outra conexão de salto curto.


### Camada Linear


Na sequência, os autores adicionaram uma camada linear à arquitetura. A intuição principal é que eles projetam a saída da auto-atenção em um espaço dimensional superior (ideia muito similar ao que é feito no algoritmo SVM estudado em detalhes no curso de [Machine Learning](https://www.datascienceacademy.com.br/course/machine-learning-engineer)). Isso resolve inicializações ruins e colapso de classificação. Mas vamos representá-lo nos diagramas simplesmente como Linear.


Esta é a parte do codificador do transformador com N blocos de construção, conforme ilustrado abaixo:


![encoder-without-multi-head](https://www.deeplearningbook.com.br/wp-content/uploads/2021/12/encoder-without-multi-head-164x300.png)


Na verdade, este é quase o codificador do transformador. Existe uma diferença. Atenção multi-cabeça (multi-head attention). No artigo original, os autores expandem a ideia de auto-atenção para a multi-head attention. Em essência, passamos pelo mecanismo de atenção várias vezes, conforme ilustrado na imagem abaixo:


![parallel-multi-head-attention](https://www.deeplearningbook.com.br/wp-content/uploads/2021/12/parallel-multi-head-attention.png)


Mas por que passar por todos esses problemas?


A intuição por trás da atenção com várias cabeças é que ela nos permite atender a diferentes partes da sequência de maneira diferente a cada vez. Isso praticamente significa que:


1- O modelo pode capturar melhor as informações posicionais porque cada cabeça atenderá a diferentes segmentos da entrada. A combinação deles nos dará uma representação mais robusta.


2- Cada cabeça também irá capturar diferentes informações contextuais, correlacionando palavras de uma maneira única.


Não perca o objetivo de vista. Tudo isso que é feito no Transformador tem um objetivo: criar Inteligência Artificial para o Processamento de Linguagem Natural, sendo esta uma das técnicas mais avançadas da atualidade.


Agora estamos em condições de resumir tudo que vimos até aqui e construir a arquitetura do Transformador. Exatamente o tema do próximo capítulo. Até lá.


Referências:


[Attention Is All You Need](https://arxiv.org/abs/1706.03762)


[Deep Learning Para Aplicações de IA com PyTorch e Lightning](https://www.datascienceacademy.com.br/course/deep-learning-para-aplicacoes-de-ia-com-pytorch-e-lightning)


[Processamento de Linguagem Natural](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers)


[The Illustrated Transformer](https://jalammar.github.io/illustrated-transformer/)


[Understanding Attention In Deep Learning](https://towardsdatascience.com/attaining-attention-in-deep-learning-a712f93bdb1e)


[How Transformers work in deep learning and NLP: an intuitive introduction](https://theaisummer.com/transformer/)


<div id="capitulo-90---como-funcionam-os-transformadores-em-processamento-de-linguagem-natural---parte-5"></div>

# Capítulo 90 – Como Funcionam os Transformadores em Processamento de Linguagem Natural – Parte 5


Vamos prosseguir estudando os transformadores. *Este capítulo considera que você leu os capítulos anteriores*.


Vamos começar esta capítulo com um resumo do Transformer. Para processar uma frase, precisamos destes 3 passos:


1- Embeddings de palavras da sentença de entrada são computados simultaneamente.


2- Codificações posicionais são então aplicadas a cada Embeddings, resultando em vetores de palavras que também incluem informações posicionais.


3- Os vetores de palavras são passados para o primeiro bloco do codificador.


Cada bloco consiste nas seguintes camadas na mesma ordem:


* Uma camada de autoatenção de várias cabeças para encontrar correlações entre cada palavra.
* Uma camada de normalização.
* Uma conexão residual em torno das duas subcamadas anteriores.
* Uma camada linear.
* Uma segunda camada de normalização.
* Uma segunda conexão residual.


Observe que o bloco acima pode ser replicado várias vezes para formar o Encoder. No papel original, o codificador é composto por 6 blocos como na imagem abaixo.


![](https://www.deeplearningbook.com.br/wp-content/uploads/2022/01/encoder.png)


Vamos ver o que pode ser diferente na parte do decodificador.


O decodificador consiste em todos os componentes acima mencionados mais dois novos. Como antes:


1- A sequência de saída é alimentada em sua totalidade e os embeddings de palavras são calculados.


2- A codificação posicional é novamente aplicada.


3- E os vetores são passados para o primeiro bloco Decoder


Cada bloco decodificador inclui:


* Uma camada de autoatenção de várias cabeças.
* Uma camada de normalização seguida por uma conexão residual.
* Uma nova camada de atenção de várias cabeças (conhecida como atenção Encoder-Decoder).
* Uma segunda camada de normalização e uma conexão residual.
* Uma camada linear e uma terceira conexão residual.


O bloco decodificador aparece novamente 6 vezes. A saída final é transformada através de uma camada linear final e as probabilidades de saída são calculadas com a função softmax padrão. A imagem abaixo traz um resumo.


![](https://www.deeplearningbook.com.br/wp-content/uploads/2022/01/decoder.png)


As probabilidades de saída predizem o próximo token na sentença de saída. Como? Em essência, atribuímos uma probabilidade a cada palavra e simplesmente mantemos aquela com a maior pontuação.


Para colocar as coisas em perspectiva, o modelo original foi treinado no conjunto de dados inglês-francês do WMT 2014, composto por 36 milhões de frases e 32.000 tokens.


Embora a maioria dos conceitos do decodificador já seja familiar, há mais dois que precisamos discutir. Vamos começar com a camada de autoatenção de várias cabeças mascaradas.


### Masked Multi-head Attention


Caso você não tenha percebido, na etapa de decodificação, prevemos uma palavra (token) após a outra. Em problemas de PLN como a tradução automática, a previsão sequencial de tokens é inevitável. Como resultado, a camada de autoatenção precisa ser modificada para considerar apenas a sentença de saída gerada até o momento.


Em nosso exemplo de tradução, a entrada do decodificador na terceira passagem será “Bonjour”, “je” … …”.


Como você pode ver, a diferença aqui é que não conhecemos a frase inteira porque ela ainda não foi produzida. É por isso que precisamos desconsiderar as palavras desconhecidas. Caso contrário, o modelo apenas copiaria a próxima palavra! Para conseguir isso, mascaramos os próximos embeddings de palavras.


Matematicamente temos:


![](https://www.deeplearningbook.com.br/wp-content/uploads/2022/01/form1-300x55.png)


onde a matriz M (máscara) consiste em zeros e -inf.


Zeros se tornarão uns com o exponencial enquanto infinitos se tornarão zeros.


Isso efetivamente tem o mesmo efeito que remover a conexão correspondente. Os princípios restantes são exatamente os mesmos que a atenção do codificador. E mais uma vez, podemos implementá-los em paralelo para acelerar os cálculos.


Obviamente, a máscara mudará para cada novo token que computarmos.


### Atenção Codificador-Decodificador: Onde a Mágica Acontece


Na verdade, é aqui que o decodificador processa a representação codificada. A matriz de atenção gerada pelo codificador é passada para outra camada de atenção juntamente com o resultado do bloco de atenção Masked Multi-head anterior.


A intuição por trás da camada de atenção codificador-decodificador é combinar a sentença de entrada e saída. A saída do codificador encapsula a embedding final da sentença de entrada. É como nosso banco de dados. Portanto, usaremos a saída do codificador para produzir as matrizes Key e Value. Por outro lado, a saída do bloco de atenção Masked Multi-head contém a nova sentença gerada até agora e é representada como a matriz de consulta na camada de atenção. Novamente, é a “pesquisa” no banco de dados.


Ele acabará por determinar o quão relacionado cada palavra em inglês está em relação às palavras em francês. É essencialmente aí que está acontecendo o mapeamento entre inglês e francês.


Observe que a saída do último bloco do codificador será utilizada em cada bloco do decodificador.


### Por Que os Transformadores Funcionam Tão Bem?


1- Representações distribuídas e independentes em cada bloco: Cada bloco transformador tem 8 representações contextualizadas. Intuitivamente, você pode pensar nisso como os vários mapas de recursos de uma camada de convolução que capturam diferentes recursos da imagem. A diferença com as convoluções é que aqui temos múltiplas vistas (reprojeções lineares) para outros espaços. Obviamente, isso é possível ao representar inicialmente palavras como vetores em um espaço euclidiano (e não como símbolos discretos).


2- O significado depende muito do contexto: é exatamente disso que se trata a autoatenção! Associamos relações entre a representação de palavras expressa pelos pesos de atenção. Não há noção de localidade, pois naturalmente deixamos o modelo fazer associações globais.


3- Vários blocos de codificador e decodificador: Com mais camadas, o modelo faz representações mais abstratas. Semelhante ao empilhamento de blocos recorrentes ou de convolução, podemos empilhar vários blocos de transformadores. O primeiro bloco associa pares palavra-vetor, o segundo pares de pares, o terceiro de pares de pares de pares e assim por diante. Em paralelo, as múltiplas cabeças se concentram em diferentes segmentos dos pares. Isso é análogo ao campo receptivo, mas em termos de pares de representações distribuídas.


4- Combinação de informações de alto e baixo nível: com conexões de salto, é claro! Eles permitem que a compreensão de cima para baixo flua de volta com os vários caminhos de gradiente que fluem para trás.


### Autoatenção x Camadas Lineares x Convoluções


Qual é a diferença entre atenção e uma camada de feed forward em um modelo padrão de rede neural? As camadas lineares não fazem exatamente as mesmas operações para um vetor de entrada como atenção?


Boa pergunta! A resposta é não se você se aprofundar nos conceitos.


Você vê que os valores dos pesos de autoatenção são calculados em tempo real. Eles são pesos dinâmicos dependentes de dados porque mudam dinamicamente em resposta aos dados (pesos rápidos).


Por exemplo, cada palavra na sequência traduzida (Bonjour, je t’aime) atenderá de forma diferente em relação à entrada.


Por outro lado, os pesos de uma camada feedforward (linear) mudam muito lentamente com a descida do gradiente estocástico. Em convoluções, restringimos ainda mais o peso (lento) para ter um tamanho fixo, ou seja, o tamanho do kernel.


### Conclusão


Ufa! Compreendeu agora porque a Inteligência Artificial é algo tão incrível? Usamos a Matemática via programação de computadores para fazer a mágica acontecer. E isso está revolucionando o mundo como conhecemos!


O Transformer é um conceito mais avançado e nosso objetivo aqui foi trazer uma visão geral. Concluímos aqui a parte sobre Transformer.


Mas temos ainda mais 10 capítulos pela frente para concluir o Deep Learning Book. Que tal uma revisão completa e gratuita sobre Machine Learning para encerrar este livro? É o que teremos nos 10 capítulos finais. Não perca.


Referências:


[Attention Is All You Need](https://arxiv.org/abs/1706.03762)


[Deep Learning Para Aplicações de IA com PyTorch e Lightning](https://www.datascienceacademy.com.br/course/deep-learning-para-aplicacoes-de-ia-com-pytorch-e-lightning)


[Processamento de Linguagem Natural](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers)


[The Illustrated Transformer](https://jalammar.github.io/illustrated-transformer/)


[Understanding Attention In Deep Learning](https://towardsdatascience.com/attaining-attention-in-deep-learning-a712f93bdb1e)


[How Transformers work in deep learning and NLP: an intuitive introduction](https://theaisummer.com/transformer/)


<div id="capitulo-91---machine-learning---guia-definitivo---parte-1"></div>

# Capítulo 91 – Machine Learning – Guia Definitivo – Parte 1


Nos 10 capítulos finais deste livro online vamos trazer um grande resumo sobre Machine Learning. O objetivo é fornecer uma visão clara do que é e como Machine Learning está sendo usado no dia a dia, um pouco de matemática, as principais regras e princípios. Queremos ainda que esses capítulos finais possam servir de material de referência para os alunos que estão buscando as certificações oferecidas pela DSA no [Bootcamp de Certificação](https://www.datascienceacademy.com.br/course/bootcamp-cientista-de-dados).


Serão 10 partes no total com um guia completo sobre Machine Learning. Aproveite a leitura para compreender de forma definitiva o que é uma das tecnologias mais incríveis do nosso tempo.


Começaremos com uma visão geral! Boa leitura.


Visão Geral
-----------


O Aprendizado de Máquina ([Machine Learning](https://www.datascienceacademy.com.br/course/machine-learning-em-python-e-c)) está por trás de chatbots, aplicativos de tradução de idiomas, os programas que a Netflix sugere para você e como seus feeds de mídia social são apresentados. Machine Learning alimenta veículos e máquinas autônomos que podem diagnosticar condições médicas com base em imagens. Deep Learning, que estudamos ao longo de todo este livro até aqui, é um subcampo de Machine Learning.


Quando as empresas hoje implantam programas de [Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia), provavelmente estão usando Machine Learning – tanto que os termos são frequentemente usados ​​​​de forma intercambiável e às vezes ambígua. O Aprendizado de Máquina é um subcampo da Inteligência Artificial (IA) que dá aos computadores a capacidade de aprender sem serem explicitamente programados.


Nos últimos 10 anos, o Aprendizado de Máquina se tornou a principal técnica por trás de aplicações de IA. É por isso que algumas pessoas usam os termos IA e Aprendizado de Máquina quase como sinônimos, pois a maioria dos avanços atuais em IA envolvem Aprendizado de Máquina.


Com a crescente onipresença de aplicações de Machine Learning, todos os negócios provavelmente o encontrarão e precisarão de algum conhecimento prático sobre esse campo. Uma [pesquisa da Deloitte](https://www2.deloitte.com/us/en/insights/focus/cognitive-technologies/state-of-ai-and-intelligent-automation-in-business-survey.html) descobriu que 67% das empresas estão usando Aprendizado de Máquina e 97% estão usando ou planejando usá-lo no futuro próximo.


Da manufatura ao varejo e do setor bancário à agricultura, há muitas empresas usando Machine Learning para aumentar a eficiência. “O Aprendizado de Máquina está mudando, ou mudará, todos os setores e os líderes precisam entender os princípios básicos, o potencial e as limitações”, disse o professor de ciência da computação do MIT, Aleksander Madry, diretor do MIT Center for Deployable Machine Learning.


Embora nem todos precisem conhecer os detalhes técnicos, eles devem entender o que a tecnologia faz e o que ela pode e não pode fazer (ainda). Ninguém pode se dar ao luxo de não estar ciente do que está acontecendo.


Isso inclui estar ciente das implicações sociais e éticas do Aprendizado de Máquina. “É importante se engajar e começar a entender essas ferramentas e depois pensar em como você vai usá-las para o bem. Temos que usar essas ferramentas para o bem de todos”, disse o Dr. Joan LaRovere, médico pediátrico de terapia intensiva cardíaca e cofundador da The Virtue Foundation, organização sem fins lucrativos. “A IA tem muito potencial para fazer o bem e precisamos realmente manter isso em nossas lentes enquanto pensamos nisso. Como usamos a tecnologia para fazer o bem e melhorar o mundo?”


Mas Afinal, o Que é Machine Learning?
-------------------------------------


O Aprendizado de Máquina é um subcampo da Inteligência Artificial (e Deep Learning é um subcampo de Machine Learning), que é amplamente definido como a capacidade de uma máquina de imitar o comportamento humano inteligente. Os sistemas de Inteligência Artificial são usados ​​para realizar tarefas complexas de maneira semelhante à forma como os humanos resolvem problemas.


O objetivo da IA ​​é criar modelos de computador que exibam “comportamentos inteligentes” como os humanos, de acordo com Boris Katz, principal cientista de pesquisa e chefe do Grupo InfoLab no [CSAIL](https://www.csail.mit.edu/). Isso significa máquinas que podem reconhecer uma cena visual, entender um texto escrito em linguagem natural ou realizar uma ação no mundo físico.


O Aprendizado de Máquina é uma maneira de usar a IA. Foi definido na década de 1950 pelo pioneiro da IA ​​Arthur Samuel como “o campo de estudo que dá aos computadores a capacidade de aprender sem serem explicitamente programados”.


A definição é verdadeira, de acordo com Mikey Shulman, professor do MIT Sloan e chefe de Aprendizado de Máquina da Kensho, especializada em Inteligência Artificial para as comunidades de finanças e inteligência dos EUA. Ele comparou a maneira tradicional de programar computadores, ou “software 1.0”, à panificação, onde uma receita pede quantidades precisas de ingredientes e diz ao padeiro para misturar por um período exato de tempo. A programação tradicional também requer a criação de instruções detalhadas para o computador seguir.


Mas, em alguns casos, escrever um programa para a máquina seguir é demorado ou impossível, como treinar um computador para reconhecer fotos de pessoas diferentes. Embora os humanos possam fazer essa tarefa facilmente, é difícil dizer a um computador como fazê-lo. O Aprendizado de Máquina adota a abordagem de permitir que os computadores aprendam a se programar por meio da experiência.


O Aprendizado de Máquina começa com dados – números, textos, transações bancárias, fotos de pessoas, registros de acesso a servidores web, dados de séries temporais de sensores ou relatórios de vendas. Os dados são coletados e preparados para serem usados como dados de treinamento ou as informações nas quais o modelo de Aprendizado de Máquina será treinado. Quanto mais dados, melhor o programa.


A partir daí, os [Cientistas de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) escolhem um modelo de Aprendizado de Máquina para usar, fornecem os dados e permitem que o modelo seja treinado para encontrar padrões e fazer previsões. Com o tempo, o programador humano também pode ajustar o modelo, incluindo alterar seus parâmetros, para ajudá-lo a obter resultados mais precisos. O site [AI Weirdness](https://www.aiweirdness.com/), da cientista de pesquisa Janelle Shane, é uma visão divertida de como os algoritmos de Aprendizado de Máquina aprendem e como eles podem errar.


Alguns dados são extraídos a partir dos dados de treinamento para serem usados como dados de avaliação, que testam a precisão do modelo de Aprendizado de Máquina quando são mostrados novos dados. O resultado é um modelo que pode ser usado no futuro com diferentes conjuntos de dados.


Algoritmos de Aprendizado de Máquina bem-sucedidos podem fazer coisas diferentes, escreveu Malone em uma [pesquisa recente sobre IA](https://workofthefuture.mit.edu/wp-content/uploads/2020/12/2020-Research-Brief-Malone-Rus-Laubacher2.pdf) e o futuro do trabalho, em coautoria da professora do MIT e diretora do CSAIL, Daniela Rus, e Robert Laubacher, diretor associado do MIT Center for Collective Intelligence.


“A função de um sistema de Aprendizado de Máquina pode ser **descritiva**, o que significa que o sistema usa os dados para explicar o que aconteceu; **preditiva**, significando que o sistema usa os dados para prever o que acontecerá; ou **prescritiva**, o que significa que o sistema usará os dados para fazer sugestões sobre quais ações tomar”, escreveram os pesquisadores.


Tipos de Aprendizado de Máquina
-------------------------------


Os modelos de Aprendizado de Máquina supervisionados são treinados com conjuntos de dados rotulados, que permitem que os modelos aprendam e se tornem mais precisos ao longo do tempo. Por exemplo, um algoritmo seria treinado com fotos de cães e outras coisas, todas rotuladas por humanos, e a máquina aprenderia maneiras de identificar fotos de cães por conta própria. O Aprendizado de Máquina supervisionado é o tipo mais comum usado hoje.


No Aprendizado de Máquina não supervisionado, um programa procura padrões em dados não rotulados. O Aprendizado de Máquina não supervisionado pode encontrar padrões ou tendências que as pessoas não estão procurando explicitamente. Por exemplo, um modelo de Aprendizado de Máquina não supervisionado pode analisar dados de vendas on-line e identificar diferentes tipos de clientes que fazem compras.


O Aprendizado de Máquina de reforço treina as máquinas por meio de tentativa e erro para tomar a melhor ação, estabelecendo um sistema de recompensa. O aprendizado por reforço pode treinar modelos para jogar ou treinar veículos autônomos para dirigir, informando à máquina quando ela tomou as decisões corretas, o que a ajuda a aprender ao longo do tempo quais ações devem ser tomadas.


O Aprendizado de Máquina é mais adequado para situações com muitos dados – milhares ou milhões de exemplos, como gravações de conversas anteriores com clientes, logs de sensores de máquinas ou transações comerciais. Por exemplo, o Google Tradutor foi possível porque “treinou” na grande quantidade de informações na web, em diferentes idiomas.


Em alguns casos, o Aprendizado de Máquina pode obter insights ou automatizar a tomada de decisões em casos em que os humanos não conseguiriam. Pode não apenas ser mais eficiente e menos dispendioso ter um algoritmo para fazer isso, mas às vezes os humanos literalmente não são capazes de fazê-lo.


Com o conceito de Machine Learning claramente definido, vejamos como Machine Learning está sendo usado pelas empresas. Acompanhe o próximo capítulo.


Referências:


[Machine Learning com R e Python](https://www.datascienceacademy.com.br/course/machine-learning-engineer)


[Machine Learning com Python e C++](https://www.datascienceacademy.com.br/course/machine-learning-em-python-e-c)


[Machine Learning, Explained](https://mitsloan.mit.edu/ideas-made-to-matter/machine-learning-explained)


<div id="capitulo-92---machine-learning---guia-definitivo---parte-2"></div>

# Capítulo 92 – Machine Learning – Guia Definitivo – Parte 2


Nos 10 capítulos finais deste livro online vamos trazer um grande resumo sobre Machine Learning. O objetivo é fornecer uma visão clara do que é e como Machine Learning está sendo usado no dia a dia, um pouco de matemática, as principais regras e princípios. Queremos ainda que esses capítulos finais possam servir de material de referência para os alunos que estão buscando as certificações oferecidas pela DSA no [Bootcamp de Certificação](https://www.datascienceacademy.com.br/course/bootcamp-cientista-de-dados).


Serão 10 partes no total com um guia completo sobre Machine Learning. Aproveite a leitura para compreender de forma definitiva o que é uma das tecnologias mais incríveis do nosso tempo.


Agora na Parte 2, vejamos como Machine Learning está presente em diversos subcampos da [Inteligência Artificial](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia):


**Processamento de Linguagem Natural**


No Processamento de Linguagem Natural as máquinas aprendem a entender a linguagem natural, falada e escrita por humanos, em vez dos dados e números normalmente usados ​​para programar computadores. Isso permite que as máquinas reconheçam o idioma, o entendam e respondam a ele, bem como criem novos textos e traduzam idiomas. O Processamento de Linguagem Natural é a tecnologia por trás de chatbots e assistentes digitais como Siri ou Alexa.


**Redes Neurais**


As redes neurais são uma classe específica e comumente usada de algoritmos de aprendizado de máquina. As redes neurais artificiais são modeladas a partir do funcionamento do cérebro humano, no qual milhares ou milhões de nós de processamento são interconectados e organizados em camadas.


Em uma rede neural artificial, células ou nós são conectados, com cada célula processando entradas e produzindo uma saída que é enviada a outros neurônios. Os dados rotulados se movem pelos nós (estruturas matemáticas), ou células, com cada célula desempenhando uma função diferente. Em uma rede neural treinada para identificar se uma imagem contém um gato ou não, os diferentes nós avaliariam as informações e chegariam a uma saída que indica se uma imagem apresenta um gato. Os modelos de redes neurais atuais fazem isso muito bem.


**Deep Learning**


As redes de aprendizado profundo são redes neurais com muitas camadas. A rede com muitas camadas pode processar grandes quantidades de dados e determinar o “peso” de cada link na rede – por exemplo, em um sistema de reconhecimento de imagem, algumas camadas da rede neural podem detectar características individuais de um rosto, como olhos, nariz, ou boca, enquanto outra camada seria capaz de dizer se esses recursos aparecem de uma forma que indica um rosto. Estudamos Deep Learning ao longo deste livro online.


Assim como as redes neurais, o aprendizado profundo é modelado na maneira como o cérebro humano funciona e potencializa muitos usos do aprendizado de máquina, como veículos autônomos, chatbots e diagnósticos médicos.


O aprendizado profundo requer muito poder computacional, o que levanta preocupações sobre sua sustentabilidade econômica e ambiental.


### Como as Empresas Estão Usando o Aprendizado de Máquina?


O aprendizado de máquina é o núcleo dos modelos de negócios de algumas empresas, como no caso do algoritmo de sugestões da Netflix ou do mecanismo de busca do Google. Outras empresas estão se engajando profundamente com o aprendizado de máquina, embora não seja sua principal proposta de negócios.


Outros ainda estão tentando determinar como usar o aprendizado de máquina de maneira eficiente. Um dos problemas mais difíceis no aprendizado de máquina é descobrir quais problemas podemos resolver com o aprendizado de máquina. Ainda há uma lacuna no entendimento.


Em um [artigo de 2018](https://ide.mit.edu/wp-content/uploads/2018/12/2018-08-MITIDE-researchbrief-Erikb.final_.pdf), pesquisadores da Iniciativa do MIT sobre a Economia Digital delinearam uma pesquisa de 21 perguntas para determinar se uma tarefa é adequada para aprendizado de máquina. Os pesquisadores descobriram que nenhuma ocupação será intocada pelo aprendizado de máquina, mas é provável que nenhuma ocupação seja completamente dominada por ele. A maneira de desencadear o sucesso do aprendizado de máquina, descobriram os pesquisadores, era reorganizar os trabalhos em tarefas discretas, algumas que podem ser feitas por aprendizado de máquina e outras que exigem um humano.


As empresas já estão usando o aprendizado de máquina de várias maneiras, incluindo:


**Algoritmos de recomendação**. Os mecanismos de recomendação por trás das sugestões da Netflix e do YouTube, quais informações aparecem no seu feed do Facebook e recomendações de produtos, são alimentados pelo aprendizado de máquina. Os algoritmos estão tentando aprender nossas preferências. Eles querem aprender, como no Twitter, quais tweets queremos que eles nos mostrem, no Facebook, quais anúncios exibir e quais postagens ou conteúdos compartilhar conosco.


**Análise de imagens e detecção de objetos**. O aprendizado de máquina pode analisar imagens para obter informações diferentes, como aprender a identificar pessoas e diferenciá-las – embora os algoritmos de reconhecimento facial sejam controversos. Os usos comerciais para isso variam. Os fundos de hedge usam o aprendizado de máquina para analisar o número de carros em estacionamentos, o que os ajuda a saber como as empresas estão se saindo e fazer boas apostas.


**Detecção de fraude**. As máquinas podem analisar padrões, como por exemplo quanto alguém normalmente gasta ou onde costuma fazer compras, para identificar transações de cartão de crédito potencialmente fraudulentas, tentativas de login ou e-mails de spam.


**Chatbots**. Muitas empresas estão implantando chatbots, nos quais clientes interagem com uma máquina. Esses algoritmos usam aprendizado de máquina e Processamento de Linguagem Natural, com os bots aprendendo com registros de conversas anteriores para obter respostas apropriadas.


**Carros autônomos**. Grande parte da tecnologia por trás dos carros autônomos é baseada no aprendizado de máquina, em particular no aprendizado profundo (Deep Learning).


**Imagiologia e diagnóstico médico**. Programas de aprendizado de máquina podem ser treinados para examinar imagens médicas ou outras informações e procurar certos marcadores de doenças, como uma ferramenta que pode prever o risco de câncer com base em uma mamografia.


### Como Machine Learning Funciona: Promessas e Desafios


Embora o aprendizado de máquina esteja alimentando a tecnologia que pode ajudar os trabalhadores ou abrir novas possibilidades para as empresas, há várias coisas que os líderes empresariais devem saber sobre o aprendizado de máquina e seus limites.


**Explicabilidade**


Uma área de preocupação é o que alguns especialistas chamam de explicabilidade, ou a capacidade de ser claro sobre o que os modelos de aprendizado de máquina estão fazendo e como eles tomam decisões. Entender por que um modelo faz o que faz é realmente uma questão muito difícil, e você sempre tem que se perguntar isso. Você nunca deve tratar isso como uma caixa preta, que vem apenas como um oráculo … sim, você deve usá-lo, mas então tente ter uma ideia de quais são as regras básicas que ele criou. E depois valide-as.


Isso é especialmente importante porque os sistemas podem ser enganados e prejudicados, ou simplesmente falhar em certas tarefas, mesmo aquelas que humanos podem executar facilmente. Por exemplo, ajustar os metadados nas imagens pode confundir os computadores – com alguns ajustes, uma máquina identifica uma foto de um cachorro como avestruz.


Houve um famoso caso em que um algoritmo de aprendizado de máquina examinando raios-X parecia superar os médicos. Mas descobriu-se que o algoritmo estava correlacionando os resultados com as máquinas que tiraram a imagem, não necessariamente a imagem em si. A tuberculose é mais comum em países em desenvolvimento, que tendem a ter máquinas mais antigas. O programa de aprendizado de máquina descobriu que, se o raio-X fosse feito em uma máquina mais antiga, o paciente era mais propenso a ter tuberculose. Ele completou a tarefa, mas não da maneira que os [Cientistas de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) pretendiam ou achariam útil.


A importância de explicar como um modelo está funcionando – e sua precisão – pode variar dependendo de como está sendo usado. Embora a maioria dos problemas possa ser resolvidos por meio de aprendizado de máquina, as pessoas devem assumir agora que os modelos funcionam apenas com cerca de 95% da precisão humana. Pode ser bom para o [Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) e o usuário se um algoritmo recomendando filmes for 95% preciso, mas esse nível de precisão não seria suficiente para um veículo autônomo ou um programa projetado para encontrar falhas graves em máquinas.


**Viés e Resultados Não Intencionais**


Máquinas são treinadas por humanos e preconceitos humanos podem ser incorporados em algoritmos – se informações tendenciosas ou dados que refletem desigualdades existentes forem alimentados a um programa de aprendizado de máquina, o programa aprenderá a replicá-lo e perpetuar formas de discriminação. Chatbots treinados sobre como as pessoas conversam no Twitter podem captar linguagem ofensiva e racista, por exemplo.


Em alguns casos, os modelos de aprendizado de máquina criam ou exacerbam problemas sociais. Por exemplo, o Facebook usa o aprendizado de máquina como uma ferramenta para mostrar aos usuários anúncios e conteúdo que os interessarão e os envolverão – o que pode levar a modelos que mostram às pessoas conteúdo extremo que causa polarização e disseminação de teorias da conspiração.


Maneiras de combater o preconceito no aprendizado de máquina, incluindo a verificação cuidadosa de dados de treinamento e apoio organizacional por trás de esforços éticos de Inteligência Artificial, como garantir que uma organização adote IA centrada no ser humano, a prática de buscar informações de pessoas de diferentes origens, experiências e estilos de vida quando projetar sistemas de IA. As iniciativas que trabalham nesta questão incluem o projeto [Algorithmic Justice League](https://www.ajl.org/) e [The Moral Machine](https://www.moralmachine.net/).


### Colocando o Aprendizado de Máquina Para Funcionar


Os executivos tendem a lutar para entender onde o aprendizado de máquina pode realmente agregar valor à empresa. O que é enigmático para uma empresa é essencial para outra e as empresas devem evitar tendências e encontrar casos de uso de negócios que funcionem para elas.


A maneira como o aprendizado de máquina funciona para a Amazon provavelmente não será traduzido em uma empresa de automóveis – embora a Amazon tenha encontrado sucesso com assistentes de voz, isso não significa que as empresas de automóveis devam priorizar a adição de assistentes aos carros. O mais provável é que a montadora encontre uma maneira de usar o aprendizado de máquina na linha da fábrica que economize ou ganhe muito dinheiro.


O campo de estudo em Machine Learning está se movendo rapidamente, e isso é incrível, mas torna difícil para os executivos tomar decisões e decidir quanto recursos devem ser investidos na tecnologia.


Também é melhor evitar olhar para o aprendizado de máquina como uma solução em busca de um problema. Algumas empresas podem acabar tentando fazer engenharia reversa do aprendizado de máquina em um uso comercial. Em vez de começar com foco em tecnologia, as empresas devem começar com foco em um problema de negócios ou necessidade do cliente que possa ser atendido com aprendizado de máquina.


Uma compreensão básica do aprendizado de máquina é importante mas, encontrar o uso certo de aprendizado de máquina depende, em última análise, de pessoas com diferentes conhecimentos trabalhando juntos. 


Continuamos no próximo capítulo!


Referências:


[Machine Learning com R e Python](https://www.datascienceacademy.com.br/course/machine-learning-engineer)


[Machine Learning com Python e C++](https://www.datascienceacademy.com.br/course/machine-learning-em-python-e-c)


[Machine Learning, Explained](https://mitsloan.mit.edu/ideas-made-to-matter/machine-learning-explained)


<div id="capitulo-93---machine-learning---guia-definitivo---parte-3"></div>

# Capítulo 93 – Machine Learning – Guia Definitivo – Parte 3


Nos 10 capítulos finais deste livro online vamos trazer um grande resumo sobre Machine Learning. O objetivo é fornecer uma visão clara do que é e como Machine Learning está sendo usado no dia a dia, um pouco de matemática, as principais regras e princípios. Queremos ainda que esses capítulos finais possam servir de material de referência para os alunos que estão buscando as certificações oferecidas pela DSA no [Bootcamp de Certificação](https://www.datascienceacademy.com.br/course/bootcamp-cientista-de-dados).


Serão 10 partes no total com um guia completo sobre Machine Learning. Aproveite a leitura para compreender de forma definitiva o que é uma das tecnologias mais incríveis do nosso tempo.


Agora, na Parte 3, um glossário com os 50 principais termos em Machine Learning.


### Glossário


Os termos a seguir aparecerão repetidamente em projetos de Machine Learning (listamos em ordem de importância e similaridade e não em ordem alfabética):


**1- Instância**: linha, registro ou observação em seu conjunto de dados, sobre a qual você deseja fazer uma previsão. Por exemplo, cada instância pode ser um registro contendo informações sobre pacientes como idade, peso e altura e informação se o paciente desenvolveu diabetes. Queremos prever a ocorrência de diabetes com base nas características do paciente.


**2- Rótulo (Label)**: uma resposta para uma tarefa de previsão, seja a resposta produzida por um sistema de aprendizado de máquina ou a resposta correta fornecida nos dados de treinamento. Por exemplo, o rótulo da instância definido no item anterior seria “diabetes”, indicando se o paciente desenvolveu ou não a doença.


**3- Classe**: uma categoria de um conjunto de valores de destino enumerados para um rótulo. Por exemplo, em um modelo de classificação binária que detecta spam, as duas classes são spam e não spam. Em um modelo de classificação multiclasse que identifica raças de cães, as classes seriam poodle, beagle, pug e assim por diante.


**4- Recurso (Feature)**: uma propriedade de uma instância usada em uma tarefa de previsão. Por exemplo, uma instância com dados de pacientes teria um recurso indicando a idade.


**5- Recurso Denso**: um recurso em que a maioria dos valores é diferente de zero, normalmente um tensor de valores de ponto flutuante.


**6- Recurso Esparso**: vetor de recursos cujos valores são predominantemente zero ou vazios. Por exemplo, um vetor contendo um único valor 1 e um milhão de valores 0 é esparso. Como outro exemplo, as palavras em uma consulta de pesquisa também podem ser um recurso esparso – há muitas palavras possíveis em um determinado idioma, mas apenas algumas delas ocorrem em uma determinada consulta.


**7- Dados Categóricos**: recursos com um conjunto discreto de valores possíveis representando informação qualitativa. Por exemplo, considere um recurso categórico chamado estilo da casa, que possui um conjunto discreto de três valores possíveis: apartamento, casa e chalé.


**8- Dados Numéricos**: características representadas como números inteiros ou números reais. Por exemplo, em um modelo imobiliário, você provavelmente representaria o tamanho de uma casa (em metros quadrados) como dados numéricos. Representar um recurso como dados numéricos indica que os valores do recurso têm uma relação matemática entre si e possivelmente com o rótulo. 


**9- Exemplo**: uma instância (com seus recursos) e um rótulo.


**10- Modelo**: uma representação estatística de uma tarefa de previsão. Você treina um modelo em exemplos e depois usa o modelo para fazer previsões.


**11- Baseline**: um modelo usado como ponto de referência para comparar o desempenho de outro modelo (normalmente mais complexo). Por exemplo, um modelo de regressão logística pode servir como uma boa linha de base para um modelo de Deep Learning. Para um problema específico, a linha de base ajuda os [Cientistas de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados) a quantificar o desempenho mínimo esperado que um novo modelo deve alcançar para que o novo modelo seja útil.


**12- Aprendizado de Máquina Supervisionado**: técnica para treinar um modelo a partir de dados de entrada e seus rótulos correspondentes. O aprendizado de máquina supervisionado é análogo a um aluno aprendendo um assunto estudando um conjunto de perguntas e suas respostas correspondentes. Depois de dominar o mapeamento entre perguntas e respostas, o aluno pode fornecer respostas para novas perguntas (nunca antes vistas) sobre o mesmo tema.


**13- Aprendizado de Máquina Não Supervisionado**: técnica para treinar um modelo para encontrar padrões em um conjunto de dados, normalmente um conjunto de dados não rotulado. O uso mais comum do aprendizado de máquina não supervisionado é agrupar dados em grupos de exemplos semelhantes. Por exemplo, um algoritmo de aprendizado de máquina não supervisionado pode agrupar músicas com base em várias propriedades da música. Os clusters resultantes podem se tornar uma entrada para outros algoritmos de aprendizado de máquina (por exemplo, para um serviço de recomendação de música). O clustering pode ser útil em domínios onde os rótulos verdadeiros são difíceis de obter. Por exemplo, em domínios como antiabuso e fraude, os clusters podem ajudar os humanos a entender melhor os dados. Outro exemplo de aprendizado de máquina não supervisionado é a análise de componentes principais (PCA). Por exemplo, a aplicação de PCA em um conjunto de dados contendo o conteúdo de milhões de carrinhos de compras pode revelar que carrinhos de compras contendo limões frequentemente também contêm antiácidos.


**14- Métrica**: medida da performance do seu modelo. Cada tipo de modelo pode ter uma ou mais métricas, que usamos para comparar a performance entre versões do modelo.


**15- Função Objetivo**: a fórmula matemática ou métrica que um modelo visa otimizar. Por exemplo, a função objetivo para regressão linear geralmente é o erro ao quadrado. Portanto, ao treinar um modelo de regressão linear, o objetivo é minimizar o erro quadrática. Em alguns casos, o objetivo é maximizar a função objetivo. Por exemplo, se a função objetivo é precisão, o objetivo é maximizar a precisão.


**16- AUC (Área sob a Curva ROC)**: uma métrica de avaliação que considera todos os limites de classificação possíveis. A área sob a curva ROC é a probabilidade de um classificador estar mais confiante de que um exemplo positivo escolhido aleatoriamente é realmente positivo, do que um exemplo negativo escolhido aleatoriamente é positivo.


**17- Acurácia**: a fração de previsões que um modelo de classificação acertou. Em um modelo com acurácia de 82% dizemos que o modelo acerta 82 previsões a cada 100 previsões realizadas.


**18- Precisão Média**: uma métrica para resumir o desempenho de uma sequência classificada de resultados. A precisão média é calculada tomando a média dos valores de precisão para cada resultado relevante.


**19- DataFrame**: popular estrutura de dados para representar conjuntos de dados. Um DataFrame é análogo a uma tabela. Cada coluna do DataFrame tem um nome (um cabeçalho) e cada linha é identificada por um número.


**20- Função de Ativação**: uma função (por exemplo, ReLU ou sigmoid) que recebe a soma ponderada de todas as entradas da camada anterior em um modelo de rede neural e, em seguida, gera e passa um valor de saída (normalmente não linear) para a próxima camada.


**21- Backpropagation**: o algoritmo primário para executar gradiente descendente em redes neurais. Primeiro, os valores de saída de cada nó são calculados (e armazenados em cache) em uma passagem direta. Então, a derivada parcial do erro em relação a cada parâmetro é calculada em uma passagem para trás pelo grafo computacional, conforme estudado em detalhes neste livro online.


**22- Batch**: o conjunto de exemplos usados em uma iteração (ou seja, uma atualização de gradiente) do treinamento do modelo.


**23- Batch Normalization**: normalização da entrada ou saída das funções de ativação em uma camada oculta. A normalização em lote pode fornecer os seguintes benefícios: torna as redes neurais mais estáveis protegendo contra pesos discrepantes, habilita taxas de aprendizado mais altas e reduz o sobreajuste (overfitting).


**24- Stochastic Gradient Descent (SGD)**: um algoritmo de descida de gradiente em que o tamanho do lote é um. Em outras palavras, o SGD conta com um único exemplo escolhido uniformemente de forma aleatória de um conjunto de dados para calcular uma estimativa do gradiente em cada etapa.


**25- Overfitting**: o overfiting (sobre ajuste) ocorre quando o modelo aprende os detalhes nos dados de treino. Não é isso que queremos em Machine Learning. Em aprendizado de máquina buscamos a criação de um modelo que aprende a generalização dos dados, para então fazer previsões com novos dados.


**26- Bagging**: um método para treinar um ensemble onde cada modelo constituinte é treinado em um subconjunto aleatório de exemplos de treinamento amostrados com substituição. Por exemplo, uma floresta aleatória (Random Forest) é uma coleção de árvores de decisão treinadas com bagging. O termo bagging é a abreviação de bootstrap aggregating.


**27- Boosting**: uma técnica de aprendizado de máquina que combina iterativamente um conjunto de classificadores simples e não muito precisos (referidos como classificadores “fracos”) em um classificador com alta precisão (um classificador “forte”), valorizando os exemplos que o modelo está classificando incorretamente no momento .


**28- Bag of Words**: uma representação das palavras em uma frase ou passagem, independentemente da ordem. Cada palavra é mapeada para um índice em um vetor esparso, onde o vetor tem um índice para cada palavra do vocabulário. Por exemplo, a frase “o cachorro pula” é mapeada em um vetor de características com valores diferentes de zero nos três índices correspondentes às palavras “o”, “cachorro” e “pula”.


**29- Word Embedding**: estrutura que representa cada palavra em um conjunto de palavras; ou seja, representando cada palavra como um vetor de valores de ponto flutuante entre 0,0 e 1,0. Palavras com significados semelhantes têm representações mais semelhantes do que palavras com significados diferentes. Por exemplo, cenoura, aipo e pepino teriam representações relativamente semelhantes, que seriam muito diferentes das representações de avião, óculos de sol e pasta de dente.


**30- Inteligência Artificial**: um programa ou modelo não humano que pode resolver tarefas sofisticadas. Por exemplo, um programa ou modelo que traduz texto ou um programa ou modelo que identifica doenças a partir de imagens radiológicas exibem Inteligência Artificial. Formalmente, o aprendizado de máquina é um subcampo da Inteligência Artificial. No entanto, nos últimos anos, algumas organizações começaram a usar os termos Inteligência Artificial e aprendizado de máquina de forma intercambiável.


**31- Inteligência Artificial Geral**: um mecanismo não humano que demonstra uma ampla gama de resolução de problemas, criatividade e adaptabilidade. Por exemplo, um programa que demonstra Inteligência Artificial Geral pode traduzir texto, compor sinfonias e se destacar em jogos que ainda não foram inventados.


**32- Atenção**: qualquer um de uma ampla gama de mecanismos de arquitetura de rede neural que agregam informações de um conjunto de entradas de maneira dependente de dados. Um mecanismo de atenção típico pode consistir em uma soma ponderada sobre um conjunto de entradas, onde o peso de cada entrada é calculado por outra parte da rede neural. São os blocos principais dos Transformers, estudados aqui mesmo neste livro online.


**33- Recall**: o recall é a medida do nosso modelo identificando corretamente os Verdadeiros Positivos. Assim, para todos os pacientes que realmente têm doença cardíaca, o recall nos diz quantos identificamos corretamente como tendo uma doença cardíaca.


**34- Precisão**: é a razão entre os Verdadeiros Positivos e todos os Positivos. Para nossa declaração de problema, essa seria a medida de pacientes que identificamos corretamente como tendo uma doença cardíaca entre todos os pacientes que realmente a têm.


**35- Bias (ética/justiça)**: estereótipo, preconceito ou favoritismo em relação a algumas coisas, pessoas ou grupos em detrimento de outros. Esses vieses podem afetar a coleta e interpretação de dados, o design de um sistema e como os usuários interagem com um sistema.


**36- Bias (matemática)**: uma interceptação ou deslocamento de uma origem. O bias (também conhecido como termo de viés) é referido como b ou w0 em modelos de aprendizado de máquina.


**37- Classificação Binária**: um tipo de tarefa de classificação que gera uma das duas classes mutuamente exclusivas. Por exemplo, um modelo de aprendizado de máquina que avalia mensagens de e-mail e gera “spam” ou “não spam” é um classificador binário.


**38- BLEU (Bilingual Evaluation Understudy)**: uma pontuação entre 0,0 e 1,0, inclusive, indicando a qualidade de uma tradução entre duas línguas humanas (por exemplo, entre inglês e russo). Uma pontuação BLEU de 1,0 indica uma tradução perfeita; uma pontuação BLEU de 0,0 indica uma tradução terrível. Medida usada em modelos de Processamento de Linguagem Natural.


**39- Normalização**: o processo de conversão de um intervalo real de valores em um intervalo padrão de valores, normalmente -1 a +1 ou 0 a 1. Por exemplo, suponha que o intervalo natural de um determinado recurso seja de 800 a 6.000. Por meio de subtração e divisão, você pode normalizar esses valores no intervalo -1 a +1.


**40- Normalização Z-score**: uma técnica de normalização que substitui um valor de recurso bruto por um valor de ponto flutuante que representa o número de desvios padrão da média desse recurso.


**41- Entropia Cruzada**: uma generalização de Log Loss para problemas de classificação multiclasse. A entropia cruzada quantifica a diferença entre duas distribuições de probabilidade.


**42- Matriz de Confusão**: uma tabela NxN que agrega as suposições corretas e incorretas de um modelo de classificação. Um eixo de uma matriz de confusão é o rótulo que o modelo previu e o outro eixo é a verdade básica. N representa o número de classes. Por exemplo, N=2 para um modelo de classificação binária.


**43- Validação**: um processo usado, como parte do treinamento, para avaliar a qualidade de um modelo de aprendizado de máquina usando o conjunto de validação. Como o conjunto de validação é separado do conjunto de treinamento, a validação ajuda a garantir que o desempenho do modelo se generalize além do conjunto de treinamento.


**44- Estacionaridade**: uma propriedade de dados em um conjunto de dados, na qual a distribuição de dados permanece constante em uma ou mais dimensões. Mais comumente, essa dimensão é o tempo, o que significa que os dados que exibem estacionariedade não mudam com o tempo. Por exemplo, os dados que exibem estacionariedade não mudam de setembro a dezembro. Termo muito usado em análise de séries temporais.


**45- Não Estacionaridade**: uma propriedade de dados cujos valores mudam em uma ou mais dimensões, geralmente o tempo. Por exemplo, o número de maiôs vendidos em uma determinada loja demonstra não estacionaridade porque esse número varia com a estação. Como segundo exemplo, a quantidade de uma determinada fruta colhida em uma determinada região normalmente mostra uma acentuada não estacionariedade ao longo do tempo. Termo muito usado em análise de séries temporais.


**46- Convergência**: informalmente, muitas vezes se refere a um estado alcançado durante o treinamento no qual a perda de treinamento e a perda de validação mudam muito pouco ou nada a cada iteração após um certo número de iterações. Em outras palavras, um modelo atinge a convergência quando o treinamento adicional nos dados atuais não melhora o modelo. No aprendizado profundo, os valores de perda às vezes permanecem constantes por muitas iterações antes de finalmente descer, produzindo temporariamente uma falsa sensação de convergência.


**47- Desbalanceamento de Classe:** um problema de classificação binária em que os rótulos para as duas classes têm frequências significativamente diferentes. Por exemplo, um conjunto de dados de doenças em que 0,0001 dos exemplos tem rótulos positivos e 0,9999 têm rótulos negativos é um problema de desequilíbrio de classe, mas um preditor de jogo de futebol no qual 0,51 dos exemplos rotula um time vencedor e 0,49 rotula o outro time vencedor não é um problema de classe desequilibrada.


**48- Limite (Threshold) de Classificação**: um critério de valor escalar que é comparado com a pontuação prevista de um modelo para separar a classe positiva da classe negativa. Usado ao mapear resultados de regressão logística para classificação binária. Por exemplo, considere um modelo de regressão logística que determina a probabilidade de uma determinada mensagem de email ser spam. Se o limite de classificação for 0,9, os valores de regressão logística acima de 0,9 são classificados como spam e os abaixo de 0,9 são classificados como não spam.


**49- Checkpoint**: captura o estado dos parâmetros de um modelo em um determinado momento. Os pontos de verificação permitem exportar pesos de modelo ou realizar treinamento em várias sessões. Os pontos de verificação também permitem que o treinamento continue com erros anteriores.


**50- [Data Science Academy](https://www.datascienceacademy.com.br/)**: maior portal da América Latina para o capacitação de alto nível em Data Science, IA, Blockchain, RPA e tecnologias relacionadas. 🙂


A partir do próximo capítulo veremos as regras para uso e aplicação de Machine Learning.


<div id="capitulo-94---machine-learning---guia-definitivo---parte-4"></div>

# Capítulo 94 – Machine Learning – Guia Definitivo – Parte 4


Nos 10 capítulos finais deste livro online vamos trazer um grande resumo sobre Machine Learning. O objetivo é fornecer uma visão clara do que é e como Machine Learning está sendo usado no dia a dia, um pouco de matemática, as principais regras e princípios. Queremos ainda que esses capítulos finais possam servir de material de referência para os alunos que estão buscando as certificações oferecidas pela DSA no [Bootcamp de Certificação](https://www.datascienceacademy.com.br/course/bootcamp-cientista-de-dados).


Serão 10 partes no total com um guia completo sobre Machine Learning. Aproveite a leitura para compreender de forma definitiva o que é uma das tecnologias mais incríveis do nosso tempo.


E a partir deste capítulo até o final do livro (que terá 100 capítulos), vamos explicar para você dezenas de regras e princípios da aplicação de Machine Learning para resolver problemas de negócio! 


Boa leitura!


### Machine Learning Não é a Solução Para Todos os Problemas


O aprendizado de máquina é incrível, mas requer dados. Sem dados, não há como usar Machine Learning. Isso está bem claro para você? Vamos repetir: sem dados não há como usar Machine Learning.


Logo, antes de pensar em Machine Learning uma empresa deve pensar em dados. Como obter os dados necessários? Como armazenar os dados com segurança? Como seguir as normas regulatórias e de privacidade? Todas essas perguntas devem ser respondidas antes de considerar Machine Learning para resolver os problemas da empresa.


E a criação de um modelo de Machine Learning não significa que já podemos parar de pensar em dados. Teremos que usar dados para alimentar o modelo treinado e extrair as previsões e teremos que re-treinar o modelo periodicamente com novos dados.


Sem uma política clara de gestão de dados (e de metadados) qualquer iniciativa de Machine Learning já começa errada. Não é justo depois colocar a culpa na tecnologia se ela não funcionar. Sem matéria-prima (dados), Machine Learning é apenas um belo diagrama teórico.


Machine Learning é Matemática e Estatística via programação de computadores. Quando os algoritmos são treinados com dados, aprendem os padrões e a generalização presente nos dados (se houver) e um modelo é criado. Ao receber novos dados, esse modelo é capaz de fazer previsões. Mas você deve concordar que os padrões podem mudar ao longo do tempo. O que isso significa? Que o modelo deve ser re-treinado periodicamente para manter a sua performance. Ainda assim, espera-se que o modelo tenha uma taxa de erros, algo absolutamente normal. O que você prefere? Nenhum modelo para prever as vendas ou um modelo capaz de fazer previsões com 90% de precisão? A segunda opção, evidentemente.


Além de tudo isso, cada modelo de Machine Learning é específico para resolver um problema. Sua empresa precisa de um modelo para prever o volume de vendas no próximo mês? Criamos um modelo para esse fim. Sua empresa precisa de um modelo para classificar novos e-mails como spam ou não spam? Criamos outro modelo para esse fim. Sua empresa precisa de um modelo capaz de detectar o sentimento do cliente em um post em determinada rede social? Ótimo, então criamos um outro modelo para esse fim. Entendeu a ideia? Cada modelo é específico ao problema que estamos tentando resolver e cada problema terá seu próprio conjunto de dados.


Logo, Machine Learning parece mágica somente até você compreender a Matemática por trás dos modelos. Por se tratar de uma tecnologia baseada em Ciências Exatas, Machine Learning é regido por diversas regras e princípios, muitas das quais listaremos para você a partir de agora.


Mas antes de decidir usar Machine Learning, a empresa deve considerar se Machine Learning é a solução ideal ou não. Por isso conhecer as regras e princípios do aprendizado de máquina pode ser o ponto de partida.


### Regras e Princípios


Vamos listar agora dezenas de regras e princípios para a utilização de Machine Learning no dia a dia. Começaremos neste capítulo e seguiremos até o final deste livro, no Capítulo 100. O primeiro grupo de regras e princípios é sobre o início do projeto de Machine Learning.


**Regra 1: Tudo começa com a definição do problema de negócio**


Machine Learning compreende um conjunto de algoritmos que, ao serem treinados com dados, geram um modelo capaz de fazer previsões quando recebe novos dados. Logo, cada modelo de Machine Learning será criado para resolver um problema diferente, cada qual com diferentes conjuntos de dados. Se não definirmos o problema, como saberemos quais dados buscar e qual algoritmo usar? Definimos o problema e só depois teremos condições de pensar em Machine Learning.


Um projeto de Machine Learning não começa com Machine Learning. Começa com a definição do problema, identificação dos dados e só então podemos falar em aprendizado de máquina.


**Regra 2: Escolha o aprendizado de máquina em vez de uma heurística complexa**


Uma simples heurística pode levar um produto (software) ao mercado. Uma heurística complexa é insustentável. Depois de ter uma ideia básica do problema de negócio que está tentando resolver e dados que suportam a ideia, passe para o aprendizado de máquina. Como na maioria das tarefas de engenharia de software, você desejará estar constantemente atualizando sua abordagem, seja uma heurística ou um modelo de Machine Learning e descobrirá que o modelo de aprendizado de máquina é mais fácil de atualizar e manter, na maioria dos casos.


**Regra 3: Projete e implemente métricas desde o início**


“O que não pode ser medido não pode ser gerenciado”.


A célebre frase de William Edwards Deming (notável estatístico, consultor, conferencista e professor norte-americano) expõe uma verdade aplicável à qualquer situação, inclusive à construção dos modelos de Machine Learning. Como saber se a performance do modelo está adequada? Como saber se a performance está se deteriorando ao longo do tempo? Precisamos medir a performance do modelo periodicamente e, logo, precisamos de uma ou mais métricas.


Há métricas comuns como acurácia ou coeficiente de determinação, mas cada empresa pode criar suas próprias métricas e isso é muito comum em Startups de tecnologia. Definimos as métricas que permitirão monitorar e acompanhar a evolução do modelo ao longo do tempo. Isso vai ajudar a saber, por exemplo, o momento ideal de re-treinar o modelo ou mesmo mudar completamente sua concepção.


**Regra 4: Mantenha o primeiro modelo simples e obtenha a infraestrutura certa**


O primeiro modelo fornece o maior impulso à sua solução, por isso não precisa ser sofisticado. Mas você terá muito mais problemas de infraestrutura do que o esperado. Antes que alguém possa usar seu novo e sofisticado sistema de aprendizado de máquina, você precisa determinar:


* Como obter dados para o seu algoritmo de aprendizagem.
* Uma ou mais métricas para definir se o modelo é “bom” ou “ruim”.
* Como integrar seu modelo de Machine Learning aos aplicativos da empresa. Você pode aplicar o modelo ao vivo ou pré-computar o modelo em exemplos offline e armazenar os resultados em uma tabela. Por exemplo, você pode querer pré-classificar páginas da web e armazenar os resultados em uma tabela, mas pode querer classificar mensagens de redes sociais ao vivo.


Modelos de Machine Learning serão melhorados ao longo do tempo à medida que a empresa e a equipe de Ciência de Dados aprendem as nuances de uso do modelo no dia a dia, comete erros, faz ajustes, reavalia e o ciclo se repete. Não é necessário ter um modelo perfeito para começar e a primeira versão do modelo traz aprendizado para a empresa construir modelos cada vez melhores.


**Regra 5: Teste a infraestrutura independentemente do aprendizado de máquina**


Não adianta ter o modelo de Machine Learning mais incrível, sofisticado e preciso do sistema solar, se não for possível executá-lo em tempo hábil.


Certifique-se de que a infraestrutura seja “testável” e que as partes de aprendizado do sistema sejam encapsuladas para que você possa testar tudo ao seu redor. Especificamente:


* Teste a obtenção de dados no algoritmo. Verifique se as colunas de recursos que devem ser preenchidas estão preenchidas. Onde a privacidade permitir, inspecione manualmente as entradas de treinamento do seu algoritmo. Se possível, verifique as estatísticas em seu pipeline em comparação com as estatísticas dos mesmos dados processados ​​em outro lugar.
* Teste a precisão dos modelos. Certifique-se de que o modelo em seu ambiente de treinamento forneça a mesma pontuação que o modelo em seu ambiente de produção.
* O aprendizado de máquina tem um elemento de imprevisibilidade, portanto, verifique se você tem testes para o código para criar exemplos no treinamento e na produção e se pode carregar e usar um modelo fixo durante a produção.


**Regra 6: Tenha cuidado com dados descartados ao executar pipelines**


Um pipeline é uma sequência de tarefas para extrair, processar e carregar dados. Dados são extraídos de uma ou mais fontes, processados e transformados de acordo com as necessidades de limpeza e regras de negócio e então carregados em um repositório de destino. A arquitetura e concepção do pipeline é responsabilidade de um [Arquiteto de Dados](https://www.datascienceacademy.com.br/bundle/formacao-arquiteto-de-dados) e a criação, execução e manutenção é responsabilidade de um [Engenheiro de Dados](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-dados).


O problema, é que esses profissionais podem não ter uma visão completa de como os dados serão usados mais tarde para treinar os modelos de Machine Learning e dados úteis podem ser descartados no meio do caminho. O que é bom para o pipeline pode gerar falta de dados mais tarde no processo.


Certifique-se que todos os membros da equipe de Ciência de Dados estejam alinhados para que o processo de construção de modelos de aprendizado de máquina seja uma grande linha de produção e nada seja perdido no meio do caminho.


**Regra 7: Transforme heurísticas em recursos ou trate-os externamente**


Heurísticas são estratégias práticas que diminuem o tempo de tomada de decisão e permitem que as pessoas funcionem sem parar constantemente para pensar em seu próximo curso de ação. As heurísticas são úteis em muitas situações, mas também podem levar a vieses inconscientes.


Normalmente, os problemas que o aprendizado de máquina está tentando resolver não são completamente novos. Existe um sistema existente para classificação ou qualquer problema que você esteja tentando resolver. 


Isso significa que há um monte de regras e heurísticas. Essas mesmas heurísticas podem ajudá-lo quando ajustadas com aprendizado de máquina. Suas heurísticas devem ser exploradas para qualquer informação que tenham, por dois motivos: Primeiro, a transição para um sistema de aprendizado de máquina será mais suave. Em segundo lugar, geralmente essas regras contêm muita intuição sobre o sistema que você não quer jogar fora. Existem quatro maneiras de usar uma heurística existente:


**Pré-processar usando a heurística**. Se o recurso é incrivelmente importante, então esta é uma opção. Por exemplo, se, em um filtro de spam, o remetente já estiver na lista restritiva, não tente reaprender o que significa “lista restritiva”. Bloqueie a mensagem. Essa abordagem faz mais sentido em tarefas de classificação binária.


**Crie um recurso**. Criar um recurso diretamente da heurística é ótimo. Por exemplo, se você usar uma heurística para calcular uma pontuação de relevância para um resultado de consulta, poderá incluir a pontuação como o valor de um recurso. Mais tarde, você pode querer usar técnicas de aprendizado de máquina para massagear o valor (por exemplo, converter o valor em um de um conjunto finito de valores discretos ou combiná-lo com outros recursos), mas comece usando o valor bruto produzido pela heurística.


**Extraia as entradas brutas da heurística**. Se houver uma heurística para aplicativos que combine o número de instalações, o número de caracteres no texto e o dia da semana, considere separar essas partes e alimentar essas entradas no aprendizado separadamente. 


**Modifique o rótulo**. Esta é uma opção quando você sente que a heurística captura informações não contidas no rótulo. Por exemplo, se você está tentando maximizar o número de downloads de uma app, mas também deseja conteúdo de qualidade, talvez a solução seja multiplicar o rótulo pelo número médio de estrelas que o aplicativo recebeu. Há muita margem de manobra aqui. 


Esteja atento à complexidade adicional ao usar heurística em um sistema de Machine Learning. Usar heurísticas antigas em seu novo algoritmo de aprendizado de máquina pode ajudar a criar uma transição suave, mas pense se existe uma maneira mais simples de obter o mesmo efeito.


Continuaremos no próximo capítulo.


Referências:


[Formação Linguagem Python Para Data Science](https://www.datascienceacademy.com.br/bundle/formacao-linguagem-python-para-data-science)


[Formação Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-machine-learning)


[Rules of Machine Learning](https://developers.google.com/machine-learning/guides/rules-of-ml)


<div id="capitulo-95---machine-learning---guia-definitivo---parte-5"></div>

# Capítulo 95 – Machine Learning – Guia Definitivo – Parte 5


Nos 10 capítulos finais deste livro online vamos trazer um grande resumo sobre Machine Learning. O objetivo é fornecer uma visão clara do que é e como Machine Learning está sendo usado no dia a dia, um pouco de matemática, as principais regras e princípios. Queremos ainda que esses capítulos finais possam servir de material de referência para os alunos que estão buscando as certificações oferecidas pela DSA no [Bootcamp de Certificação](https://www.datascienceacademy.com.br/course/bootcamp-cientista-de-dados).


Serão 10 partes no total com um guia completo sobre Machine Learning. Aproveite a leitura para compreender de forma definitiva o que é uma das tecnologias mais incríveis do nosso tempo.


E neste capítulo vamos seguir explicando para você dezenas de regras e princípios da aplicação de Machine Learning para resolver problemas de negócio!


Boa leitura!


### Regras e Princípios


O segundo grupo de regras e princípios é sobre o monitoramento dos modelos de aprendizado de máquina. O primeiro grupo foi descrito no [capítulo anterior](https://www.deeplearningbook.com.br/machine-learning-guia-definitivo-parte-4/).


**Regra 8: Defina o nível de atualização do modelo**


O trabalho termina quando o modelo de ML é criado? Não. O modelo é criado, colocado em produção e vai precisar de atualização constante. Quão constante? Isso é o que precisa ser definido.


Quanto o desempenho diminui se você tiver um modelo com um dia de idade (criado ontem)? Uma semana de idade? Um mês de idade? Essas informações podem ajudá-lo a entender as prioridades do seu monitoramento. Se você perder qualidade significativa se o modelo não for atualizado por um dia, faz sentido ter um [Engenheiro de Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-machine-learning) observando-o continuamente. 


A maioria dos sistemas de veiculação de anúncios tem novos anúncios para lidar todos os dias e devem ser atualizados diariamente. 


Por exemplo, se o modelo de ML para a Pesquisa do Google Play não for atualizado, ele poderá ter um impacto negativo em menos de um mês. Alguns modelos do *What’s Hot in Google Plus* não têm identificador de postagem e esses modelos são atualizados com pouca frequência. Outros modelos que possuem identificadores de postagem são atualizados com muito mais frequência. 


Observe também que a atualização pode mudar ao longo do tempo, especialmente quando colunas de recursos são adicionadas ou removidas do seu modelo.


**Regra 9: Detecte problemas antes de exportar modelos**


Muitos sistemas de aprendizado de máquina têm um estágio em que você exporta o modelo para publicar em produção. Se houver um problema com um modelo exportado, é um problema que vai gerar impacto no usuário final.


Faça verificações de sanidade antes de exportar o modelo. Especificamente, certifique-se de que o desempenho do modelo seja razoável em dados de teste. Ou, se você tiver dúvidas persistentes com os dados, não exporte um modelo. Muitas equipes que implantam modelos continuamente verificam a métrica área sob a curva ROC (ou AUC) antes de exportar. Problemas sobre modelos que não foram exportados exigem um alerta por e-mail para a equipe de Data Science, mas problemas em um modelo voltado para o usuário podem exigir uma página web explicando o que ocorreu. Então é melhor esperar e ter certeza antes de impactar os usuários.


**Regra 10: Fique atento a falhas silenciosas**


Esse é um problema que ocorre mais em sistemas de aprendizado de máquina do que em outros tipos de sistemas. 


Suponha que uma determinada tabela usada para alimentar um modelo de ML em produção não esteja mais sendo atualizada. O sistema de aprendizado de máquina se ajustará e o comportamento continuará razoavelmente bom, decaindo gradualmente. Às vezes, você encontra tabelas que estão meses desatualizadas e uma simples atualização melhora o desempenho mais do que uma nova versão do modelo.


A cobertura de um recurso pode mudar devido a mudanças na implementação: por exemplo, uma coluna de recurso pode ser preenchida em 90% dos exemplos e cair repentinamente para 60% dos exemplos. Se você acompanhar as estatísticas dos dados, bem como inspecionar manualmente os dados de vez em quando, poderá reduzir esses tipos de falhas.


**Regra 11: Forneça os proprietários e a documentação das colunas de recursos**


Se o sistema for grande e houver muitas colunas de recurso (muitas variáveis no dataset), saiba quem criou ou está mantendo cada coluna de recurso. 


Se você achar que a pessoa que entende uma coluna de recurso está saindo da empresa, certifique-se de que alguém tenha as informações. Embora muitas colunas de recursos tenham nomes descritivos, é bom ter uma descrição mais detalhada do que é o recurso, de onde veio e como se espera que ele ajude mo sistema de ML.


Documente cada etapa do trabalho e mantenha um log de atualizações e modificações do modelo e dos dados ao longo do tempo.


Continuaremos no próximo capítulo.


Referências:


[Formação Linguagem Python Para Data Science](https://www.datascienceacademy.com.br/bundle/formacao-linguagem-python-para-data-science)


[Formação Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-machine-learning)


[Rules of Machine Learning](https://developers.google.com/machine-learning/guides/rules-of-ml)


<div id="capitulo-96---machine-learning---guia-definitivo---parte-6"></div>

# Capítulo 96 – Machine Learning – Guia Definitivo – Parte 6


Nos 10 capítulos finais deste livro online vamos trazer um grande resumo sobre Machine Learning. O objetivo é fornecer uma visão clara do que é e como Machine Learning está sendo usado no dia a dia, um pouco de matemática, as principais regras e princípios. Queremos ainda que esses capítulos finais possam servir de material de referência para os alunos que estão buscando as certificações oferecidas pela DSA no [Bootcamp de Certificação](https://www.datascienceacademy.com.br/course/bootcamp-cientista-de-dados).


Serão 10 partes no total com um guia completo sobre Machine Learning. Aproveite a leitura para compreender de forma definitiva o que é uma das tecnologias mais incríveis do nosso tempo.


E neste capítulo vamos seguir explicando para você dezenas de regras e princípios da aplicação de Machine Learning para resolver problemas de negócio!


Boa leitura!


### Regras e Princípios


O terceiro grupo de regras e princípios é sobre definição de métricas e objetivos dos modelos de aprendizado de máquina. O segundo grupo foi descrito no [capítulo anterior](https://www.deeplearningbook.com.br/machine-learning-guia-definitivo-parte-5/).


**Regra 12: Métricas Técnicas x Métricas de Negócio**


As métricas técnicas são aquelas triviais em Machine Learning: acurácia, precisão, recall para modelos de classificação e erro quadrático médio e coeficiente de determinação para podemos de regressão, por exemplo.


As métricas de negócio dizem respeito ao objetivo do modelo de Machine Learning. Se o modelo prevê a taxa e cliques em um anúncio de um portal, qual foi a taxa efetiva de cliques no anúncio? Ou ainda, se o modelo prevê a taxa de turnover de funcionários de uma empresa, qual foi a taxa efetiva de turnover?


Ajustar todas as essas métricas é bem complicado, mas no final das contas é esse nosso trabalho. Primeiro medimos as métricas técnicas usando os dados de teste antes do modelo seguir para produção e, então, medimos as métricas de negócio depois que o modelo está em produção, calculando as previsões do modelo e comparando com o resultado efetivo.


Uma boa acurácia nos dados de teste não significa necessariamente que o modelo terá uma boa performance mais tarde ao prever o clique em um anúncio, por exemplo. Por quê? Porque o padrão nos dados pode mudar. Usamos dados históricos para treinar a avaliar o modelo, logo, a acurácia é medida com dados históricos. Já a métrica de negócio será medida com novos dados e o padrão pode ter mudado por conta de um feriado, mudança na preferência do usuário ou velocidade do web site. Se a métrica de negócio estiver ruim, devemos voltar e re-treinar o modelo com novos dados históricos. De fato, muitas empresas re-treinam seus modelos todos os dias, o que normalmente é trabalho de um [Engenheiro de Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-machine-learning).


**Regra 13: Defina qual objetivo você deseja otimizar**


Existem dúzias de métricas com as quais você se importa e você deve medir todas elas. No entanto, no início do processo de aprendizado de máquina, você notará que todas elas estão subindo, mesmo aquelas que você não otimiza diretamente. Por exemplo, suponha que você se preocupe com o número de cliques e o tempo gasto no web site. Se você otimizar seu modelo para prever com mais precisão o número de cliques, provavelmente verá melhoria na métrica que prevê o tempo gasto no web site. Isso é comum no começo do ciclo de vida de modelos de Machine Learning.


Portanto, mantenha as coisas simples e não pense muito em equilibrar métricas diferentes quando você ainda pode aumentar facilmente todas as métricas. No entanto, não leve essa regra longe demais: não confunda seu objetivo com a saúde final do sistema. Queremos um modelo equilibrado sendo executado em produção.


**Regra 14: Escolha uma métrica simples, observável e atribuível para seu primeiro objetivo**


Muitas vezes você não sabe qual é o verdadeiro objetivo. Você pensa que sabe, mas ao observar os dados e analisar os resultados do modelo de Machine Learning, percebe que deseja ajustar o objetivo.


Além disso, diferentes membros da equipe de Data Science muitas vezes não conseguem concordar com o verdadeiro objetivo. O objetivo de um modelo de Machine Learning deve ser algo que seja fácil de medir e seja um proxy para o objetivo “verdadeiro”. Portanto, treine o modelo com um objetivo simples e considere ter uma “camada de política” no topo que permita adicionar lógica complementar (esperamos uma lógica muito simples) para fazer a classificação final. Ou seja, sobre a previsão feita pelo modelo adicionamos uma lógica definida por seres humanos (ensinamos isso em diversos cursos na [Data Science Academy](https://www.datascienceacademy.com.br)). Lembre-se: Machine Learning é um meio e não um fim.


A coisa mais fácil de modelar é um comportamento do usuário que é observado diretamente e atribuível a uma ação do sistema:


* Este link classificado foi clicado?
* Este objeto foi classificado?
* Este objeto classificado foi baixado?
* Este objeto classificado foi encaminhado/respondido/enviado por e-mail?
* Este objeto mostrado foi marcado como spam/ofensivo?


Evite modelar efeitos indiretos no início:


* O usuário visitou o web site no dia seguinte?
* Quanto tempo o usuário visitou o site?
* Quais eram os usuários ativos diários?


Os efeitos indiretos são ótimas métricas e podem ser usados ​​durante o Teste A/B e durante as decisões de lançamento. Os alunos estudam Testes A/B no curso de [Business Analytics](https://www.datascienceacademy.com.br/course/anlise-de-dados-com-matlab).


Por fim, não tente fazer o aprendizado de máquina descobrir:


* O usuário está satisfeito com o produto?
* O usuário está satisfeito com a experiência?
* O produto está melhorando o bem-estar geral do usuário?
* Como isso afetará a saúde geral da empresa?


Tudo isso é importante, mas também incrivelmente difícil de medir. Em vez disso, use proxies: se o usuário estiver satisfeito, ele permanecerá no site por mais tempo. Se o usuário estiver satisfeito, ele visitará novamente o web site amanhã. No que diz respeito ao bem-estar e à saúde da empresa, o julgamento humano é necessário para conectar qualquer objetivo de Machine Learning à natureza do produto que sua empresa está vendendo e ao plano de negócios.


**Regra 15: Começar com um modelo interpretável facilita a depuração**


Regressão linear e regressão logística são diretamente motivadas por um modelo probabilístico. Cada previsão é interpretável como uma probabilidade ou um valor esperado. Isso os torna mais fáceis de depurar do que modelos que usam objetivos que tentam otimizar diretamente a precisão da classificação ou o desempenho da classificação. Por exemplo, se as probabilidades no treinamento se desviarem das probabilidades previstas lado a lado ou pela inspeção do sistema de produção, esse desvio pode revelar um problema.


Com modelos simples, é mais fácil lidar com loops de feedback. Muitas vezes, usamos essas previsões probabilísticas para tomar uma decisão. Por exemplo, classificar as postagens em valor esperado decrescente (ou seja, probabilidade de clique/download/etc.). No entanto, lembre-se quando chegar a hora de escolher qual modelo usar, a decisão final importa mais do que a probabilidade dos dados fornecidos ao modelo.


Comece com modelos mais simples e interpretáveis para conquistar a confiança das áreas de negócio e gestores. Com o suporte deles será mais fácil avançar para o uso de modelos mais complexos.


Continuaremos no próximo capítulo.


Referências:


[Formação Linguagem Python Para Data Science](https://www.datascienceacademy.com.br/bundle/formacao-linguagem-python-para-data-science)


[Formação Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-machine-learning)


[Rules of Machine Learning](https://developers.google.com/machine-learning/guides/rules-of-ml)


<div id="capitulo-97---machine-learning---guia-definitivo---parte-7"></div>

# Capítulo 97 – Machine Learning – Guia Definitivo – Parte 7


Nos 10 capítulos finais deste livro online vamos trazer um grande resumo sobre Machine Learning. O objetivo é fornecer uma visão clara do que é e como Machine Learning está sendo usado no dia a dia, um pouco de matemática, as principais regras e princípios. Queremos ainda que esses capítulos finais possam servir de material de referência para os alunos que estão buscando as certificações oferecidas pela DSA no [Bootcamp de Certificação](https://www.datascienceacademy.com.br/course/bootcamp-cientista-de-dados).


Serão 10 partes no total com um guia completo sobre Machine Learning. Aproveite a leitura para compreender de forma definitiva o que é uma das tecnologias mais incríveis do nosso tempo.


Neste capítulo vamos seguir explicando para você dezenas de regras e princípios sobre Machine Learning para resolver problemas de negócio, agora com ênfase na Engenharia de Atributos (Feature Engineering).


Boa leitura!


### Engenharia de Atributos


A Engenharia de Atributos (também chamada de Engenharia de Recursos) é uma das partes mais importantes e ao mesmo tempo mais complexas em Machine Learning. 


Quando estamos diante de um problema e recebemos os dados, não sabemos previamente se cada variável (cada atributo ou recurso) é realmente útil ou não. Também não sabemos se a combinação de variáveis pode ser mais interessante do que o uso de variáveis individuais. Ou ainda, não sabemos se outros atributos serão necessários. E como resolvemos isso?


Através da experimentação, trabalho fundamental do [Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados). Ou seja, diversos experimentos devem ser feitos com diferentes atributos a fim de chegar no conjunto ideal para resolver determinado problema. E diversas técnicas podem ser usadas na Engenharia de Atributos, técnicas que são ensinadas nos cursos da DSA.


Mas depois que o modelo está criado e em produção, será que podemos melhorar sua performance incluindo mais atributos ou modificando atributos já usados pelo modelo? Afinal, o padrão previamente detectado nos dados pode mudar ao longo do tempo e a performance do modelo será reduzida de forma gradual. Logo, mesmo depois que o modelo estiver em produção o trabalho de Engenharia de Atributos continua, mas nesse caso passa a ser responsabilidade do [Engenheiro de Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-machine-learning).


Vamos continuar listando as regras e princípios em Machine Learning e agora compreender algumas técnicas fundamentais ao trabalhar com Engenharia de Atributos. Algumas das técnicas listadas aqui são de nível avançado e requerem boa experiência em Machine Learning e no processo de Ciência de Dados.


**Regra 16: O Processo é Iterativo**


Não espere que o modelo em que você está trabalhando agora seja a última e perfeita versão. De fato, o modelo nunca será perfeito e raramente será a última versão. O processo é iterativo e contínuo. 


Muitas equipes lançam um modelo para um determinado problema por trimestre ou por semestre (lembrando que cada problema de negócio vai requerer um modelo diferente). Existem três razões básicas para lançar novos modelos:


* Você deseja usar novos recursos (atributos) testados recentemente.
* Você está ajustando a regularização e combinando recursos antigos de novas maneiras.
* Você está ajustando o objetivo.


Assim como qualquer sistema de software, um modelo de Machine Learning tem o seu ciclo de vida e requer manutenção constante. Monitorando as métricas conseguimos detectar eventuais quedas de performance e tomar ações para que o modelo siga atendendo o propósito para o qual ele foi criado. A Engenharia de Atributos será, portanto, um processo constante.


**Regra 17: Comece com Recursos Observados Diretamente em Oposição aos Recursos Aprendidos**


Este pode ser um ponto controverso, mas evita muitas armadilhas. Em primeiro lugar, vamos descrever o que é um recurso aprendido. 


Um recurso aprendido é um recurso gerado por um sistema externo (como um sistema de clustering não supervisionado) ou pelo próprio modelo (por exemplo, por meio de um modelo fatorado ou aprendizado profundo). Ambos podem ser úteis, mas podem ter muitos problemas, portanto, não devem estar na primeira versão do modelo.


Se você usar um sistema externo para criar um recurso, lembre-se de que o sistema externo tem seu próprio objetivo. O objetivo do sistema externo pode ser apenas fracamente correlacionado com seu objetivo atual. Se você capturar um instantâneo do sistema externo, ele poderá ficar desatualizado. Se você atualizar os recursos do sistema externo, os significados podem mudar. Se você usar um sistema externo para fornecer um recurso, saiba que essa abordagem requer muito cuidado. 


Quem disse que seria fácil?


O principal problema com modelos fatorados e modelos profundos é que eles não são convexos. Assim, não há garantia de que uma solução ótima possa ser aproximada ou encontrada e os mínimos locais encontrados em cada iteração podem ser diferentes. 


Essa variação torna difícil julgar se o impacto de uma mudança em seu sistema é significativo ou aleatório. Ao criar um modelo sem recursos profundos, você pode obter um excelente desempenho de linha de base (benchmark). Depois que essa linha de base for alcançada, você pode tentar abordagens mais esotéricas.


**Regra 18: Combine Recursos Usando Discretização**


Há várias maneiras de combinar e modificar recursos. Sistemas de aprendizado de máquina, como o TensorFlow, permitem que você pré-processe seus dados por meio de transformações. As duas abordagens mais comuns são “discretizações” e “cruzamentos”.


A discretização consiste em pegar um recurso contínuo e criar muitos recursos discretos a partir dele. Considere um recurso contínuo, como a idade. Você pode criar um recurso (um novo atributo) que terá o valor 1 quando a idade for menor que 18, outro recurso que o valor será 1 quando a idade estiver entre 18 e 35, etc. Podemos usar os quartis para fazer essa divisão.


Dependendo do problema, o recurso original contínuo pode apresentar melhor performance. Mas em um outro tipo de problema, o mesmo recurso de forma discretizada pode ser uma melhor opção. A discretização oferece ainda uma vantagem: pode ser mais fácil de compreender para os seres humanos e assim facilitar a interpretação dos resultados de um modelo.


No fim, precisamos experimentar. Isso faz parte do nosso trabalho em Ciência de Dados.


**Regra 19: Combine Recursos Usando Cruzamento**


Cruzamentos combinam duas ou mais colunas de recursos. Uma coluna de recursos, na terminologia do TensorFlow, é um conjunto de recursos homogêneos (por exemplo, {masculino, feminino}, {EUA, Canadá, México} etc.). 


Um cruzamento é uma nova coluna de recurso com recursos em, por exemplo, {masculino, feminino} × {EUA, Canadá, México}. Esta nova coluna de recurso conterá o recurso (masculino, Canadá). Se você estiver usando o TensorFlow e disser ao TensorFlow para criar esse cruzamento para você, esse recurso (masculino, Canadá) estará presente em exemplos que representam homens canadenses. Observe que são necessárias grandes quantidades de dados para aprender modelos com cruzamentos de três, quatro ou mais colunas de recursos básicos. Isso é muito útil para regras de associação e sistemas de recomendação.


Cruzamentos que produzem colunas de recursos muito grandes podem se ajustar demais. Por exemplo, imagine que você está fazendo algum tipo de pesquisa e tem uma coluna de recurso com palavras na consulta e uma coluna de recurso com palavras no documento. Você pode combiná-los com um cruzamento, mas acabará com muitos recursos.


Ao trabalhar com texto, existem duas alternativas. O mais draconiano é um produto escalar. Um produto escalar em sua forma mais simples conta o número de palavras em comum entre a consulta e o documento. Este recurso pode então ser discretizado. Outra abordagem é uma interseção: assim, teremos um recurso que está presente se e somente se a palavra “pônei” estiver no documento e na consulta, e outro recurso que está presente se e somente se a palavra “o” estiver no documento e na consulta, por exemplo.


**Regra 20: Use Recursos Muito Específicos Quando Puder**


Com toneladas de dados é mais simples aprender milhões de recursos simples do que alguns recursos complexos. 


Portanto, não tenha medo de grupos de recursos em que cada recurso se aplica a uma fração muito pequena de seus dados, mas a cobertura geral está acima de 90%. Você pode usar a regularização para eliminar os recursos que se aplicam a poucos exemplos.


**Regra 21: Pesos dos Recursos**


O número de pesos de recursos que você pode aprender em um modelo linear é aproximadamente proporcional à quantidade de dados que você possui.


Existem resultados fascinantes da teoria da aprendizagem estatística sobre o nível apropriado de complexidade para um modelo, mas essa regra é basicamente tudo o que você precisa saber. Muitos profissionais duvidam que algo possa ser aprendido com mil exemplos, ou que você precisaria de mais de um milhão de exemplos, porque eles ficam presos a um certo método de aprendizado. A chave é dimensionar seu aprendizado para o tamanho de seus dados. Por exemplo:


Se você estiver trabalhando em um sistema de classificação de pesquisa e houver milhões de palavras diferentes nos documentos e na consulta e tiver 1.000 exemplos rotulados, você deve usar um produto escalar entre os recursos de documento e consulta, TF-IDF e uma dúzia de outros recursos altamente projetados por humanos. Ou seja, 1000 exemplos, uma dúzia de recursos.


Se você tiver um milhão de exemplos, cruze as colunas de recurso de consulta e documento, usando regularização e possivelmente seleção de recurso. Isso lhe dará milhões de recursos, mas com a regularização você terá menos. Ou seja, 10 milhões de exemplos, talvez 100 mil recursos.


Se você tiver bilhões ou centenas de bilhões de exemplos, poderá cruzar as colunas de recursos com tokens de documento e consulta, usando seleção e regularização de recursos. Você terá um bilhão de exemplos e 10 milhões de recursos. 


A teoria da aprendizagem estatística raramente fornece limites, mas dá uma ótima orientação para um ponto de partida.


**Regra 22: Limpe os Recursos Que Você Não Está Mais Usando**


Recursos não utilizados criam dívida técnica. 


Se você achar que não está usando um recurso e que combiná-lo com outros recursos não está funcionando, remova-o de sua infraestrutura e do seu modelo (o modelo obviamente terá que ser retreinado sem aquele recurso). 


Você deve manter sua infraestrutura limpa para que os recursos mais promissores possam ser testados o mais rápido possível. Se necessário, alguém sempre pode adicionar de volta seu recurso. Por isso as Features Stores (Lojas de Recursos) estão cada vez mais populares. São repositórios que armazenam os recursos já tratados e processados e que podem ser usados a qualquer momento. Leia mais sobre isso [aqui](https://www.cienciaedados.com/o-que-sao-feature-stores-e-por-que-sao-essenciais-na-escalabilidade-em-data-science/). 


Lembre-se da cobertura ao considerar quais recursos adicionar ou manter. Quantos exemplos são cobertos pelo recurso? Por exemplo, se você tiver alguns recursos de personalização, mas apenas 8% de seus usuários tiverem recursos de personalização, isso não será muito eficaz.


Se, por outro lado, você tem um recurso que cobre apenas 1% dos dados, mas 90% dos exemplos que têm o recurso são positivos, então será um ótimo recurso para adicionar.


Machine Learning não é mais um hype. É uma tecnologia usada pelas empresas no dia a dia e a gestão desse processo se torna cada vez mais importante.


Continuaremos no próximo capítulo.


Referências:


[Formação Linguagem Python Para Data Science](https://www.datascienceacademy.com.br/bundle/formacao-linguagem-python-para-data-science)


[Formação Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-machine-learning)


[Rules of Machine Learning](https://developers.google.com/machine-learning/guides/rules-of-ml)


<div id="capitulo-98---machine-learning---guia-definitivo---parte-8"></div>

# Capítulo 98 – Machine Learning – Guia Definitivo – Parte 8


Nos 10 capítulos finais (de 91 a 100) deste livro online vamos trazer um grande resumo sobre Machine Learning. O objetivo é fornecer uma visão clara do que é e como Machine Learning está sendo usado no dia a dia, um pouco de matemática, as principais regras e princípios. Queremos ainda que esses capítulos finais possam servir de material de referência para os alunos que estão buscando as certificações oferecidas pela DSA no [Bootcamp de Certificação](https://www.datascienceacademy.com.br/course/bootcamp-cientista-de-dados).


Serão 10 partes no total com um guia completo sobre Machine Learning. Aproveite a leitura para compreender de forma definitiva o que é uma das tecnologias mais incríveis do nosso tempo.


Neste capítulo vamos abordar algumas regras que raramente você verá sendo explicadas nos cursos em geral por aí, pelo simples fato que muitos que ensinam Machine Learning nunca colocaram um modelo em produção: Como analisar um modelo existente e melhorá-lo? Isso é mais uma arte do que uma ciência e existem vários padrões e técnicas que ajudam com essa tarefa.


Boa leitura!


### O Que é o Deploy de Modelos de Machine Learning?


Antes de trazer as regras para você, vamos compreender claramente o que é colocar um modelo em produção, o que tem vários sinônimos: servir o modelo, implantar o modelo, fazer o deploy do modelo.


Os modelos de Machine Learning (ML) quase sempre são desenvolvidos em uma configuração offline, mas devem ser implantados em um ambiente de produção para fazer previsões ou detectar padrões com novos dados e, então, agregar valor.


O objetivo de construir um aplicativo de aprendizado de máquina é resolver um problema e um modelo de ML só pode fazer isso quando está sendo usado ativamente em produção. 


Como tal, a implantação do modelo de ML é tão importante quanto o desenvolvimento do modelo de ML. Cientistas de Dados desenvolvem os modelos e Engenheiros de Machine Learning fazem o deploy.


A implantação é o processo pelo qual um modelo de ML é movido de um ambiente offline e integrado a um ambiente de produção, como um aplicativo ativo. É uma etapa crítica que deve ser concluída para que um modelo atenda ao propósito pretendido e resolva os desafios para os quais foi projetado.


O processo exato de implantação do modelo de ML será diferente dependendo do ambiente do sistema, do tipo de modelo e dos processos de DataOps e MLOps implementados em cada empresa.


Agora vamos às regras com dicas valiosas.


**Regra 23: Você Não Deve Fazer os Testes Finais no Modelo**


Você ([Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados), [Engenheiro de Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-machine-learning) ou Engenheiro de IA) não é um usuário final do modelo. Você não deve ser o responsável pelos testes finais quando o modelo estiver próximo de ser colocado em produção. 


Em última instância um modelo de Machine Learning é uma peça de software e uma regra básica da Engenharia de Software é que os testes devem ser feitos por quem não desenvolveu a solução. Ensinamos isso no primeiro curso da [Formação Engenheiro de Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-machine-learning).


Os testes finais de um modelo de Machine Learning devem ser feitos por usuários, preferencialmente usuários que irão usar o sistema ou que serão responsáveis pelo suporte ao usuário final.


**Regra 24: Obtenha Feedback Contínuo**


Uma vez que o modelo seja colocado em produção e testado pelos usuários, isso não significa que o trabalho acabou. Muito pelo contrário. O modelo deve ser constantemente monitorado e novas rodadas de validação e testes com os usuários finais devem ser realizadas. Quanto mais feedback você obter sobre o uso do modelo, mais fácil identificar e corrigir problemas.


Para obter feedback contínuo, considere perguntas como essas:


* Como podemos obter o feedback dos modelos de produção?
* Como podemos garantir uma entrega constante?
* Como podemos testar novas iterações do modelo?
* Como podemos iterar nosso modelo sem interromper sua operação?


Crie uma base de conhecimento com o feedback contínuo do modelo em produção e o uso de Machine Learning se torna algo de valor cada vez maior para a empresa.


**Regra 25: Calcule o Delta Entre os Modelos**


Se você já tiver um modelo de Machine Learning em produção e está preparando uma nova versão do modelo, esse é um bom momento para calcular a diferença de performance entre ambos. Por isso a regra 24 anterior é tão importante. Com a ajuda da validação feita por um usuário final, você pode calcular e medir a diferença de performance entre o modelo atual em produção e o novo modelo com as melhorias. 


Além de criar documentação, permite demonstrar a evolução do trabalho e como a empresa está conseguindo construir modelos cada vez melhores. E o contrário também é verdadeiro. Uma mudança que poderia melhorar a performance pode, na verdade, piorá-la e esse é o momento de detectar isso. 


Calculando o delta da diferença de performance, podemos facilmente responder perguntas do tipo: Qual o percentual de melhoria de performance do modelo em produção depois das alterações realizadas? Qual foi o custo dessa melhoria? Quanto tempo foi necessário?


**Regra 26: Ao Atualizar Modelos, a Solução do Problema é Mais Importante do Que o Poder Preditivo**


Seu modelo pode tentar prever a taxa de cliques, por exemplo. No entanto, no final, a questão-chave é o que você faz com essa previsão. Se você estiver usando o modelo para classificar documentos, a qualidade da classificação final importa mais do que o poder de previsão. 


Machine Learning não é um fim. É um meio para resolver problemas. Logo, a performance geral do sistema é mais importante do que o poder preditivo do modelo. 


Imagine um modelo usado para previsão se uma mensagem é spam ou não. O modelo não precisa ser 100% eficaz. Se conseguir prever que um documento é spam com 55% de probabilidade isso já é suficiente e a performance final do sistema (ter cada mensagem classificada como spam ou não) será ótima.


É comum tentar levar o modelo ao limite da perfeição (como se isso fosse realmente possível), quando na verdade o poder de previsão é menos importante do que o resultado em si.


**Regra 27: Procure Padrões nos Erros do Modelo em Produção e Crie Novos Recursos**


Suponha que você veja um exemplo de que o modelo em produção errou na previsão. Em uma tarefa de classificação, esse erro pode ser um falso positivo ou um falso negativo. Em uma tarefa de classificação, o erro pode ser um par em que um positivo foi classificado abaixo de um negativo. 


O ponto mais importante é que este é um exemplo de que o sistema de aprendizado de máquina sabe o que deu errado e gostaria de corrigir se tivesse a oportunidade. Se você fornecer ao modelo um recurso que permita corrigir o erro, o modelo tentará usá-lo.


Logo, se o modelo em produção foi treinado com 10 recursos (10 variáveis), pode ser que a inclusão de mais um recurso aumente de forma significativa a performance do modelo. Por isso é tão importante monitorar o modelo em produção, pois o padrão que havia nos dados usados no treinamento pode mudar ao longo do tempo e novos recursos podem ser necessários.


**Regra 28: Tente Quantificar o Comportamento Indesejável Observado**


É natural que um modelo tenha perda de performance ao longo do tempo. Os eventos que geraram os dados mudam, os padrões de comportamento mudam, os dados mudam. 


Em determinado momento, um modelo em produção pode começar a apresentar comportamento indesejado, indicando que sua performance está deteriorando. Mas qual o limite aceitável e como quantificar isso?


O ideal nesse caso é criar uma métrica para quantificar o comportamento indesejado. Por exemplo, se é aceitável um modelo classificar mensagens como spam com 55% de probabilidade, se esse valor for reduzido para 52% é hora de tomar alguma ação. Ou seja, não temos que esperar o modelo começar a errar para então otimizá-lo.


A regra geral é “medir primeiro, otimizar depois”. Não caia na tentação de querer otimizar algo que você não mediu antes.


**Regra 29: Esteja Ciente de Que Comportamento Idêntico de Curto Prazo Não Implica Comportamento Idêntico de Longo Prazo**


A mudança é a regra. 


Uma boa estratégia depois que os dados estiverem em produção é continuar coletando novos dados e retreinar o modelo periodicamente. Algumas empresas retreinam seus modelos todos os dias, algumas uma vez por semana e isso vai depender do volume de dados disponível.


Mas o fato é que mudanças de comportamento são esperadas e o modelo não pode ficar muito tempo sem atualização. É possível criar um repositório de versionamento de modelos para garantir que tenhamos sempre a versão mais atual disponível em produção. E mesmo se o modelo parece apresentar boa performance por vários dias seguidos, isso não é garantia que irá permanecer assim por muito tempo.


**Regra 30: Reutilize o Código Entre o Pipeline de Treinamento e o Pipeline de Deploy Sempre que Possível**


O processamento em lote é diferente do processamento online. No processamento online, você deve lidar com cada solicitação à medida que ela chega (por exemplo, você deve fazer uma pesquisa separada para cada consulta), enquanto no processamento em lote, você pode combinar tarefas (por exemplo, fazer uma junção). 


Quando o modelo está em produção, você está fazendo o processamento online, enquanto o treinamento do modelo é uma tarefa de processamento em lote. No entanto, há algumas coisas que você pode fazer para reutilizar o código. 


Por exemplo, você pode criar um objeto que seja específico do seu sistema onde o resultado de quaisquer consultas ou junções pode ser armazenado de uma maneira muito legível e os erros podem ser testados facilmente. Então, depois de reunir todas as informações, com o modelo em produção ou em treinamento, você executa um método comum para fazer a ponte entre o objeto legível por humanos específico do seu sistema e qualquer formato que o sistema de aprendizado de máquina espera. 


Isso elimina uma fonte de distorção entre o modelo em produção e o treinamento. Tente não usar duas linguagens de programação diferentes entre treinar e servir. Essa decisão tornará quase impossível compartilhar código.


**Regra 31: Se Você Produzir um Modelo com Base nos Dados até 5 de Janeiro, Teste o Modelo nos Dados de 6 de Janeiro em Diante**


Em geral, meça o desempenho de um modelo nos dados coletados após os dados nos quais você treinou o modelo, pois isso reflete melhor o que seu sistema fará em produção. 


Se você produzir um modelo com base nos dados até 5 de janeiro, teste o modelo nos dados a partir de 6 de janeiro, por exemplo. Você esperará que o desempenho não seja tão bom nos novos dados, mas não deve ser radicalmente pior. 


Como pode haver efeitos diários, você pode não prever a taxa média de cliques ou a taxa de conversão, mas a área sob a curva, que representa a probabilidade de dar ao exemplo positivo uma pontuação mais alta do que a um exemplo negativo, deve ser razoavelmente próxima.


**Regra 32: Na classificação binária para filtragem (como detecção de spam ou determinação de e-mails interessantes), faça pequenos sacrifícios de curto prazo no desempenho para obter dados limpos**


Em uma tarefa de filtragem, os exemplos marcados como negativos não são mostrados ao usuário final da aplicação que contém o modelo de Machine Learning. 


Suponha que você tenha um filtro que bloqueie 75% dos exemplos negativos em produção. Você pode ficar tentado a extrair dados de treinamento adicionais das instâncias mostradas aos usuários. Por exemplo, se um usuário marca um e-mail como spam que seu filtro deixou passar, você pode querer aprender com isso.


Mas essa abordagem introduz viés de amostragem. Você pode coletar dados mais limpos se, com o modelo em produção, rotular 1% de todo o tráfego como “retido” e enviar todos os exemplos retidos ao usuário. Agora seu filtro está bloqueando pelo menos 74% dos exemplos negativos. Esses exemplos retidos podem se tornar seus dados de treinamento.


Observe que se o seu filtro estiver bloqueando 95% dos exemplos negativos ou mais, essa abordagem se tornará menos viável. Mesmo assim, se você deseja medir o desempenho em produção, pode fazer uma amostra ainda menor (digamos 0,1% ou 0,001%). Dez mil exemplos são suficientes para estimar o desempenho com bastante precisão.


**Regra 33: Evite Loops de Feedback com Características Posicionais**


A posição do conteúdo afeta drasticamente a probabilidade de o usuário interagir com ele. Se você colocar um botão na primeira posição no topo de uma página, ele será clicado com mais frequência do que um botão no final da página. A posição fará com que um botão seja muito mais clicado do que o outro e isso pode dar a impressão que o primeiro botão é melhor. Não. Ele apenas está posicionado de forma que o cérebro humano o percebe primeiro.


Uma maneira de lidar com isso é adicionar características posicionais, ou seja, características sobre a posição do conteúdo na página. Você treina seu modelo com recursos posicionais e ele aprende a ponderar, por exemplo, o recurso “1stposition” fortemente. Seu modelo, portanto, dá menos peso a outros fatores para exemplos com “1stposition=true”. 


Então, ao servir o modelo, você não dá a nenhuma instância o recurso posicional, ou dá a todos o mesmo recurso padrão, porque você está pontuando os candidatos antes de decidir a ordem na qual exibi-los.


Observe que é importante manter quaisquer recursos posicionais um pouco separados do restante do modelo devido a assimetria entre treinamento e teste. Ter o modelo como a soma de uma função dos traços posicionais e uma função do resto dos traços é o ideal. Por exemplo, não cruze os recursos posicionais com nenhum recurso de documento.


**Regra 34: Medir a Distorção Entre Treinamento/Produção**


Existem várias coisas que podem causar distorção no sentido mais geral. Além disso, você pode dividi-lo em várias partes:


A diferença entre o desempenho nos dados de treinamento e os dados de validação. Em geral, isso sempre existirá, e nem sempre é ruim.


A diferença entre o desempenho nos dados de validação e os dados do “dia seguinte”. Novamente, isso sempre existirá. Você deve ajustar sua regularização para maximizar o desempenho no dia seguinte. No entanto, grandes quedas no desempenho entre os dados de hoje e do dia seguinte podem indicar que alguns recursos são sensíveis ao tempo e possivelmente degradam o desempenho do modelo.


A diferença entre o desempenho nos dados do “dia seguinte” e os dados ao vivo. Se você aplicar um modelo a um exemplo nos dados de treinamento e o mesmo exemplo em produção, ele deverá fornecer exatamente o mesmo resultado. Assim, uma discrepância aqui provavelmente indica um erro na construção do modelo.


**Regra 35: Prepara-se Para o Deploy Através de Containers**


Hoje a tecnologia de containers (máquinas virtuais super leves) é quase um padrão em Machine Learning e Engenharia de Dados (e por isso o tema é abordado em detalhes nos cursos em nosso portal).


Ao fazer o deploy de um modelo você não estará enviando o modelo em si, mas um container com o modelo, suas dependências, arquivos de configuração, parâmetros e muito mais. Isso simplifica o deploy, mas requer cuidados adicionais, especialmente com o versionamento. Certifique-se que você domina a tecnologia de containers e conhece muito bem o Docker.


Continuaremos no próximo capítulo.


Referências:


[Curso Gratuito de Sistema Operacional Linux, Docker e Kubernetes](https://www.datascienceacademy.com.br/course/modulos-extras-de-capacitacao-profissional)


[Machine Learning com Python e R](https://www.datascienceacademy.com.br/course/machine-learning-engineer)


[Machine Learning com Python e C++](https://www.datascienceacademy.com.br/course/machine-learning-em-python-e-c)


[Rules of Machine Learning](https://developers.google.com/machine-learning/guides/rules-of-ml)


[Deploy de Modelos de Machine Learning](https://www.datascienceacademy.com.br/course/deploy-de-modelos-de-machine-learning)


<div id="capitulo-99---machine-learning---guia-definitivo---parte-9"></div>

# Capítulo 99 – Machine Learning – Guia Definitivo – Parte 9


Nos 10 capítulos finais (de 91 a 100) deste livro online vamos trazer um grande resumo sobre Machine Learning. O objetivo é fornecer uma visão clara do que é e como Machine Learning está sendo usado no dia a dia, um pouco de matemática, as principais regras e princípios. Queremos ainda que esses capítulos finais possam servir de material de referência para os alunos que estão buscando as certificações oferecidas pela DSA no [Bootcamp de Certificação](https://www.datascienceacademy.com.br/course/bootcamp-cientista-de-dados).


Serão 10 partes no total com um guia completo sobre Machine Learning. Aproveite a leitura para compreender de forma definitiva o que é uma das tecnologias mais incríveis do nosso tempo.


Neste capítulo vamos continuar abordando algumas regras que iniciamos no capítulo anterior e que raramente você verá sendo explicadas nos cursos em geral por aí, pelo simples fato que muitos que ensinam Machine Learning nunca colocaram um modelo em produção. Vamos agora responder à seguinte pergunta: Quais são as estratégias ideais para o deploy de modelos de Machine Learning?


Boa leitura!


**Regra 36: Deploy do Modelo Como Web Service**


A maneira mais simples de implantar um modelo de aprendizado de máquina é criar um web service para entregar as previsões do modelo. Um web service é um sistema de software que suporta interação máquina a máquina interoperável em uma rede.


Para criar um web service de aprendizado de máquina, você precisa de pelo menos três etapas:


– O primeiro passo é criar um modelo de aprendizado de máquina, treiná-lo e validar seu desempenho, normalmente tarefa de um [Cientista de Dados](https://www.datascienceacademy.com.br/bundle/formacao-cientista-de-dados).


– Na segunda etapa, precisamos persistir o modelo, ou seja, gravar o modelo em um arquivo no disco. O ambiente em que implantamos o web service geralmente é diferente de onde treinamos o modelo. Assim, essa separação ajuda as empresas a otimizar seus orçamentos e esforços. Aplicamos a serialização para persistir o modelo em disco e isso pode ser feito através de diferentes bibliotecas em Linguagens Python, R, Scala, C++ ou Java.


– Finalmente, na terceira etapa, podemos servir o modelo usando um framework web ou serviço na nuvem. O modelo é hospedado em um ambiente diferente, geralmente em um servidor na nuvem. A partir do framework web implementamos o web service que será responsável por receber os novos dados, passá-los ao pipeline de processamento e ao modelo, receber a resposta com a previsão e entregar de volta ao chamador. 


Implementar um web service é normalmente tarefa de um [Engenheiro de Machine Learning](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-machine-learning) e temos diversas ferramentas para esse propósito.


**Regra 37: Deploy do Modelo Para Previsões em Batch**


Podemos fazer o deploy de modo que os modelos de Machine Learning forneçam previsões em tempo real (usando web service, por exemplo). Nesse caso chamamos de modelos online. Mas em diversas situações é preferível ter as previsões em batch (lote) e nesse caso chamamos de modelos offline.


Os modelos offline podem ser otimizados para lidar com um alto volume de instâncias e executar modelos mais complexos. Uma outra vantagem desse tipo de deploy é que normalmente podemos usar um único tipo de hardware sem preocupação com escalabilidade.


A previsão em lote pode ser tão simples quanto chamar a função de previsão com um conjunto de dados de variáveis ​​de entrada. Isso pode ser feito via linha de comando, no Jupyter Notebook, no RStudio ou com script automatizado.


Às vezes, você terá que agendar o treinamento ou a previsão no método de processamento em lote. Existem várias maneiras de fazer isso. Uma alternativa é usar o Airflow ou o Prefect para automatizar a tarefa.


No entanto, a construção do modelo pode exigir vários estágios na estrutura de processamento em lote. Você precisa decidir quais recursos são necessários e como deve construir o modelo para cada estágio. O ideal é treinar o modelo em um sistema de computação de alto desempenho com uma estrutura de processamento em lote apropriada.


Normalmente, você particiona os dados de treinamento em segmentos que são processados ​​sequencialmente, um após o outro. Você pode fazer isso dividindo o conjunto de dados usando um esquema de amostragem (por exemplo, amostragem balanceada, amostragem estratificada) ou por meio de algum algoritmo (por exemplo, map-reduce).


As partições podem ser distribuídas para várias máquinas, mas todas devem carregar o mesmo conjunto de recursos. O dimensionamento de recursos é recomendado. Se você usou pré-treinamento não supervisionado (por exemplo, codificadores automáticos) para Transfer Learning, deverá desfazer cada partição.


Após a execução de todos os estágios, você pode fazer previsões em novos dados com o modelo resultante iterando sequencialmente nas partições.


**Regra 38: Deploy do Modelo em Dispositivos de Borda (Edge) Como Modelos Incorporados**


A computação em dispositivos de borda (Edge Computing), como dispositivos móveis e IoT, tornou-se muito popular nos últimos anos. Os benefícios de implantar um modelo de aprendizado de máquina em dispositivos de borda incluem, mas não estão limitados a:


Latência reduzida, pois o dispositivo provavelmente estará mais próximo do usuário do que um servidor distante.


Reduz o consumo de largura de banda de dados à medida que enviamos os resultados processados de volta para a nuvem, em vez de dados brutos que geralmente são maiores e, eventualmente, consomem mais largura de banda.


Mas dispositivos de borda, como dispositivos móveis e IoT, têm poder de computação e capacidade de armazenamento limitados devido à natureza de seu hardware. Não podemos simplesmente implantar modelos de aprendizado de máquina diretamente nesses dispositivos da mesma forma que faríamos em um servidor, especialmente se nosso modelo for grande ou exigir computação extensiva para executar inferência neles.


Em vez disso, devemos simplificar o modelo usando técnicas como quantização e agregação, mantendo a precisão. Esses modelos simplificados podem ser implantados com eficiência em dispositivos de borda com computação, memória e armazenamento limitados.


Podemos usar a biblioteca TensorFlow Lite para simplificar nosso modelo TensorFlow. O TensorFlow Lite é uma biblioteca de software de código aberto para dispositivos móveis e incorporados que tenta fazer o que o nome diz: executar modelos do TensorFlow em plataformas móveis e incorporadas.


**Regra 39: Monitoramento do Modelo em Produção**


O estágio de monitoramento do ciclo de vida da Ciência de Dados começa após a implantação bem-sucedida de um modelo.


O monitoramento garante que o modelo esteja funcionando corretamente e que suas previsões sejam eficazes. Claro, não é apenas o modelo que precisa ser monitorado, principalmente durante as primeiras execuções. A equipe de implantação precisa garantir que o software e os recursos de suporte estejam funcionando conforme necessário e que os usuários finais tenham sido suficientemente treinados. Aqui normalmente temos Engenheiros DataOps e [Engenheiros de Dados](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-dados) atuando.


Vários problemas podem surgir após a implantação: os recursos podem não ser adequados, o feed de dados pode não estar conectado corretamente ou os usuários podem não estar usando os aplicativos de forma adequada.


Depois que sua equipe determinar que o modelo e seus recursos de suporte estão funcionando corretamente, o monitoramento ainda precisa continuar, mas a maior parte disso pode ser automatizada até que surja um problema.


A melhor maneira de monitorar um modelo é avaliar rotineiramente seu desempenho em seu ambiente implantado. Este deve ser um processo automatizado, usando ferramentas que rastrearão as métricas para alertá-lo automaticamente caso haja alterações em sua precisão, precisão ou pontuação F.


Cada modelo implantado tem o potencial de se degradar ao longo do tempo devido a problemas como:


– Variação nos dados. Muitas vezes, os dados fornecidos ao modelo na implantação não são limpos da mesma maneira que os dados de treinamento e teste, resultando em alterações na implantação do modelo.


– Alterações na integridade dos dados. Ao longo de semanas, meses ou anos, as alterações nos dados que estão sendo alimentados no modelo podem afetar negativamente o desempenho do modelo, como alterações nos formatos, campos renomeados ou novas categorias.


– Desvio de dados. Mudanças na demografia ou mudanças no mercado podem causar desvios ao longo do tempo, tornando os dados de treinamento menos relevantes para a situação atual e os resultados do modelo, portanto, menos precisos. Por isso o modelo deve ser re-treinado periodicamente.


– Mudança de conceito. Mudanças nas expectativas dos usuários finais sobre o que constitui uma previsão correta podem mudar ao longo do tempo, tornando as previsões do modelo menos relevantes.


Usando uma plataforma de Ciência de Dados corporativa, você pode monitorar automaticamente cada um desses problemas, usando uma variedade de ferramentas de monitoramento, e fazer com que a equipe de Ciência de Dados seja alertada assim que a variação for detectada no modelo.


**Regra 40: Planejar e Projetar Protocolos Robustos de Monitoramento, Auditoria e Reciclagem**


Antes de implantar e usar um modelo preditivo, você precisa entender se ele está realmente entregando o tipo de resultado que você estava procurando. Você deve verificar se esses resultados são precisos e também se os dados que você está carregando no modelo manterão esses modelos consistentes e relevantes ao longo do tempo. Além disso, dados muito antigos usados no treinamento podem criar desvios no modelo, levando a resultados imprecisos.


Isso implica que você deve criar processos de treinamento e pipelines que atraiam novos dados, monitorem suas fontes de dados internas e informem quais recursos ainda estão fornecendo informações importantes.


Você nunca deve ficar complacente em relação a isso, ou os modelos podem estar influenciando as decisões de negócio em direções inúteis. É essencial manter os processos em posição para monitorar os resultados, garantindo que você não esteja apenas configurando cada vez mais tipos de dados errados em seu modelo preditivo.


Você também deve realizar testes AB para descobrir o desempenho desses modelos em diferentes versões.


O próximo capítulo é o de número 100, o último deste livro. E você não pode deixar de conferir o que preparamos!


Referências:


[Machine Learning com Python e R](https://www.datascienceacademy.com.br/course/machine-learning-engineer)


[Machine Learning com Python e C++](https://www.datascienceacademy.com.br/course/machine-learning-em-python-e-c)


[Deploy de Modelos de Machine Learning](https://www.datascienceacademy.com.br/course/deploy-de-modelos-de-machine-learning)


<div id="capitulo-100---machine-learning---guia-definitivo---parte-10"></div>

# Capítulo 100 – Machine Learning – Guia Definitivo – Parte 10


Chegamos ao final do Deep Learning Book. Este é o centésimo e último capítulo deste livro online, em português, gratuito e agora com 100 capítulos!


Antes de mais nada nós da DSA gostaríamos de agradecer a você que acompanhou todo este trabalho realizado até aqui. 


O Deep Learning Book nasceu do nosso inconformismo em ver pouco conhecimento sendo gerado em português sobre uma das tecnologias mais revolucionárias da história humana, a Inteligência Artificial. Este livro online, bem como os [cursos gratuitos](https://www.datascienceacademy.com.br/cursosgratuitos) que oferecemos em nosso portal, fazem parte da nossa contribuição para ajudar a disseminar o conhecimento e a educação, tão importantes para a evolução do país.


Hoje o Deep Learning Book é uma referência em língua portuguesa, sendo usado aliás como referência em trabalhos de Mestrado e Doutorado, trabalhos de conclusão de curso de Graduação e Pós-Graduação e desde que foi lançado recebe um volume cada vez maior de acessos. Nosso objetivo vem sendo alcançado e estamos ajudando pessoas interessadas em aprender Inteligência Artificial. 


Para concluir este trabalho, vamos fazer uma revisão do processo de aprendizado de máquina com as 10 últimas regras do Guia Definitivo de Machine Learning. 


**E ao final do capítulo teremos uma surpresa para você.**


Boa leitura.




---


Inteligência Artificial já está presente em nossas vidas. Observe a sua volta. Aplicações de filtro de spam, sistemas de reconhecimento facial no celular, chatbots de atendimento ao cliente, sistemas de recomendação e muito, muito mais.


Pelo menos desde a década de 50 que cientistas ao redor do mundo estão tentando reproduzir nas máquinas o que considera-se como inteligência, reproduzindo especialmente o sistema de aprendizado do cérebro humano. 


Mas foi a partir do surgimento do Big Data, e em especial do processamento paralelo em GPUs, pouco mais de uma década atrás, que a Inteligência Artificial cresceu de forma exponencial, permitindo a criação de aplicações maravilhosas em áreas como Visão Computacional e Processamento de Linguagem Natural, notadamente as tarefas mais complexas de reproduzir em computadores.


E uma sub-área da IA, Machine Learning, teve os avanços mais incríveis, quando uma arquitetura em especial, Deep Learning, conseguiu obter resultados do estado da arte.


Mas se você acompanhou este livro com atenção deve ter percebido que muito do que fazemos em IA se resume a Matemática com programação de computadores, através do treinamento com muitos, muitos dados. Aplicando as mais diversas técnicas matemáticas e estatísticas, preparamos os dados, treinamos algoritmos via programação e modelos são criados para os mais devidos fins, resolvendo problemas de negócio, ajudando tomadores de decisão ou alimentando aplicações. E muito ainda está por vir, à medida que as empresas percebem os benefícios de aplicações baseadas em IA.


Aqui estão as 10 regras finais do Guia Definitivo de Machine Learning.


**Regra 41: Precisamos de Dados**


Você pode pensar: “Espere, isso é óbvio”. Você ficaria surpreso com a quantidade de pessoas que não compreendem que IA, Machine Learning ou Deep Learning não existem sem dados. Precisamos de dados históricos para que, através de algoritmos, possamos detectar padrões e então o modelo realizar suas previsões ou tarefa final.


Para compreender bem isso, basta fazer uma analogia com o aprendizado de uma criança. Como uma criança aprende a falar? Ouvindo sua família falar o tempo todo (a voz representa os dados nesse caso). Como uma criança aprende a escrever? Quando alguém a ensina através de exercícios (que nesse caso representam os dados). Ou seja, uma criança aprende à medida que é exposta a dados, que são processados através dos sentidos e criam no cérebro a memória que será usada pela criança durante toda a sua vida.


Se a sua empresa ainda não está cuidando dos dados com o devido valor, ela já está bem atrasada. Os dados são agora um ativo corporativo mais importante do que nunca e que permite o uso e benefícios de Inteligência Artificial.


Isso explica por que a engenharia de dados também cresceu muito nos últimos anos, uma vez que precisamos de mecanismos, sistemas e ferramentas para coletar, armazenar e processar os dados.


**Regra 42: Os Dados Raramente Estarão Prontos Para Uso**


E por isso a etapa de limpeza e pré-processamentos dados ainda é parte crucial do trabalho. São várias técnicas que devem ser usadas de acordo com o conjunto de dados.


Raramente os dados estarão no formato ideal para o processo de análise ou construção dos modelos. A criação de pipelines de dados é o que permite passar os dados por uma “linha de produção”, para que os dados cheguem ao seu destino em condições de serem usados. Para compreender isso faça uma analogia: O petróleo bruto poderia ser usado como combustível em um automóvel? Não. Logo, o petróleo passa a ser valioso quando é processado e gera como produto final o combustível que, aí sim, ajudará a resolver diversos problemas (embora também crie outros). Com os dados a ideia é a mesma.


**Regra 43: Não Há Arquitetura Ideal em Machine Learning**


Machine Learning está distante da perfeição. Cada arquitetura tem pontos fortes e fracos e nosso trabalho não é buscar perfeição e sim encontrar a melhor solução possível, uma aproximação, que será suficiente para resolver determinado problema de negócio.


Não desperdice seu tempo buscando o modelo perfeito. Mantenha o foco na solução do problema e tente encontrar o modelo que oferece a melhor aproximação com o menor esforço.


**Regra 44: Machine Learning Não é Aplicação Pronta**


Um equívoco muito comum cometido por iniciantes é achar que Machine Learning é uma aplicação pronta, linda e maravilhosa, que pode ser usada imediatamente. Não. Machine Learning cria um modelo e ainda precisamos dar um passo adiante e decidir como usar esse modelo. 


O modelo pode ser usado via linha de comando em nossas máquinas, pode ser integrado em uma aplicação web, uma aplicação para smartphone, podemos criar uma API usando um serviço em nuvem. As opções são inúmeras, mas Machine Learning concentra o conhecimento para criação do modelo e não criação da uma aplicação completa.


**Regra 45: Use Transfer Learning Sempre Que Possível**


Quando seu conjunto de dados consiste em dados não estruturados, como imagens, texto ou áudio, é recomendável pegar carona em modelos pré-treinados existentes. 


Para ajustar um classificador de imagens, você pode precisar de apenas 10 exemplos por classe, por exemplo. Frameworks como TensorFlow e PyTorch oferecem uma variedade de modelos pré-treinados. Você não precisa reinventar a roda ou gastar horas ou mesmo dias para treinar um modelo a partir do zero. Aprenda a trabalhar com Transfer Learning e mantenha o foco no seu objetivo. Seu objetivo não é criar modelos e sim resolver problemas de negócio. Aprenda a usar Transfer Learning.


**Regra 46: Generalização Através de Regularização**


Ao criar um modelo de Machine Learning queremos que ele seja generalizável, ou seja, depois de aprender com dados de treino o modelo deve ser capaz de fazer previsões ou extrair padrões em novos conjuntos de dados. Generalização significa que o modelo não deve aprender os detalhes dos dados de treino, mas sim a relação matemática geral nos dados.


Uma maneira de ajudar seu modelo a generalizar além do conjunto de treinamento é colocar penalidades no tamanho dos pesos w do seu modelo. Isso se chama regularização. Duas penalidades populares são a norma de Manhattan (ou norma L₁) e a norma euclidiana “padrão” (ou norma L₂).


Ao regularizar, verifique se todos os recursos são dimensionados para ordenar a unidade (sem dimensão) por padronização. Isso garante que a penalidade afete todos os pesos igualmente. As estimativas de Ball Park podem ser obtidas estudando dois casos de regressão linear que podem ser resolvidos de forma fechada, a saber, Regressão Lasso (isto é, L₁ regularização λ₁|w|₁ de pesos w) e Regressão de Ridge (L₂ regularização λ₂|w|²₂ de pesos W). Quando os recursos são centrados e não correlacionados, suas soluções podem ser expressas em termos da solução não penalizada. 


A Regularização LASSO corta (ou trunca) todos os coeficientes não penalizados abaixo de λ₁. Um ponto de partida razoável pode, portanto, ser λ₁ = 0,1. 


A Regularização Ridge, por outro lado, apenas diminui o tamanho para zero. Para escolher λ₂, você pode querer levar em consideração até que ponto seu sistema está sobreajustado (overfitting). 


Uma nota de advertência: O Scikit-Learn usa convenções ligeiramente diferentes para os objetivos em Ridge e Lasso.


**Regra 47: Qual o Volume de Dados Ideal Para Treinar Modelos de Machine Learning?**


Não existe regra mágica, mas a figura abaixo apresenta um ponto de partida:


![formula](https://www.deeplearningbook.com.br/wp-content/uploads/2022/11/formula-1024x274.png)


Número de amostras (m), recursos (n) e parâmetros de modelo (d) formam a santíssima trindade do aprendizado de máquina. A maioria das regras de ouro pode ser amplamente trazida de volta a esta tríade.


**Regra 48: Quantas Amostras Para Treinar Modelos de Machine Learning?**


O desempenho normalmente escala como log m, onde m é o número de amostras e geralmente é limitado pelo ruído nos rótulos. Portanto, quando os dados de treinamento são rotulados por humanos, esse limite geralmente corresponde ao desempenho de nível humano. Logo, pode ser útil focar na qualidade dos dados, em vez da quantidade, conforme sugerido pelo movimento de IA centrada em dados.


Em geral, mais amostras são necessárias para problemas de regressão do que para problemas de classificação. 


**Regra 49: Quantos Parâmetros?**


Lembre-se de sua aula de álgebra linear lá no ensino médio, que para resolver um sistema linear com d graus de liberdade, você precisa de d restrições. Para regressão linear, cada amostra é uma restrição. 


Portanto, para fixar os parâmetros d, você precisa de pelo menos tantas amostras — caso contrário, seu sistema é considerado subdeterminado. De forma mais geral, ao interpretar os parâmetros de um modelo como graus de liberdade, uma heurística comum é um sistema dez vezes sobredeterminado:


d ≤ m/10 


embora limites mais conservadores para redes neurais, como d ≤ m/50, também sejam sugeridos. Por sua vez, ter determinado o número de parâmetros, d, pode ajudá-lo a decidir se o número de recursos, n, precisa ser reduzido.


No entanto, é necessário cautela porque para muitos modelos, por exemplo, modelos probabilísticos, o número de restrições pode ser O(n) e independente do tamanho da amostra m.


**Regra 50: Não Termina Aqui. Isso Foi Só o Começo**


Existem 3 fases do aprendizado:


* Fase 1 – Você não sabe o que não sabe.
* Fase 2 – Você sabe o que não sabe.
* Fase 3 – Você sabe o que sabe.


Ao finalizar a leitura deste livro esperamos que você tenha passado da Fase 1 para a Fase 2, quando o assunto é aprendizado de máquina. 


Há muito ainda para aprender sobre Inteligência Artificial e este livro foi apenas o começo! 


Sucesso na sua jornada!




---


E agora sua surpresa.


Para ajudar na sua capacitação estamos lançando a mais nova Formação DSA:


### [**Formação Engenheiro de Inteligência Artificial**](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)


Um programa que traz para você as mais modernas técnicas de IA através de uma série de laboratórios práticos e projetos realmente incríveis em diferentes áreas de negócio. 


Veja abaixo a sequência e descrição dos 6 cursos da Formação Engenheiro de IA:


**1- [Deep Learning Para Aplicações de IA com PyTorch e Lightning](https://www.datascienceacademy.com.br/course/deep-learning-para-aplicacoes-de-ia-com-pytorch-e-lightning)**


Este é o ponto de partida da Formação. Aqui você aprenderá como construir modelos de Deep Learning, as principais arquiteturas, como pré-processar os dados, como otimizar os modelos e como realizar o deploy. Os frameworks PyTorch e Pytorch Lightning serão usados em Linguagem Python.


Este é um curso completo de Deep Learning, hoje a principal técnica de Inteligência Artificial, com o framework de maior sucesso da atualidade, o PyTorch. E vamos trazer também para você o Lightning, biblioteca que simplifica a forma como criamos modelos com o PyTorch aumentando a produtividade na construção dos modelos e a performance das aplicações de Inteligência Artificial.


Depois de mais de 5 anos capacitando milhares de alunos em Deep Learning através de diversos outros treinamentos, neste novo curso oferecido pela DSA você vai desenvolver suas habilidades em IA com o estado da arte em Deep Learning através de Estudos de Caso, Labs, Mini-Projetos e Projetos. 


**2- [Análise de Imagens com Inteligência Artificial](https://www.datascienceacademy.com.br/course/analise-de-imagens-com-inteligencia-artificial)**


Aqui é onde a diversão começa. Você vai trabalhar com uma das principais áreas da Inteligência Artificial, a Visão Computacional. Através de labs e projetos de diferentes áreas, você aprenderá como construir modelos de IA capazes de detectar, classificar e segmentar imagens dos mais variados tipos.


Este curso traz para você modernas técnicas de Visão Computacional para análise de todo tipo de imagem, como imagens médicas, imagens de satélite, imagens de plantações agrícolas, imagens de objetos, imagens de pessoas para reconhecimento facial e você ainda vai aprender como criar seu próprio dataset de imagens customizado e como detectar Deep Fakes.


Visão Computacional é atualmente uma das principais áreas da Inteligência Artificial. Um conjunto de técnicas para carregar, manipular, tratar, processar, detectar, prever, segmentar e analisar imagens. E neste curso, de alto nível, vamos trazer as principais técnicas e ferramentas para você, incluindo Vision Transformers.


O curso é inteiramente orientado a projetos. Isso significa que a cada capítulo você vai trabalhar em um problema do mundo real com dados reais (disponíveis publicamente) e então vai desenvolver suas habilidades através de aulas teóricas que exploram os principais conceitos e aulas práticas que implementam a solução. E em um dos capítulos vamos ensinar como você cria seu próprio dataset de imagens customizado.


**3- [Processamento de Linguagem Natural com Transformers](https://www.datascienceacademy.com.br/course/processamento-de-linguagem-natural-com-transformers)**


O terceiro curso da Formação é sobre a área mais complexa da Inteligência Artificial. Pelo menos até o surgimento dos modelos Transformers, que estão revolucionando a forma como ensinamos o computador a fazer traduções de texto, reconhecer a voz humana ou classificar textos e mensagens por tópicos


Você deseja aplicar o Processamento de Linguagem Natural (PLN), com as mais modernas técnicas de IA, para resolver diferentes problemas nas áreas de Direito, Atendimento ao Cliente, Reconhecimento de Voz, Análise de Sentimento, Classificação de Texto e Detecção de Fake News? Então este curso é para você.


Este não é apenas um curso de PLN. Este curso traz para você o estado da arte em Inteligência Artificial com Transformers e aplicações práticas em diversas áreas com projetos completos, incluindo a Dorothy, o Bot Transformer que você irá construir para automatizar o atendimento ao cliente. Imperdível.


**4- [Análise e Previsão de Séries Temporais com Inteligência Artificial](https://www.datascienceacademy.com.br/course/analise-e-previsao-de-series-temporais-com-inteligencia-artificial)**


No quarto curso da Formação você vai aplicar Inteligência Artificial em problemas de negócio que requerem análise ao longo do tempo. Os principais métodos clássicos para análise de séries temporais, também serão abordados no começo do curso.


A análise de séries temporais é provavelmente uma das mais importantes habilidades dentro do universo da Ciência de Dados. Afinal, o fator tempo é determinante em quase tudo que ocorre no mundo dos negócios.


E com os avanços das técnicas de Inteligência Artificial conseguimos construir modelos cada vez mais precisos, capazes de entregar respostas aos tomadores de decisão que podem fazer toda a diferença nas estratégias corporativas.


Este é um curso de alto nível que vai trazer para você modernas técnicas de IA aplicadas a análise e previsão de séries temporais e comparar essas técnicas com os métodos clássicos (que também são abordados no curso).


**5- [Cyber Security Data Science](https://www.datascienceacademy.com.br/course/cyber-security-data-science)**


No curso número 5 você vai aplicar técnicas de Data Science e Inteligência Artificial para resolver problemas na área de segurança cibernética. Um curso incrível não apenas para quem deseja aplicar análise de dados na área de segurança, mas também em problemas comuns na área de tecnologia, como configuração de rede, configuração de sistema operacional e segurança de acesso.


Além de conhecer as principais ameaças e riscos cibernéticos, você vai aprender quais são as estratégias ideais de segurança, como trabalhar com dados reais e como usar Ciência de Dados e IA para detectar anomalias, tentativas de invasão, ataques a bancos de dados e dispositivos IoT, e muito mais.


**6- [Infraestrutura Como Código com Terraform, AWS, Azure e Databricks](https://www.datascienceacademy.com.br/course/infraestrutura-como-codigo-com-terraform-aws-azure-e-databricks)**


O sexto e último curso é a cereja do bolo. Você vai desenvolver as habilidades necessárias para criar a infraestrutura necessária para treinar seus modelos, fazer o deploy e publicar aplicações usando IaC (Infraestrutura Como Código) através do Terraform, ferramenta open-source que simplifica de forma considerável a maneira como criamos, usamos e então desfazemos a infraestrutura necessária para o trabalho com Data Science, Machine Learning e IA.


IaC (Infraestrutura Como Código) nasceu no universo DevOps, mas rapidamente chegou à área de dados para ajudar no trabalho de Engenheiros de Dados, Engenheiros de Machine Learning, Arquitetos de Dados, Cientistas de Dados e Engenheiros de IA.


Além do Terraform você vai trabalhar com AWS, Azure e Databricks através de diversos Labs e Projetos. O conhecimento que você irá adquirir neste curso vai colocá-lo muito a frente de outros profissionais do mercado, aumentando de forma considerável sua empregabilidade na área de dados, independente da sua função.


Não é incrível?


**Mas espere, tem mais.**


Assim como as demais Formações DSA você ainda recebe os Módulos Extras de Capacitação Profissional com os seguintes cursos de bônus:


* Introdução à Lógica de Programação
* Sistema Operacional Linux, Docker e Kubernetes
* Governança de Dados
* Empreendedorismo em Data Science, IA e Blockchain
* Web Scraping e Análise de Dados
* Soft Skills – Desenvolvendo Suas Habilidades Comportamentais
* E-Gov Analytics
* Machine Learning com JavaScript e Go
* Data Science e Machine Learning com Linguagem Julia


A Formação está disponível em nosso portal. Confira:


[Formação Engenheiro de IA](https://www.datascienceacademy.com.br/bundle/formacao-engenheiro-de-ia)
---------------------------------------------------------------------------------------------------


Obrigado


Equipe DSA


